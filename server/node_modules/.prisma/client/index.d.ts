
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model vmware
 * 
 */
export type vmware = $Result.DefaultSelection<Prisma.$vmwarePayload>
/**
 * Model cisco
 * 
 */
export type cisco = $Result.DefaultSelection<Prisma.$ciscoPayload>
/**
 * Model oracle
 * 
 */
export type oracle = $Result.DefaultSelection<Prisma.$oraclePayload>
/**
 * Model microsoft
 * 
 */
export type microsoft = $Result.DefaultSelection<Prisma.$microsoftPayload>
/**
 * Model hackernews
 * 
 */
export type hackernews = $Result.DefaultSelection<Prisma.$hackernewsPayload>
/**
 * Model Redhat
 * 
 */
export type Redhat = $Result.DefaultSelection<Prisma.$RedhatPayload>
/**
 * Model Redhat_Document
 * 
 */
export type Redhat_Document = $Result.DefaultSelection<Prisma.$Redhat_DocumentPayload>
/**
 * Model Redhat_Tracking
 * 
 */
export type Redhat_Tracking = $Result.DefaultSelection<Prisma.$Redhat_TrackingPayload>
/**
 * Model Redhat_AggregateSeverity
 * 
 */
export type Redhat_AggregateSeverity = $Result.DefaultSelection<Prisma.$Redhat_AggregateSeverityPayload>
/**
 * Model Redhat_Distribution
 * 
 */
export type Redhat_Distribution = $Result.DefaultSelection<Prisma.$Redhat_DistributionPayload>
/**
 * Model Redhat_Tlp
 * 
 */
export type Redhat_Tlp = $Result.DefaultSelection<Prisma.$Redhat_TlpPayload>
/**
 * Model Redhat_Document_Note
 * 
 */
export type Redhat_Document_Note = $Result.DefaultSelection<Prisma.$Redhat_Document_NotePayload>
/**
 * Model Redhat_Publisher
 * 
 */
export type Redhat_Publisher = $Result.DefaultSelection<Prisma.$Redhat_PublisherPayload>
/**
 * Model Redhat_Document_Reference
 * 
 */
export type Redhat_Document_Reference = $Result.DefaultSelection<Prisma.$Redhat_Document_ReferencePayload>
/**
 * Model Redhat_Vulnerability
 * 
 */
export type Redhat_Vulnerability = $Result.DefaultSelection<Prisma.$Redhat_VulnerabilityPayload>
/**
 * Model Redhat_Vulnerability_Id
 * 
 */
export type Redhat_Vulnerability_Id = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_IdPayload>
/**
 * Model Redhat_Vulnerability_Note
 * 
 */
export type Redhat_Vulnerability_Note = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_NotePayload>
/**
 * Model Redhat_Vulnerability_ProductStatus
 * 
 */
export type Redhat_Vulnerability_ProductStatus = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
/**
 * Model Redhat_Vulnerability_Reference
 * 
 */
export type Redhat_Vulnerability_Reference = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_ReferencePayload>
/**
 * Model Redhat_Vulnerability_Remediation
 * 
 */
export type Redhat_Vulnerability_Remediation = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_RemediationPayload>
/**
 * Model Redhat_Vulnerability_RestartRequired
 * 
 */
export type Redhat_Vulnerability_RestartRequired = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
/**
 * Model Redhat_Vulnerability_Score
 * 
 */
export type Redhat_Vulnerability_Score = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_ScorePayload>
/**
 * Model Redhat_Vulnerability_CvssV3
 * 
 */
export type Redhat_Vulnerability_CvssV3 = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_CvssV3Payload>
/**
 * Model Redhat_Vulnerability_Threat
 * 
 */
export type Redhat_Vulnerability_Threat = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_ThreatPayload>
/**
 * Model Redhat_Vulnerability_Cwe
 * 
 */
export type Redhat_Vulnerability_Cwe = $Result.DefaultSelection<Prisma.$Redhat_Vulnerability_CwePayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Vmwares
 * const vmwares = await prisma.vmware.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Vmwares
   * const vmwares = await prisma.vmware.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.vmware`: Exposes CRUD operations for the **vmware** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vmwares
    * const vmwares = await prisma.vmware.findMany()
    * ```
    */
  get vmware(): Prisma.vmwareDelegate<ExtArgs>;

  /**
   * `prisma.cisco`: Exposes CRUD operations for the **cisco** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Ciscos
    * const ciscos = await prisma.cisco.findMany()
    * ```
    */
  get cisco(): Prisma.ciscoDelegate<ExtArgs>;

  /**
   * `prisma.oracle`: Exposes CRUD operations for the **oracle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Oracles
    * const oracles = await prisma.oracle.findMany()
    * ```
    */
  get oracle(): Prisma.oracleDelegate<ExtArgs>;

  /**
   * `prisma.microsoft`: Exposes CRUD operations for the **microsoft** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Microsofts
    * const microsofts = await prisma.microsoft.findMany()
    * ```
    */
  get microsoft(): Prisma.microsoftDelegate<ExtArgs>;

  /**
   * `prisma.hackernews`: Exposes CRUD operations for the **hackernews** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hackernews
    * const hackernews = await prisma.hackernews.findMany()
    * ```
    */
  get hackernews(): Prisma.hackernewsDelegate<ExtArgs>;

  /**
   * `prisma.redhat`: Exposes CRUD operations for the **Redhat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhats
    * const redhats = await prisma.redhat.findMany()
    * ```
    */
  get redhat(): Prisma.RedhatDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Document`: Exposes CRUD operations for the **Redhat_Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Documents
    * const redhat_Documents = await prisma.redhat_Document.findMany()
    * ```
    */
  get redhat_Document(): Prisma.Redhat_DocumentDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Tracking`: Exposes CRUD operations for the **Redhat_Tracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Trackings
    * const redhat_Trackings = await prisma.redhat_Tracking.findMany()
    * ```
    */
  get redhat_Tracking(): Prisma.Redhat_TrackingDelegate<ExtArgs>;

  /**
   * `prisma.redhat_AggregateSeverity`: Exposes CRUD operations for the **Redhat_AggregateSeverity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_AggregateSeverities
    * const redhat_AggregateSeverities = await prisma.redhat_AggregateSeverity.findMany()
    * ```
    */
  get redhat_AggregateSeverity(): Prisma.Redhat_AggregateSeverityDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Distribution`: Exposes CRUD operations for the **Redhat_Distribution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Distributions
    * const redhat_Distributions = await prisma.redhat_Distribution.findMany()
    * ```
    */
  get redhat_Distribution(): Prisma.Redhat_DistributionDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Tlp`: Exposes CRUD operations for the **Redhat_Tlp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Tlps
    * const redhat_Tlps = await prisma.redhat_Tlp.findMany()
    * ```
    */
  get redhat_Tlp(): Prisma.Redhat_TlpDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Document_Note`: Exposes CRUD operations for the **Redhat_Document_Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Document_Notes
    * const redhat_Document_Notes = await prisma.redhat_Document_Note.findMany()
    * ```
    */
  get redhat_Document_Note(): Prisma.Redhat_Document_NoteDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Publisher`: Exposes CRUD operations for the **Redhat_Publisher** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Publishers
    * const redhat_Publishers = await prisma.redhat_Publisher.findMany()
    * ```
    */
  get redhat_Publisher(): Prisma.Redhat_PublisherDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Document_Reference`: Exposes CRUD operations for the **Redhat_Document_Reference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Document_References
    * const redhat_Document_References = await prisma.redhat_Document_Reference.findMany()
    * ```
    */
  get redhat_Document_Reference(): Prisma.Redhat_Document_ReferenceDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability`: Exposes CRUD operations for the **Redhat_Vulnerability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerabilities
    * const redhat_Vulnerabilities = await prisma.redhat_Vulnerability.findMany()
    * ```
    */
  get redhat_Vulnerability(): Prisma.Redhat_VulnerabilityDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Id`: Exposes CRUD operations for the **Redhat_Vulnerability_Id** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Ids
    * const redhat_Vulnerability_Ids = await prisma.redhat_Vulnerability_Id.findMany()
    * ```
    */
  get redhat_Vulnerability_Id(): Prisma.Redhat_Vulnerability_IdDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Note`: Exposes CRUD operations for the **Redhat_Vulnerability_Note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Notes
    * const redhat_Vulnerability_Notes = await prisma.redhat_Vulnerability_Note.findMany()
    * ```
    */
  get redhat_Vulnerability_Note(): Prisma.Redhat_Vulnerability_NoteDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_ProductStatus`: Exposes CRUD operations for the **Redhat_Vulnerability_ProductStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_ProductStatuses
    * const redhat_Vulnerability_ProductStatuses = await prisma.redhat_Vulnerability_ProductStatus.findMany()
    * ```
    */
  get redhat_Vulnerability_ProductStatus(): Prisma.Redhat_Vulnerability_ProductStatusDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Reference`: Exposes CRUD operations for the **Redhat_Vulnerability_Reference** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_References
    * const redhat_Vulnerability_References = await prisma.redhat_Vulnerability_Reference.findMany()
    * ```
    */
  get redhat_Vulnerability_Reference(): Prisma.Redhat_Vulnerability_ReferenceDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Remediation`: Exposes CRUD operations for the **Redhat_Vulnerability_Remediation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Remediations
    * const redhat_Vulnerability_Remediations = await prisma.redhat_Vulnerability_Remediation.findMany()
    * ```
    */
  get redhat_Vulnerability_Remediation(): Prisma.Redhat_Vulnerability_RemediationDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_RestartRequired`: Exposes CRUD operations for the **Redhat_Vulnerability_RestartRequired** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_RestartRequireds
    * const redhat_Vulnerability_RestartRequireds = await prisma.redhat_Vulnerability_RestartRequired.findMany()
    * ```
    */
  get redhat_Vulnerability_RestartRequired(): Prisma.Redhat_Vulnerability_RestartRequiredDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Score`: Exposes CRUD operations for the **Redhat_Vulnerability_Score** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Scores
    * const redhat_Vulnerability_Scores = await prisma.redhat_Vulnerability_Score.findMany()
    * ```
    */
  get redhat_Vulnerability_Score(): Prisma.Redhat_Vulnerability_ScoreDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_CvssV3`: Exposes CRUD operations for the **Redhat_Vulnerability_CvssV3** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_CvssV3s
    * const redhat_Vulnerability_CvssV3s = await prisma.redhat_Vulnerability_CvssV3.findMany()
    * ```
    */
  get redhat_Vulnerability_CvssV3(): Prisma.Redhat_Vulnerability_CvssV3Delegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Threat`: Exposes CRUD operations for the **Redhat_Vulnerability_Threat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Threats
    * const redhat_Vulnerability_Threats = await prisma.redhat_Vulnerability_Threat.findMany()
    * ```
    */
  get redhat_Vulnerability_Threat(): Prisma.Redhat_Vulnerability_ThreatDelegate<ExtArgs>;

  /**
   * `prisma.redhat_Vulnerability_Cwe`: Exposes CRUD operations for the **Redhat_Vulnerability_Cwe** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Redhat_Vulnerability_Cwes
    * const redhat_Vulnerability_Cwes = await prisma.redhat_Vulnerability_Cwe.findMany()
    * ```
    */
  get redhat_Vulnerability_Cwe(): Prisma.Redhat_Vulnerability_CweDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.11.0
   * Query Engine version: efd2449663b3d73d637ea1fd226bafbcf45b3102
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    vmware: 'vmware',
    cisco: 'cisco',
    oracle: 'oracle',
    microsoft: 'microsoft',
    hackernews: 'hackernews',
    Redhat: 'Redhat',
    Redhat_Document: 'Redhat_Document',
    Redhat_Tracking: 'Redhat_Tracking',
    Redhat_AggregateSeverity: 'Redhat_AggregateSeverity',
    Redhat_Distribution: 'Redhat_Distribution',
    Redhat_Tlp: 'Redhat_Tlp',
    Redhat_Document_Note: 'Redhat_Document_Note',
    Redhat_Publisher: 'Redhat_Publisher',
    Redhat_Document_Reference: 'Redhat_Document_Reference',
    Redhat_Vulnerability: 'Redhat_Vulnerability',
    Redhat_Vulnerability_Id: 'Redhat_Vulnerability_Id',
    Redhat_Vulnerability_Note: 'Redhat_Vulnerability_Note',
    Redhat_Vulnerability_ProductStatus: 'Redhat_Vulnerability_ProductStatus',
    Redhat_Vulnerability_Reference: 'Redhat_Vulnerability_Reference',
    Redhat_Vulnerability_Remediation: 'Redhat_Vulnerability_Remediation',
    Redhat_Vulnerability_RestartRequired: 'Redhat_Vulnerability_RestartRequired',
    Redhat_Vulnerability_Score: 'Redhat_Vulnerability_Score',
    Redhat_Vulnerability_CvssV3: 'Redhat_Vulnerability_CvssV3',
    Redhat_Vulnerability_Threat: 'Redhat_Vulnerability_Threat',
    Redhat_Vulnerability_Cwe: 'Redhat_Vulnerability_Cwe'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'vmware' | 'cisco' | 'oracle' | 'microsoft' | 'hackernews' | 'redhat' | 'redhat_Document' | 'redhat_Tracking' | 'redhat_AggregateSeverity' | 'redhat_Distribution' | 'redhat_Tlp' | 'redhat_Document_Note' | 'redhat_Publisher' | 'redhat_Document_Reference' | 'redhat_Vulnerability' | 'redhat_Vulnerability_Id' | 'redhat_Vulnerability_Note' | 'redhat_Vulnerability_ProductStatus' | 'redhat_Vulnerability_Reference' | 'redhat_Vulnerability_Remediation' | 'redhat_Vulnerability_RestartRequired' | 'redhat_Vulnerability_Score' | 'redhat_Vulnerability_CvssV3' | 'redhat_Vulnerability_Threat' | 'redhat_Vulnerability_Cwe'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      vmware: {
        payload: Prisma.$vmwarePayload<ExtArgs>
        fields: Prisma.vmwareFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vmwareFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vmwareFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          findFirst: {
            args: Prisma.vmwareFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vmwareFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          findMany: {
            args: Prisma.vmwareFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>[]
          }
          create: {
            args: Prisma.vmwareCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          createMany: {
            args: Prisma.vmwareCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.vmwareDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          update: {
            args: Prisma.vmwareUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          deleteMany: {
            args: Prisma.vmwareDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.vmwareUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.vmwareUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$vmwarePayload>
          }
          aggregate: {
            args: Prisma.VmwareAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateVmware>
          }
          groupBy: {
            args: Prisma.vmwareGroupByArgs<ExtArgs>,
            result: $Utils.Optional<VmwareGroupByOutputType>[]
          }
          count: {
            args: Prisma.vmwareCountArgs<ExtArgs>,
            result: $Utils.Optional<VmwareCountAggregateOutputType> | number
          }
        }
      }
      cisco: {
        payload: Prisma.$ciscoPayload<ExtArgs>
        fields: Prisma.ciscoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ciscoFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ciscoFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          findFirst: {
            args: Prisma.ciscoFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ciscoFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          findMany: {
            args: Prisma.ciscoFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>[]
          }
          create: {
            args: Prisma.ciscoCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          createMany: {
            args: Prisma.ciscoCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ciscoDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          update: {
            args: Prisma.ciscoUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          deleteMany: {
            args: Prisma.ciscoDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ciscoUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ciscoUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ciscoPayload>
          }
          aggregate: {
            args: Prisma.CiscoAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateCisco>
          }
          groupBy: {
            args: Prisma.ciscoGroupByArgs<ExtArgs>,
            result: $Utils.Optional<CiscoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ciscoCountArgs<ExtArgs>,
            result: $Utils.Optional<CiscoCountAggregateOutputType> | number
          }
        }
      }
      oracle: {
        payload: Prisma.$oraclePayload<ExtArgs>
        fields: Prisma.oracleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.oracleFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.oracleFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          findFirst: {
            args: Prisma.oracleFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.oracleFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          findMany: {
            args: Prisma.oracleFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>[]
          }
          create: {
            args: Prisma.oracleCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          createMany: {
            args: Prisma.oracleCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.oracleDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          update: {
            args: Prisma.oracleUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          deleteMany: {
            args: Prisma.oracleDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.oracleUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.oracleUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$oraclePayload>
          }
          aggregate: {
            args: Prisma.OracleAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOracle>
          }
          groupBy: {
            args: Prisma.oracleGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OracleGroupByOutputType>[]
          }
          count: {
            args: Prisma.oracleCountArgs<ExtArgs>,
            result: $Utils.Optional<OracleCountAggregateOutputType> | number
          }
        }
      }
      microsoft: {
        payload: Prisma.$microsoftPayload<ExtArgs>
        fields: Prisma.microsoftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.microsoftFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.microsoftFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          findFirst: {
            args: Prisma.microsoftFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.microsoftFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          findMany: {
            args: Prisma.microsoftFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>[]
          }
          create: {
            args: Prisma.microsoftCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          createMany: {
            args: Prisma.microsoftCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.microsoftDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          update: {
            args: Prisma.microsoftUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          deleteMany: {
            args: Prisma.microsoftDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.microsoftUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.microsoftUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$microsoftPayload>
          }
          aggregate: {
            args: Prisma.MicrosoftAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateMicrosoft>
          }
          groupBy: {
            args: Prisma.microsoftGroupByArgs<ExtArgs>,
            result: $Utils.Optional<MicrosoftGroupByOutputType>[]
          }
          count: {
            args: Prisma.microsoftCountArgs<ExtArgs>,
            result: $Utils.Optional<MicrosoftCountAggregateOutputType> | number
          }
        }
      }
      hackernews: {
        payload: Prisma.$hackernewsPayload<ExtArgs>
        fields: Prisma.hackernewsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.hackernewsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.hackernewsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          findFirst: {
            args: Prisma.hackernewsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.hackernewsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          findMany: {
            args: Prisma.hackernewsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>[]
          }
          create: {
            args: Prisma.hackernewsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          createMany: {
            args: Prisma.hackernewsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.hackernewsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          update: {
            args: Prisma.hackernewsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          deleteMany: {
            args: Prisma.hackernewsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.hackernewsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.hackernewsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$hackernewsPayload>
          }
          aggregate: {
            args: Prisma.HackernewsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateHackernews>
          }
          groupBy: {
            args: Prisma.hackernewsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<HackernewsGroupByOutputType>[]
          }
          count: {
            args: Prisma.hackernewsCountArgs<ExtArgs>,
            result: $Utils.Optional<HackernewsCountAggregateOutputType> | number
          }
        }
      }
      Redhat: {
        payload: Prisma.$RedhatPayload<ExtArgs>
        fields: Prisma.RedhatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RedhatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RedhatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          findFirst: {
            args: Prisma.RedhatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RedhatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          findMany: {
            args: Prisma.RedhatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>[]
          }
          create: {
            args: Prisma.RedhatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          createMany: {
            args: Prisma.RedhatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.RedhatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          update: {
            args: Prisma.RedhatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          deleteMany: {
            args: Prisma.RedhatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.RedhatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.RedhatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$RedhatPayload>
          }
          aggregate: {
            args: Prisma.RedhatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat>
          }
          groupBy: {
            args: Prisma.RedhatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<RedhatGroupByOutputType>[]
          }
          count: {
            args: Prisma.RedhatCountArgs<ExtArgs>,
            result: $Utils.Optional<RedhatCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Document: {
        payload: Prisma.$Redhat_DocumentPayload<ExtArgs>
        fields: Prisma.Redhat_DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_DocumentFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_DocumentFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          findFirst: {
            args: Prisma.Redhat_DocumentFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_DocumentFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          findMany: {
            args: Prisma.Redhat_DocumentFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>[]
          }
          create: {
            args: Prisma.Redhat_DocumentCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          createMany: {
            args: Prisma.Redhat_DocumentCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_DocumentDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          update: {
            args: Prisma.Redhat_DocumentUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_DocumentDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_DocumentUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_DocumentUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DocumentPayload>
          }
          aggregate: {
            args: Prisma.Redhat_DocumentAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Document>
          }
          groupBy: {
            args: Prisma.Redhat_DocumentGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_DocumentCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_DocumentCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Tracking: {
        payload: Prisma.$Redhat_TrackingPayload<ExtArgs>
        fields: Prisma.Redhat_TrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_TrackingFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_TrackingFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          findFirst: {
            args: Prisma.Redhat_TrackingFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_TrackingFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          findMany: {
            args: Prisma.Redhat_TrackingFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>[]
          }
          create: {
            args: Prisma.Redhat_TrackingCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          createMany: {
            args: Prisma.Redhat_TrackingCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_TrackingDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          update: {
            args: Prisma.Redhat_TrackingUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_TrackingDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_TrackingUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_TrackingUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TrackingPayload>
          }
          aggregate: {
            args: Prisma.Redhat_TrackingAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Tracking>
          }
          groupBy: {
            args: Prisma.Redhat_TrackingGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_TrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_TrackingCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_TrackingCountAggregateOutputType> | number
          }
        }
      }
      Redhat_AggregateSeverity: {
        payload: Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>
        fields: Prisma.Redhat_AggregateSeverityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_AggregateSeverityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_AggregateSeverityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          findFirst: {
            args: Prisma.Redhat_AggregateSeverityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_AggregateSeverityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          findMany: {
            args: Prisma.Redhat_AggregateSeverityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>[]
          }
          create: {
            args: Prisma.Redhat_AggregateSeverityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          createMany: {
            args: Prisma.Redhat_AggregateSeverityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_AggregateSeverityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          update: {
            args: Prisma.Redhat_AggregateSeverityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_AggregateSeverityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_AggregateSeverityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_AggregateSeverityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_AggregateSeverityPayload>
          }
          aggregate: {
            args: Prisma.Redhat_AggregateSeverityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_AggregateSeverity>
          }
          groupBy: {
            args: Prisma.Redhat_AggregateSeverityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_AggregateSeverityGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_AggregateSeverityCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_AggregateSeverityCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Distribution: {
        payload: Prisma.$Redhat_DistributionPayload<ExtArgs>
        fields: Prisma.Redhat_DistributionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_DistributionFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_DistributionFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          findFirst: {
            args: Prisma.Redhat_DistributionFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_DistributionFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          findMany: {
            args: Prisma.Redhat_DistributionFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>[]
          }
          create: {
            args: Prisma.Redhat_DistributionCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          createMany: {
            args: Prisma.Redhat_DistributionCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_DistributionDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          update: {
            args: Prisma.Redhat_DistributionUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_DistributionDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_DistributionUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_DistributionUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_DistributionPayload>
          }
          aggregate: {
            args: Prisma.Redhat_DistributionAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Distribution>
          }
          groupBy: {
            args: Prisma.Redhat_DistributionGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_DistributionGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_DistributionCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_DistributionCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Tlp: {
        payload: Prisma.$Redhat_TlpPayload<ExtArgs>
        fields: Prisma.Redhat_TlpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_TlpFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_TlpFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          findFirst: {
            args: Prisma.Redhat_TlpFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_TlpFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          findMany: {
            args: Prisma.Redhat_TlpFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>[]
          }
          create: {
            args: Prisma.Redhat_TlpCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          createMany: {
            args: Prisma.Redhat_TlpCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_TlpDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          update: {
            args: Prisma.Redhat_TlpUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_TlpDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_TlpUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_TlpUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_TlpPayload>
          }
          aggregate: {
            args: Prisma.Redhat_TlpAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Tlp>
          }
          groupBy: {
            args: Prisma.Redhat_TlpGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_TlpGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_TlpCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_TlpCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Document_Note: {
        payload: Prisma.$Redhat_Document_NotePayload<ExtArgs>
        fields: Prisma.Redhat_Document_NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Document_NoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Document_NoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Document_NoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Document_NoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          findMany: {
            args: Prisma.Redhat_Document_NoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>[]
          }
          create: {
            args: Prisma.Redhat_Document_NoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          createMany: {
            args: Prisma.Redhat_Document_NoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Document_NoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          update: {
            args: Prisma.Redhat_Document_NoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Document_NoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Document_NoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Document_NoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_NotePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Document_NoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Document_Note>
          }
          groupBy: {
            args: Prisma.Redhat_Document_NoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Document_NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Document_NoteCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Document_NoteCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Publisher: {
        payload: Prisma.$Redhat_PublisherPayload<ExtArgs>
        fields: Prisma.Redhat_PublisherFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_PublisherFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_PublisherFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          findFirst: {
            args: Prisma.Redhat_PublisherFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_PublisherFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          findMany: {
            args: Prisma.Redhat_PublisherFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>[]
          }
          create: {
            args: Prisma.Redhat_PublisherCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          createMany: {
            args: Prisma.Redhat_PublisherCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_PublisherDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          update: {
            args: Prisma.Redhat_PublisherUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_PublisherDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_PublisherUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_PublisherUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_PublisherPayload>
          }
          aggregate: {
            args: Prisma.Redhat_PublisherAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Publisher>
          }
          groupBy: {
            args: Prisma.Redhat_PublisherGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_PublisherGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_PublisherCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_PublisherCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Document_Reference: {
        payload: Prisma.$Redhat_Document_ReferencePayload<ExtArgs>
        fields: Prisma.Redhat_Document_ReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Document_ReferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Document_ReferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Document_ReferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Document_ReferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          findMany: {
            args: Prisma.Redhat_Document_ReferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>[]
          }
          create: {
            args: Prisma.Redhat_Document_ReferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          createMany: {
            args: Prisma.Redhat_Document_ReferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Document_ReferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          update: {
            args: Prisma.Redhat_Document_ReferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Document_ReferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Document_ReferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Document_ReferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Document_ReferencePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Document_ReferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Document_Reference>
          }
          groupBy: {
            args: Prisma.Redhat_Document_ReferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Document_ReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Document_ReferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Document_ReferenceCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability: {
        payload: Prisma.$Redhat_VulnerabilityPayload<ExtArgs>
        fields: Prisma.Redhat_VulnerabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_VulnerabilityFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_VulnerabilityFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          findFirst: {
            args: Prisma.Redhat_VulnerabilityFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_VulnerabilityFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          findMany: {
            args: Prisma.Redhat_VulnerabilityFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>[]
          }
          create: {
            args: Prisma.Redhat_VulnerabilityCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          createMany: {
            args: Prisma.Redhat_VulnerabilityCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_VulnerabilityDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          update: {
            args: Prisma.Redhat_VulnerabilityUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_VulnerabilityDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_VulnerabilityUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_VulnerabilityUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_VulnerabilityPayload>
          }
          aggregate: {
            args: Prisma.Redhat_VulnerabilityAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability>
          }
          groupBy: {
            args: Prisma.Redhat_VulnerabilityGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_VulnerabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_VulnerabilityCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_VulnerabilityCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Id: {
        payload: Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_IdFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_IdFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_IdFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_IdFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_IdFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_IdFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_IdCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_IdCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_IdDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_IdUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_IdDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_IdUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_IdUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_IdPayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_IdAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Id>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_IdGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_IdGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_IdCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_IdCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Note: {
        payload: Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_NoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_NoteFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_NoteFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_NoteFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_NoteFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_NoteFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_NoteCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_NoteCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_NoteDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_NoteUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_NoteDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_NoteUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_NoteUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_NotePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_NoteAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Note>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_NoteGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_NoteCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_NoteCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_ProductStatus: {
        payload: Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_ProductStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_ProductStatusFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_ProductStatusFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_ProductStatusFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_ProductStatusFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_ProductStatusFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_ProductStatusCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_ProductStatusCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_ProductStatusDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_ProductStatusUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_ProductStatusDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_ProductStatusUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_ProductStatusUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_ProductStatusAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_ProductStatus>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_ProductStatusGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ProductStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_ProductStatusCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ProductStatusCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Reference: {
        payload: Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_ReferenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_ReferenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_ReferenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_ReferenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_ReferenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_ReferenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_ReferenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_ReferenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_ReferenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_ReferenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_ReferenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_ReferenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_ReferenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ReferencePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_ReferenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Reference>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_ReferenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ReferenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_ReferenceCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ReferenceCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Remediation: {
        payload: Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_RemediationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_RemediationFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_RemediationFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_RemediationFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_RemediationFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_RemediationFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_RemediationCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_RemediationCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_RemediationDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_RemediationUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_RemediationDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_RemediationUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_RemediationUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RemediationPayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_RemediationAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Remediation>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_RemediationGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_RemediationGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_RemediationCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_RemediationCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_RestartRequired: {
        payload: Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_RestartRequiredFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_RestartRequired>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_RestartRequiredGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_RestartRequiredCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_RestartRequiredCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Score: {
        payload: Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_ScoreFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_ScoreFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_ScoreFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_ScoreFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_ScoreFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_ScoreFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_ScoreCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_ScoreCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_ScoreDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_ScoreUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_ScoreDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_ScoreUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_ScoreUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ScorePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_ScoreAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Score>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_ScoreGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ScoreGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_ScoreCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ScoreCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_CvssV3: {
        payload: Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_CvssV3FieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_CvssV3FindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_CvssV3FindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_CvssV3FindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_CvssV3FindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_CvssV3FindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_CvssV3CreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_CvssV3CreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_CvssV3DeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_CvssV3UpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_CvssV3DeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_CvssV3UpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_CvssV3UpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CvssV3Payload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_CvssV3AggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_CvssV3>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_CvssV3GroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_CvssV3GroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_CvssV3CountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_CvssV3CountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Threat: {
        payload: Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_ThreatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_ThreatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_ThreatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_ThreatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_ThreatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_ThreatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_ThreatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_ThreatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_ThreatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_ThreatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_ThreatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_ThreatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_ThreatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_ThreatPayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_ThreatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Threat>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_ThreatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ThreatGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_ThreatCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_ThreatCountAggregateOutputType> | number
          }
        }
      }
      Redhat_Vulnerability_Cwe: {
        payload: Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>
        fields: Prisma.Redhat_Vulnerability_CweFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Redhat_Vulnerability_CweFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Redhat_Vulnerability_CweFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          findFirst: {
            args: Prisma.Redhat_Vulnerability_CweFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Redhat_Vulnerability_CweFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          findMany: {
            args: Prisma.Redhat_Vulnerability_CweFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>[]
          }
          create: {
            args: Prisma.Redhat_Vulnerability_CweCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          createMany: {
            args: Prisma.Redhat_Vulnerability_CweCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Redhat_Vulnerability_CweDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          update: {
            args: Prisma.Redhat_Vulnerability_CweUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          deleteMany: {
            args: Prisma.Redhat_Vulnerability_CweDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Redhat_Vulnerability_CweUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Redhat_Vulnerability_CweUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$Redhat_Vulnerability_CwePayload>
          }
          aggregate: {
            args: Prisma.Redhat_Vulnerability_CweAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateRedhat_Vulnerability_Cwe>
          }
          groupBy: {
            args: Prisma.Redhat_Vulnerability_CweGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_CweGroupByOutputType>[]
          }
          count: {
            args: Prisma.Redhat_Vulnerability_CweCountArgs<ExtArgs>,
            result: $Utils.Optional<Redhat_Vulnerability_CweCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RedhatCountOutputType
   */

  export type RedhatCountOutputType = {
    vulnerabilities: number
  }

  export type RedhatCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerabilities?: boolean | RedhatCountOutputTypeCountVulnerabilitiesArgs
  }

  // Custom InputTypes

  /**
   * RedhatCountOutputType without action
   */
  export type RedhatCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RedhatCountOutputType
     */
    select?: RedhatCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * RedhatCountOutputType without action
   */
  export type RedhatCountOutputTypeCountVulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_VulnerabilityWhereInput
  }



  /**
   * Count Type Redhat_DocumentCountOutputType
   */

  export type Redhat_DocumentCountOutputType = {
    notes: number
    references: number
    tracking: number
  }

  export type Redhat_DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notes?: boolean | Redhat_DocumentCountOutputTypeCountNotesArgs
    references?: boolean | Redhat_DocumentCountOutputTypeCountReferencesArgs
    tracking?: boolean | Redhat_DocumentCountOutputTypeCountTrackingArgs
  }

  // Custom InputTypes

  /**
   * Redhat_DocumentCountOutputType without action
   */
  export type Redhat_DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_DocumentCountOutputType
     */
    select?: Redhat_DocumentCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Redhat_DocumentCountOutputType without action
   */
  export type Redhat_DocumentCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Document_NoteWhereInput
  }


  /**
   * Redhat_DocumentCountOutputType without action
   */
  export type Redhat_DocumentCountOutputTypeCountReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Document_ReferenceWhereInput
  }


  /**
   * Redhat_DocumentCountOutputType without action
   */
  export type Redhat_DocumentCountOutputTypeCountTrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_TrackingWhereInput
  }



  /**
   * Count Type Redhat_VulnerabilityCountOutputType
   */

  export type Redhat_VulnerabilityCountOutputType = {
    ids: number
    notes: number
    references: number
    remediations: number
    scores: number
    threats: number
  }

  export type Redhat_VulnerabilityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ids?: boolean | Redhat_VulnerabilityCountOutputTypeCountIdsArgs
    notes?: boolean | Redhat_VulnerabilityCountOutputTypeCountNotesArgs
    references?: boolean | Redhat_VulnerabilityCountOutputTypeCountReferencesArgs
    remediations?: boolean | Redhat_VulnerabilityCountOutputTypeCountRemediationsArgs
    scores?: boolean | Redhat_VulnerabilityCountOutputTypeCountScoresArgs
    threats?: boolean | Redhat_VulnerabilityCountOutputTypeCountThreatsArgs
  }

  // Custom InputTypes

  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_VulnerabilityCountOutputType
     */
    select?: Redhat_VulnerabilityCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountIdsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_IdWhereInput
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_NoteWhereInput
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ReferenceWhereInput
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountRemediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_RemediationWhereInput
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountScoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ScoreWhereInput
  }


  /**
   * Redhat_VulnerabilityCountOutputType without action
   */
  export type Redhat_VulnerabilityCountOutputTypeCountThreatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ThreatWhereInput
  }



  /**
   * Count Type Redhat_Vulnerability_RemediationCountOutputType
   */

  export type Redhat_Vulnerability_RemediationCountOutputType = {
    restart_required: number
  }

  export type Redhat_Vulnerability_RemediationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    restart_required?: boolean | Redhat_Vulnerability_RemediationCountOutputTypeCountRestart_requiredArgs
  }

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_RemediationCountOutputType without action
   */
  export type Redhat_Vulnerability_RemediationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RemediationCountOutputType
     */
    select?: Redhat_Vulnerability_RemediationCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Redhat_Vulnerability_RemediationCountOutputType without action
   */
  export type Redhat_Vulnerability_RemediationCountOutputTypeCountRestart_requiredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
  }



  /**
   * Models
   */

  /**
   * Model vmware
   */

  export type AggregateVmware = {
    _count: VmwareCountAggregateOutputType | null
    _min: VmwareMinAggregateOutputType | null
    _max: VmwareMaxAggregateOutputType | null
  }

  export type VmwareMinAggregateOutputType = {
    cve: string | null
    synopsis: string | null
    severity: string | null
    date: string | null
    link: string | null
    detail: string | null
  }

  export type VmwareMaxAggregateOutputType = {
    cve: string | null
    synopsis: string | null
    severity: string | null
    date: string | null
    link: string | null
    detail: string | null
  }

  export type VmwareCountAggregateOutputType = {
    cve: number
    synopsis: number
    severity: number
    date: number
    link: number
    detail: number
    _all: number
  }


  export type VmwareMinAggregateInputType = {
    cve?: true
    synopsis?: true
    severity?: true
    date?: true
    link?: true
    detail?: true
  }

  export type VmwareMaxAggregateInputType = {
    cve?: true
    synopsis?: true
    severity?: true
    date?: true
    link?: true
    detail?: true
  }

  export type VmwareCountAggregateInputType = {
    cve?: true
    synopsis?: true
    severity?: true
    date?: true
    link?: true
    detail?: true
    _all?: true
  }

  export type VmwareAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vmware to aggregate.
     */
    where?: vmwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vmwares to fetch.
     */
    orderBy?: vmwareOrderByWithRelationInput | vmwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vmwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vmwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vmwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vmwares
    **/
    _count?: true | VmwareCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VmwareMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VmwareMaxAggregateInputType
  }

  export type GetVmwareAggregateType<T extends VmwareAggregateArgs> = {
        [P in keyof T & keyof AggregateVmware]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVmware[P]>
      : GetScalarType<T[P], AggregateVmware[P]>
  }




  export type vmwareGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vmwareWhereInput
    orderBy?: vmwareOrderByWithAggregationInput | vmwareOrderByWithAggregationInput[]
    by: VmwareScalarFieldEnum[] | VmwareScalarFieldEnum
    having?: vmwareScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VmwareCountAggregateInputType | true
    _min?: VmwareMinAggregateInputType
    _max?: VmwareMaxAggregateInputType
  }

  export type VmwareGroupByOutputType = {
    cve: string
    synopsis: string
    severity: string
    date: string
    link: string
    detail: string
    _count: VmwareCountAggregateOutputType | null
    _min: VmwareMinAggregateOutputType | null
    _max: VmwareMaxAggregateOutputType | null
  }

  type GetVmwareGroupByPayload<T extends vmwareGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VmwareGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VmwareGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VmwareGroupByOutputType[P]>
            : GetScalarType<T[P], VmwareGroupByOutputType[P]>
        }
      >
    >


  export type vmwareSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cve?: boolean
    synopsis?: boolean
    severity?: boolean
    date?: boolean
    link?: boolean
    detail?: boolean
  }, ExtArgs["result"]["vmware"]>

  export type vmwareSelectScalar = {
    cve?: boolean
    synopsis?: boolean
    severity?: boolean
    date?: boolean
    link?: boolean
    detail?: boolean
  }


  export type $vmwarePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vmware"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cve: string
      synopsis: string
      severity: string
      date: string
      link: string
      detail: string
    }, ExtArgs["result"]["vmware"]>
    composites: {}
  }


  type vmwareGetPayload<S extends boolean | null | undefined | vmwareDefaultArgs> = $Result.GetResult<Prisma.$vmwarePayload, S>

  type vmwareCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<vmwareFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VmwareCountAggregateInputType | true
    }

  export interface vmwareDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vmware'], meta: { name: 'vmware' } }
    /**
     * Find zero or one Vmware that matches the filter.
     * @param {vmwareFindUniqueArgs} args - Arguments to find a Vmware
     * @example
     * // Get one Vmware
     * const vmware = await prisma.vmware.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends vmwareFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareFindUniqueArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Vmware that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {vmwareFindUniqueOrThrowArgs} args - Arguments to find a Vmware
     * @example
     * // Get one Vmware
     * const vmware = await prisma.vmware.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends vmwareFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Vmware that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareFindFirstArgs} args - Arguments to find a Vmware
     * @example
     * // Get one Vmware
     * const vmware = await prisma.vmware.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends vmwareFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareFindFirstArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Vmware that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareFindFirstOrThrowArgs} args - Arguments to find a Vmware
     * @example
     * // Get one Vmware
     * const vmware = await prisma.vmware.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends vmwareFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Vmwares that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vmwares
     * const vmwares = await prisma.vmware.findMany()
     * 
     * // Get first 10 Vmwares
     * const vmwares = await prisma.vmware.findMany({ take: 10 })
     * 
     * // Only select the `cve`
     * const vmwareWithCveOnly = await prisma.vmware.findMany({ select: { cve: true } })
     * 
    **/
    findMany<T extends vmwareFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Vmware.
     * @param {vmwareCreateArgs} args - Arguments to create a Vmware.
     * @example
     * // Create one Vmware
     * const Vmware = await prisma.vmware.create({
     *   data: {
     *     // ... data to create a Vmware
     *   }
     * })
     * 
    **/
    create<T extends vmwareCreateArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareCreateArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Vmwares.
     *     @param {vmwareCreateManyArgs} args - Arguments to create many Vmwares.
     *     @example
     *     // Create many Vmwares
     *     const vmware = await prisma.vmware.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends vmwareCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vmware.
     * @param {vmwareDeleteArgs} args - Arguments to delete one Vmware.
     * @example
     * // Delete one Vmware
     * const Vmware = await prisma.vmware.delete({
     *   where: {
     *     // ... filter to delete one Vmware
     *   }
     * })
     * 
    **/
    delete<T extends vmwareDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareDeleteArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Vmware.
     * @param {vmwareUpdateArgs} args - Arguments to update one Vmware.
     * @example
     * // Update one Vmware
     * const vmware = await prisma.vmware.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends vmwareUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareUpdateArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Vmwares.
     * @param {vmwareDeleteManyArgs} args - Arguments to filter Vmwares to delete.
     * @example
     * // Delete a few Vmwares
     * const { count } = await prisma.vmware.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends vmwareDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, vmwareDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vmwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vmwares
     * const vmware = await prisma.vmware.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends vmwareUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vmware.
     * @param {vmwareUpsertArgs} args - Arguments to update or create a Vmware.
     * @example
     * // Update or create a Vmware
     * const vmware = await prisma.vmware.upsert({
     *   create: {
     *     // ... data to create a Vmware
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vmware we want to update
     *   }
     * })
    **/
    upsert<T extends vmwareUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, vmwareUpsertArgs<ExtArgs>>
    ): Prisma__vmwareClient<$Result.GetResult<Prisma.$vmwarePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Vmwares.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareCountArgs} args - Arguments to filter Vmwares to count.
     * @example
     * // Count the number of Vmwares
     * const count = await prisma.vmware.count({
     *   where: {
     *     // ... the filter for the Vmwares we want to count
     *   }
     * })
    **/
    count<T extends vmwareCountArgs>(
      args?: Subset<T, vmwareCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VmwareCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vmware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VmwareAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VmwareAggregateArgs>(args: Subset<T, VmwareAggregateArgs>): Prisma.PrismaPromise<GetVmwareAggregateType<T>>

    /**
     * Group by Vmware.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vmwareGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vmwareGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vmwareGroupByArgs['orderBy'] }
        : { orderBy?: vmwareGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vmwareGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVmwareGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vmware model
   */
  readonly fields: vmwareFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vmware.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vmwareClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the vmware model
   */ 
  interface vmwareFieldRefs {
    readonly cve: FieldRef<"vmware", 'String'>
    readonly synopsis: FieldRef<"vmware", 'String'>
    readonly severity: FieldRef<"vmware", 'String'>
    readonly date: FieldRef<"vmware", 'String'>
    readonly link: FieldRef<"vmware", 'String'>
    readonly detail: FieldRef<"vmware", 'String'>
  }
    

  // Custom InputTypes

  /**
   * vmware findUnique
   */
  export type vmwareFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter, which vmware to fetch.
     */
    where: vmwareWhereUniqueInput
  }


  /**
   * vmware findUniqueOrThrow
   */
  export type vmwareFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter, which vmware to fetch.
     */
    where: vmwareWhereUniqueInput
  }


  /**
   * vmware findFirst
   */
  export type vmwareFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter, which vmware to fetch.
     */
    where?: vmwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vmwares to fetch.
     */
    orderBy?: vmwareOrderByWithRelationInput | vmwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vmwares.
     */
    cursor?: vmwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vmwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vmwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vmwares.
     */
    distinct?: VmwareScalarFieldEnum | VmwareScalarFieldEnum[]
  }


  /**
   * vmware findFirstOrThrow
   */
  export type vmwareFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter, which vmware to fetch.
     */
    where?: vmwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vmwares to fetch.
     */
    orderBy?: vmwareOrderByWithRelationInput | vmwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vmwares.
     */
    cursor?: vmwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vmwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vmwares.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vmwares.
     */
    distinct?: VmwareScalarFieldEnum | VmwareScalarFieldEnum[]
  }


  /**
   * vmware findMany
   */
  export type vmwareFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter, which vmwares to fetch.
     */
    where?: vmwareWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vmwares to fetch.
     */
    orderBy?: vmwareOrderByWithRelationInput | vmwareOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vmwares.
     */
    cursor?: vmwareWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vmwares from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vmwares.
     */
    skip?: number
    distinct?: VmwareScalarFieldEnum | VmwareScalarFieldEnum[]
  }


  /**
   * vmware create
   */
  export type vmwareCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * The data needed to create a vmware.
     */
    data: XOR<vmwareCreateInput, vmwareUncheckedCreateInput>
  }


  /**
   * vmware createMany
   */
  export type vmwareCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vmwares.
     */
    data: vmwareCreateManyInput | vmwareCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * vmware update
   */
  export type vmwareUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * The data needed to update a vmware.
     */
    data: XOR<vmwareUpdateInput, vmwareUncheckedUpdateInput>
    /**
     * Choose, which vmware to update.
     */
    where: vmwareWhereUniqueInput
  }


  /**
   * vmware updateMany
   */
  export type vmwareUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vmwares.
     */
    data: XOR<vmwareUpdateManyMutationInput, vmwareUncheckedUpdateManyInput>
    /**
     * Filter which vmwares to update
     */
    where?: vmwareWhereInput
  }


  /**
   * vmware upsert
   */
  export type vmwareUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * The filter to search for the vmware to update in case it exists.
     */
    where: vmwareWhereUniqueInput
    /**
     * In case the vmware found by the `where` argument doesn't exist, create a new vmware with this data.
     */
    create: XOR<vmwareCreateInput, vmwareUncheckedCreateInput>
    /**
     * In case the vmware was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vmwareUpdateInput, vmwareUncheckedUpdateInput>
  }


  /**
   * vmware delete
   */
  export type vmwareDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
    /**
     * Filter which vmware to delete.
     */
    where: vmwareWhereUniqueInput
  }


  /**
   * vmware deleteMany
   */
  export type vmwareDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vmwares to delete
     */
    where?: vmwareWhereInput
  }


  /**
   * vmware without action
   */
  export type vmwareDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vmware
     */
    select?: vmwareSelect<ExtArgs> | null
  }



  /**
   * Model cisco
   */

  export type AggregateCisco = {
    _count: CiscoCountAggregateOutputType | null
    _min: CiscoMinAggregateOutputType | null
    _max: CiscoMaxAggregateOutputType | null
  }

  export type CiscoMinAggregateOutputType = {
    id: string | null
    link: string | null
    title: string | null
    impact: string | null
    version: string | null
    last_updated: string | null
  }

  export type CiscoMaxAggregateOutputType = {
    id: string | null
    link: string | null
    title: string | null
    impact: string | null
    version: string | null
    last_updated: string | null
  }

  export type CiscoCountAggregateOutputType = {
    id: number
    link: number
    title: number
    impact: number
    version: number
    last_updated: number
    clean_cves: number
    _all: number
  }


  export type CiscoMinAggregateInputType = {
    id?: true
    link?: true
    title?: true
    impact?: true
    version?: true
    last_updated?: true
  }

  export type CiscoMaxAggregateInputType = {
    id?: true
    link?: true
    title?: true
    impact?: true
    version?: true
    last_updated?: true
  }

  export type CiscoCountAggregateInputType = {
    id?: true
    link?: true
    title?: true
    impact?: true
    version?: true
    last_updated?: true
    clean_cves?: true
    _all?: true
  }

  export type CiscoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cisco to aggregate.
     */
    where?: ciscoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ciscos to fetch.
     */
    orderBy?: ciscoOrderByWithRelationInput | ciscoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ciscoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ciscos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ciscos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ciscos
    **/
    _count?: true | CiscoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CiscoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CiscoMaxAggregateInputType
  }

  export type GetCiscoAggregateType<T extends CiscoAggregateArgs> = {
        [P in keyof T & keyof AggregateCisco]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCisco[P]>
      : GetScalarType<T[P], AggregateCisco[P]>
  }




  export type ciscoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ciscoWhereInput
    orderBy?: ciscoOrderByWithAggregationInput | ciscoOrderByWithAggregationInput[]
    by: CiscoScalarFieldEnum[] | CiscoScalarFieldEnum
    having?: ciscoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CiscoCountAggregateInputType | true
    _min?: CiscoMinAggregateInputType
    _max?: CiscoMaxAggregateInputType
  }

  export type CiscoGroupByOutputType = {
    id: string
    link: string
    title: string
    impact: string
    version: string
    last_updated: string
    clean_cves: string[]
    _count: CiscoCountAggregateOutputType | null
    _min: CiscoMinAggregateOutputType | null
    _max: CiscoMaxAggregateOutputType | null
  }

  type GetCiscoGroupByPayload<T extends ciscoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CiscoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CiscoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CiscoGroupByOutputType[P]>
            : GetScalarType<T[P], CiscoGroupByOutputType[P]>
        }
      >
    >


  export type ciscoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    link?: boolean
    title?: boolean
    impact?: boolean
    version?: boolean
    last_updated?: boolean
    clean_cves?: boolean
  }, ExtArgs["result"]["cisco"]>

  export type ciscoSelectScalar = {
    id?: boolean
    link?: boolean
    title?: boolean
    impact?: boolean
    version?: boolean
    last_updated?: boolean
    clean_cves?: boolean
  }


  export type $ciscoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cisco"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      link: string
      title: string
      impact: string
      version: string
      last_updated: string
      clean_cves: string[]
    }, ExtArgs["result"]["cisco"]>
    composites: {}
  }


  type ciscoGetPayload<S extends boolean | null | undefined | ciscoDefaultArgs> = $Result.GetResult<Prisma.$ciscoPayload, S>

  type ciscoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ciscoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CiscoCountAggregateInputType | true
    }

  export interface ciscoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cisco'], meta: { name: 'cisco' } }
    /**
     * Find zero or one Cisco that matches the filter.
     * @param {ciscoFindUniqueArgs} args - Arguments to find a Cisco
     * @example
     * // Get one Cisco
     * const cisco = await prisma.cisco.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ciscoFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoFindUniqueArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Cisco that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ciscoFindUniqueOrThrowArgs} args - Arguments to find a Cisco
     * @example
     * // Get one Cisco
     * const cisco = await prisma.cisco.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ciscoFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Cisco that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoFindFirstArgs} args - Arguments to find a Cisco
     * @example
     * // Get one Cisco
     * const cisco = await prisma.cisco.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ciscoFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoFindFirstArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Cisco that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoFindFirstOrThrowArgs} args - Arguments to find a Cisco
     * @example
     * // Get one Cisco
     * const cisco = await prisma.cisco.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ciscoFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Ciscos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Ciscos
     * const ciscos = await prisma.cisco.findMany()
     * 
     * // Get first 10 Ciscos
     * const ciscos = await prisma.cisco.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ciscoWithIdOnly = await prisma.cisco.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ciscoFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Cisco.
     * @param {ciscoCreateArgs} args - Arguments to create a Cisco.
     * @example
     * // Create one Cisco
     * const Cisco = await prisma.cisco.create({
     *   data: {
     *     // ... data to create a Cisco
     *   }
     * })
     * 
    **/
    create<T extends ciscoCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoCreateArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Ciscos.
     *     @param {ciscoCreateManyArgs} args - Arguments to create many Ciscos.
     *     @example
     *     // Create many Ciscos
     *     const cisco = await prisma.cisco.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ciscoCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cisco.
     * @param {ciscoDeleteArgs} args - Arguments to delete one Cisco.
     * @example
     * // Delete one Cisco
     * const Cisco = await prisma.cisco.delete({
     *   where: {
     *     // ... filter to delete one Cisco
     *   }
     * })
     * 
    **/
    delete<T extends ciscoDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoDeleteArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Cisco.
     * @param {ciscoUpdateArgs} args - Arguments to update one Cisco.
     * @example
     * // Update one Cisco
     * const cisco = await prisma.cisco.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ciscoUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoUpdateArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Ciscos.
     * @param {ciscoDeleteManyArgs} args - Arguments to filter Ciscos to delete.
     * @example
     * // Delete a few Ciscos
     * const { count } = await prisma.cisco.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ciscoDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ciscoDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Ciscos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Ciscos
     * const cisco = await prisma.cisco.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ciscoUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cisco.
     * @param {ciscoUpsertArgs} args - Arguments to update or create a Cisco.
     * @example
     * // Update or create a Cisco
     * const cisco = await prisma.cisco.upsert({
     *   create: {
     *     // ... data to create a Cisco
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cisco we want to update
     *   }
     * })
    **/
    upsert<T extends ciscoUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ciscoUpsertArgs<ExtArgs>>
    ): Prisma__ciscoClient<$Result.GetResult<Prisma.$ciscoPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Ciscos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoCountArgs} args - Arguments to filter Ciscos to count.
     * @example
     * // Count the number of Ciscos
     * const count = await prisma.cisco.count({
     *   where: {
     *     // ... the filter for the Ciscos we want to count
     *   }
     * })
    **/
    count<T extends ciscoCountArgs>(
      args?: Subset<T, ciscoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CiscoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cisco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CiscoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CiscoAggregateArgs>(args: Subset<T, CiscoAggregateArgs>): Prisma.PrismaPromise<GetCiscoAggregateType<T>>

    /**
     * Group by Cisco.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ciscoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ciscoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ciscoGroupByArgs['orderBy'] }
        : { orderBy?: ciscoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ciscoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCiscoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cisco model
   */
  readonly fields: ciscoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cisco.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ciscoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the cisco model
   */ 
  interface ciscoFieldRefs {
    readonly id: FieldRef<"cisco", 'String'>
    readonly link: FieldRef<"cisco", 'String'>
    readonly title: FieldRef<"cisco", 'String'>
    readonly impact: FieldRef<"cisco", 'String'>
    readonly version: FieldRef<"cisco", 'String'>
    readonly last_updated: FieldRef<"cisco", 'String'>
    readonly clean_cves: FieldRef<"cisco", 'String[]'>
  }
    

  // Custom InputTypes

  /**
   * cisco findUnique
   */
  export type ciscoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter, which cisco to fetch.
     */
    where: ciscoWhereUniqueInput
  }


  /**
   * cisco findUniqueOrThrow
   */
  export type ciscoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter, which cisco to fetch.
     */
    where: ciscoWhereUniqueInput
  }


  /**
   * cisco findFirst
   */
  export type ciscoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter, which cisco to fetch.
     */
    where?: ciscoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ciscos to fetch.
     */
    orderBy?: ciscoOrderByWithRelationInput | ciscoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ciscos.
     */
    cursor?: ciscoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ciscos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ciscos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ciscos.
     */
    distinct?: CiscoScalarFieldEnum | CiscoScalarFieldEnum[]
  }


  /**
   * cisco findFirstOrThrow
   */
  export type ciscoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter, which cisco to fetch.
     */
    where?: ciscoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ciscos to fetch.
     */
    orderBy?: ciscoOrderByWithRelationInput | ciscoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ciscos.
     */
    cursor?: ciscoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ciscos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ciscos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ciscos.
     */
    distinct?: CiscoScalarFieldEnum | CiscoScalarFieldEnum[]
  }


  /**
   * cisco findMany
   */
  export type ciscoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter, which ciscos to fetch.
     */
    where?: ciscoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ciscos to fetch.
     */
    orderBy?: ciscoOrderByWithRelationInput | ciscoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ciscos.
     */
    cursor?: ciscoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ciscos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ciscos.
     */
    skip?: number
    distinct?: CiscoScalarFieldEnum | CiscoScalarFieldEnum[]
  }


  /**
   * cisco create
   */
  export type ciscoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * The data needed to create a cisco.
     */
    data: XOR<ciscoCreateInput, ciscoUncheckedCreateInput>
  }


  /**
   * cisco createMany
   */
  export type ciscoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ciscos.
     */
    data: ciscoCreateManyInput | ciscoCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * cisco update
   */
  export type ciscoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * The data needed to update a cisco.
     */
    data: XOR<ciscoUpdateInput, ciscoUncheckedUpdateInput>
    /**
     * Choose, which cisco to update.
     */
    where: ciscoWhereUniqueInput
  }


  /**
   * cisco updateMany
   */
  export type ciscoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ciscos.
     */
    data: XOR<ciscoUpdateManyMutationInput, ciscoUncheckedUpdateManyInput>
    /**
     * Filter which ciscos to update
     */
    where?: ciscoWhereInput
  }


  /**
   * cisco upsert
   */
  export type ciscoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * The filter to search for the cisco to update in case it exists.
     */
    where: ciscoWhereUniqueInput
    /**
     * In case the cisco found by the `where` argument doesn't exist, create a new cisco with this data.
     */
    create: XOR<ciscoCreateInput, ciscoUncheckedCreateInput>
    /**
     * In case the cisco was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ciscoUpdateInput, ciscoUncheckedUpdateInput>
  }


  /**
   * cisco delete
   */
  export type ciscoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
    /**
     * Filter which cisco to delete.
     */
    where: ciscoWhereUniqueInput
  }


  /**
   * cisco deleteMany
   */
  export type ciscoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ciscos to delete
     */
    where?: ciscoWhereInput
  }


  /**
   * cisco without action
   */
  export type ciscoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cisco
     */
    select?: ciscoSelect<ExtArgs> | null
  }



  /**
   * Model oracle
   */

  export type AggregateOracle = {
    _count: OracleCountAggregateOutputType | null
    _avg: OracleAvgAggregateOutputType | null
    _sum: OracleSumAggregateOutputType | null
    _min: OracleMinAggregateOutputType | null
    _max: OracleMaxAggregateOutputType | null
  }

  export type OracleAvgAggregateOutputType = {
    id: number | null
  }

  export type OracleSumAggregateOutputType = {
    id: number | null
  }

  export type OracleMinAggregateOutputType = {
    id: number | null
    affected_product: string | null
    affected_product_link: string | null
    patch_document: string | null
    patch_document_link: string | null
  }

  export type OracleMaxAggregateOutputType = {
    id: number | null
    affected_product: string | null
    affected_product_link: string | null
    patch_document: string | null
    patch_document_link: string | null
  }

  export type OracleCountAggregateOutputType = {
    id: number
    affected_product: number
    affected_product_link: number
    patch_document: number
    patch_document_link: number
    _all: number
  }


  export type OracleAvgAggregateInputType = {
    id?: true
  }

  export type OracleSumAggregateInputType = {
    id?: true
  }

  export type OracleMinAggregateInputType = {
    id?: true
    affected_product?: true
    affected_product_link?: true
    patch_document?: true
    patch_document_link?: true
  }

  export type OracleMaxAggregateInputType = {
    id?: true
    affected_product?: true
    affected_product_link?: true
    patch_document?: true
    patch_document_link?: true
  }

  export type OracleCountAggregateInputType = {
    id?: true
    affected_product?: true
    affected_product_link?: true
    patch_document?: true
    patch_document_link?: true
    _all?: true
  }

  export type OracleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which oracle to aggregate.
     */
    where?: oracleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oracles to fetch.
     */
    orderBy?: oracleOrderByWithRelationInput | oracleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: oracleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oracles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oracles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned oracles
    **/
    _count?: true | OracleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OracleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OracleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OracleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OracleMaxAggregateInputType
  }

  export type GetOracleAggregateType<T extends OracleAggregateArgs> = {
        [P in keyof T & keyof AggregateOracle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOracle[P]>
      : GetScalarType<T[P], AggregateOracle[P]>
  }




  export type oracleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: oracleWhereInput
    orderBy?: oracleOrderByWithAggregationInput | oracleOrderByWithAggregationInput[]
    by: OracleScalarFieldEnum[] | OracleScalarFieldEnum
    having?: oracleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OracleCountAggregateInputType | true
    _avg?: OracleAvgAggregateInputType
    _sum?: OracleSumAggregateInputType
    _min?: OracleMinAggregateInputType
    _max?: OracleMaxAggregateInputType
  }

  export type OracleGroupByOutputType = {
    id: number
    affected_product: string
    affected_product_link: string
    patch_document: string
    patch_document_link: string
    _count: OracleCountAggregateOutputType | null
    _avg: OracleAvgAggregateOutputType | null
    _sum: OracleSumAggregateOutputType | null
    _min: OracleMinAggregateOutputType | null
    _max: OracleMaxAggregateOutputType | null
  }

  type GetOracleGroupByPayload<T extends oracleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OracleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OracleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OracleGroupByOutputType[P]>
            : GetScalarType<T[P], OracleGroupByOutputType[P]>
        }
      >
    >


  export type oracleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    affected_product?: boolean
    affected_product_link?: boolean
    patch_document?: boolean
    patch_document_link?: boolean
  }, ExtArgs["result"]["oracle"]>

  export type oracleSelectScalar = {
    id?: boolean
    affected_product?: boolean
    affected_product_link?: boolean
    patch_document?: boolean
    patch_document_link?: boolean
  }


  export type $oraclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "oracle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      affected_product: string
      affected_product_link: string
      patch_document: string
      patch_document_link: string
    }, ExtArgs["result"]["oracle"]>
    composites: {}
  }


  type oracleGetPayload<S extends boolean | null | undefined | oracleDefaultArgs> = $Result.GetResult<Prisma.$oraclePayload, S>

  type oracleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<oracleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OracleCountAggregateInputType | true
    }

  export interface oracleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['oracle'], meta: { name: 'oracle' } }
    /**
     * Find zero or one Oracle that matches the filter.
     * @param {oracleFindUniqueArgs} args - Arguments to find a Oracle
     * @example
     * // Get one Oracle
     * const oracle = await prisma.oracle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends oracleFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, oracleFindUniqueArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Oracle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {oracleFindUniqueOrThrowArgs} args - Arguments to find a Oracle
     * @example
     * // Get one Oracle
     * const oracle = await prisma.oracle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends oracleFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Oracle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleFindFirstArgs} args - Arguments to find a Oracle
     * @example
     * // Get one Oracle
     * const oracle = await prisma.oracle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends oracleFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleFindFirstArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Oracle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleFindFirstOrThrowArgs} args - Arguments to find a Oracle
     * @example
     * // Get one Oracle
     * const oracle = await prisma.oracle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends oracleFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Oracles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Oracles
     * const oracles = await prisma.oracle.findMany()
     * 
     * // Get first 10 Oracles
     * const oracles = await prisma.oracle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const oracleWithIdOnly = await prisma.oracle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends oracleFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Oracle.
     * @param {oracleCreateArgs} args - Arguments to create a Oracle.
     * @example
     * // Create one Oracle
     * const Oracle = await prisma.oracle.create({
     *   data: {
     *     // ... data to create a Oracle
     *   }
     * })
     * 
    **/
    create<T extends oracleCreateArgs<ExtArgs>>(
      args: SelectSubset<T, oracleCreateArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Oracles.
     *     @param {oracleCreateManyArgs} args - Arguments to create many Oracles.
     *     @example
     *     // Create many Oracles
     *     const oracle = await prisma.oracle.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends oracleCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Oracle.
     * @param {oracleDeleteArgs} args - Arguments to delete one Oracle.
     * @example
     * // Delete one Oracle
     * const Oracle = await prisma.oracle.delete({
     *   where: {
     *     // ... filter to delete one Oracle
     *   }
     * })
     * 
    **/
    delete<T extends oracleDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, oracleDeleteArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Oracle.
     * @param {oracleUpdateArgs} args - Arguments to update one Oracle.
     * @example
     * // Update one Oracle
     * const oracle = await prisma.oracle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends oracleUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, oracleUpdateArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Oracles.
     * @param {oracleDeleteManyArgs} args - Arguments to filter Oracles to delete.
     * @example
     * // Delete a few Oracles
     * const { count } = await prisma.oracle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends oracleDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, oracleDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Oracles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Oracles
     * const oracle = await prisma.oracle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends oracleUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, oracleUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Oracle.
     * @param {oracleUpsertArgs} args - Arguments to update or create a Oracle.
     * @example
     * // Update or create a Oracle
     * const oracle = await prisma.oracle.upsert({
     *   create: {
     *     // ... data to create a Oracle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Oracle we want to update
     *   }
     * })
    **/
    upsert<T extends oracleUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, oracleUpsertArgs<ExtArgs>>
    ): Prisma__oracleClient<$Result.GetResult<Prisma.$oraclePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Oracles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleCountArgs} args - Arguments to filter Oracles to count.
     * @example
     * // Count the number of Oracles
     * const count = await prisma.oracle.count({
     *   where: {
     *     // ... the filter for the Oracles we want to count
     *   }
     * })
    **/
    count<T extends oracleCountArgs>(
      args?: Subset<T, oracleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OracleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Oracle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OracleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OracleAggregateArgs>(args: Subset<T, OracleAggregateArgs>): Prisma.PrismaPromise<GetOracleAggregateType<T>>

    /**
     * Group by Oracle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {oracleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends oracleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: oracleGroupByArgs['orderBy'] }
        : { orderBy?: oracleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, oracleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOracleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the oracle model
   */
  readonly fields: oracleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for oracle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__oracleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the oracle model
   */ 
  interface oracleFieldRefs {
    readonly id: FieldRef<"oracle", 'Int'>
    readonly affected_product: FieldRef<"oracle", 'String'>
    readonly affected_product_link: FieldRef<"oracle", 'String'>
    readonly patch_document: FieldRef<"oracle", 'String'>
    readonly patch_document_link: FieldRef<"oracle", 'String'>
  }
    

  // Custom InputTypes

  /**
   * oracle findUnique
   */
  export type oracleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter, which oracle to fetch.
     */
    where: oracleWhereUniqueInput
  }


  /**
   * oracle findUniqueOrThrow
   */
  export type oracleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter, which oracle to fetch.
     */
    where: oracleWhereUniqueInput
  }


  /**
   * oracle findFirst
   */
  export type oracleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter, which oracle to fetch.
     */
    where?: oracleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oracles to fetch.
     */
    orderBy?: oracleOrderByWithRelationInput | oracleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for oracles.
     */
    cursor?: oracleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oracles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oracles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of oracles.
     */
    distinct?: OracleScalarFieldEnum | OracleScalarFieldEnum[]
  }


  /**
   * oracle findFirstOrThrow
   */
  export type oracleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter, which oracle to fetch.
     */
    where?: oracleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oracles to fetch.
     */
    orderBy?: oracleOrderByWithRelationInput | oracleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for oracles.
     */
    cursor?: oracleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oracles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oracles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of oracles.
     */
    distinct?: OracleScalarFieldEnum | OracleScalarFieldEnum[]
  }


  /**
   * oracle findMany
   */
  export type oracleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter, which oracles to fetch.
     */
    where?: oracleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of oracles to fetch.
     */
    orderBy?: oracleOrderByWithRelationInput | oracleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing oracles.
     */
    cursor?: oracleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` oracles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` oracles.
     */
    skip?: number
    distinct?: OracleScalarFieldEnum | OracleScalarFieldEnum[]
  }


  /**
   * oracle create
   */
  export type oracleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * The data needed to create a oracle.
     */
    data: XOR<oracleCreateInput, oracleUncheckedCreateInput>
  }


  /**
   * oracle createMany
   */
  export type oracleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many oracles.
     */
    data: oracleCreateManyInput | oracleCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * oracle update
   */
  export type oracleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * The data needed to update a oracle.
     */
    data: XOR<oracleUpdateInput, oracleUncheckedUpdateInput>
    /**
     * Choose, which oracle to update.
     */
    where: oracleWhereUniqueInput
  }


  /**
   * oracle updateMany
   */
  export type oracleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update oracles.
     */
    data: XOR<oracleUpdateManyMutationInput, oracleUncheckedUpdateManyInput>
    /**
     * Filter which oracles to update
     */
    where?: oracleWhereInput
  }


  /**
   * oracle upsert
   */
  export type oracleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * The filter to search for the oracle to update in case it exists.
     */
    where: oracleWhereUniqueInput
    /**
     * In case the oracle found by the `where` argument doesn't exist, create a new oracle with this data.
     */
    create: XOR<oracleCreateInput, oracleUncheckedCreateInput>
    /**
     * In case the oracle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<oracleUpdateInput, oracleUncheckedUpdateInput>
  }


  /**
   * oracle delete
   */
  export type oracleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
    /**
     * Filter which oracle to delete.
     */
    where: oracleWhereUniqueInput
  }


  /**
   * oracle deleteMany
   */
  export type oracleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which oracles to delete
     */
    where?: oracleWhereInput
  }


  /**
   * oracle without action
   */
  export type oracleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the oracle
     */
    select?: oracleSelect<ExtArgs> | null
  }



  /**
   * Model microsoft
   */

  export type AggregateMicrosoft = {
    _count: MicrosoftCountAggregateOutputType | null
    _min: MicrosoftMinAggregateOutputType | null
    _max: MicrosoftMaxAggregateOutputType | null
  }

  export type MicrosoftMinAggregateOutputType = {
    cve: string | null
    release_date: string | null
    revision_date: string | null
    cve_link: string | null
    cve_title: string | null
    impact: string | null
    severity: string | null
    tag: string | null
  }

  export type MicrosoftMaxAggregateOutputType = {
    cve: string | null
    release_date: string | null
    revision_date: string | null
    cve_link: string | null
    cve_title: string | null
    impact: string | null
    severity: string | null
    tag: string | null
  }

  export type MicrosoftCountAggregateOutputType = {
    cve: number
    release_date: number
    revision_date: number
    cve_link: number
    cve_title: number
    impact: number
    severity: number
    tag: number
    _all: number
  }


  export type MicrosoftMinAggregateInputType = {
    cve?: true
    release_date?: true
    revision_date?: true
    cve_link?: true
    cve_title?: true
    impact?: true
    severity?: true
    tag?: true
  }

  export type MicrosoftMaxAggregateInputType = {
    cve?: true
    release_date?: true
    revision_date?: true
    cve_link?: true
    cve_title?: true
    impact?: true
    severity?: true
    tag?: true
  }

  export type MicrosoftCountAggregateInputType = {
    cve?: true
    release_date?: true
    revision_date?: true
    cve_link?: true
    cve_title?: true
    impact?: true
    severity?: true
    tag?: true
    _all?: true
  }

  export type MicrosoftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which microsoft to aggregate.
     */
    where?: microsoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microsofts to fetch.
     */
    orderBy?: microsoftOrderByWithRelationInput | microsoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: microsoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microsofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microsofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned microsofts
    **/
    _count?: true | MicrosoftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MicrosoftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MicrosoftMaxAggregateInputType
  }

  export type GetMicrosoftAggregateType<T extends MicrosoftAggregateArgs> = {
        [P in keyof T & keyof AggregateMicrosoft]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMicrosoft[P]>
      : GetScalarType<T[P], AggregateMicrosoft[P]>
  }




  export type microsoftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: microsoftWhereInput
    orderBy?: microsoftOrderByWithAggregationInput | microsoftOrderByWithAggregationInput[]
    by: MicrosoftScalarFieldEnum[] | MicrosoftScalarFieldEnum
    having?: microsoftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MicrosoftCountAggregateInputType | true
    _min?: MicrosoftMinAggregateInputType
    _max?: MicrosoftMaxAggregateInputType
  }

  export type MicrosoftGroupByOutputType = {
    cve: string
    release_date: string
    revision_date: string
    cve_link: string
    cve_title: string
    impact: string
    severity: string
    tag: string
    _count: MicrosoftCountAggregateOutputType | null
    _min: MicrosoftMinAggregateOutputType | null
    _max: MicrosoftMaxAggregateOutputType | null
  }

  type GetMicrosoftGroupByPayload<T extends microsoftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MicrosoftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MicrosoftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MicrosoftGroupByOutputType[P]>
            : GetScalarType<T[P], MicrosoftGroupByOutputType[P]>
        }
      >
    >


  export type microsoftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cve?: boolean
    release_date?: boolean
    revision_date?: boolean
    cve_link?: boolean
    cve_title?: boolean
    impact?: boolean
    severity?: boolean
    tag?: boolean
  }, ExtArgs["result"]["microsoft"]>

  export type microsoftSelectScalar = {
    cve?: boolean
    release_date?: boolean
    revision_date?: boolean
    cve_link?: boolean
    cve_title?: boolean
    impact?: boolean
    severity?: boolean
    tag?: boolean
  }


  export type $microsoftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "microsoft"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      cve: string
      release_date: string
      revision_date: string
      cve_link: string
      cve_title: string
      impact: string
      severity: string
      tag: string
    }, ExtArgs["result"]["microsoft"]>
    composites: {}
  }


  type microsoftGetPayload<S extends boolean | null | undefined | microsoftDefaultArgs> = $Result.GetResult<Prisma.$microsoftPayload, S>

  type microsoftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<microsoftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MicrosoftCountAggregateInputType | true
    }

  export interface microsoftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['microsoft'], meta: { name: 'microsoft' } }
    /**
     * Find zero or one Microsoft that matches the filter.
     * @param {microsoftFindUniqueArgs} args - Arguments to find a Microsoft
     * @example
     * // Get one Microsoft
     * const microsoft = await prisma.microsoft.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends microsoftFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftFindUniqueArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Microsoft that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {microsoftFindUniqueOrThrowArgs} args - Arguments to find a Microsoft
     * @example
     * // Get one Microsoft
     * const microsoft = await prisma.microsoft.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends microsoftFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Microsoft that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftFindFirstArgs} args - Arguments to find a Microsoft
     * @example
     * // Get one Microsoft
     * const microsoft = await prisma.microsoft.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends microsoftFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftFindFirstArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Microsoft that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftFindFirstOrThrowArgs} args - Arguments to find a Microsoft
     * @example
     * // Get one Microsoft
     * const microsoft = await prisma.microsoft.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends microsoftFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Microsofts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Microsofts
     * const microsofts = await prisma.microsoft.findMany()
     * 
     * // Get first 10 Microsofts
     * const microsofts = await prisma.microsoft.findMany({ take: 10 })
     * 
     * // Only select the `cve`
     * const microsoftWithCveOnly = await prisma.microsoft.findMany({ select: { cve: true } })
     * 
    **/
    findMany<T extends microsoftFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Microsoft.
     * @param {microsoftCreateArgs} args - Arguments to create a Microsoft.
     * @example
     * // Create one Microsoft
     * const Microsoft = await prisma.microsoft.create({
     *   data: {
     *     // ... data to create a Microsoft
     *   }
     * })
     * 
    **/
    create<T extends microsoftCreateArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftCreateArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Microsofts.
     *     @param {microsoftCreateManyArgs} args - Arguments to create many Microsofts.
     *     @example
     *     // Create many Microsofts
     *     const microsoft = await prisma.microsoft.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends microsoftCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Microsoft.
     * @param {microsoftDeleteArgs} args - Arguments to delete one Microsoft.
     * @example
     * // Delete one Microsoft
     * const Microsoft = await prisma.microsoft.delete({
     *   where: {
     *     // ... filter to delete one Microsoft
     *   }
     * })
     * 
    **/
    delete<T extends microsoftDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftDeleteArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Microsoft.
     * @param {microsoftUpdateArgs} args - Arguments to update one Microsoft.
     * @example
     * // Update one Microsoft
     * const microsoft = await prisma.microsoft.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends microsoftUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftUpdateArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Microsofts.
     * @param {microsoftDeleteManyArgs} args - Arguments to filter Microsofts to delete.
     * @example
     * // Delete a few Microsofts
     * const { count } = await prisma.microsoft.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends microsoftDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, microsoftDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Microsofts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Microsofts
     * const microsoft = await prisma.microsoft.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends microsoftUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Microsoft.
     * @param {microsoftUpsertArgs} args - Arguments to update or create a Microsoft.
     * @example
     * // Update or create a Microsoft
     * const microsoft = await prisma.microsoft.upsert({
     *   create: {
     *     // ... data to create a Microsoft
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Microsoft we want to update
     *   }
     * })
    **/
    upsert<T extends microsoftUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, microsoftUpsertArgs<ExtArgs>>
    ): Prisma__microsoftClient<$Result.GetResult<Prisma.$microsoftPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Microsofts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftCountArgs} args - Arguments to filter Microsofts to count.
     * @example
     * // Count the number of Microsofts
     * const count = await prisma.microsoft.count({
     *   where: {
     *     // ... the filter for the Microsofts we want to count
     *   }
     * })
    **/
    count<T extends microsoftCountArgs>(
      args?: Subset<T, microsoftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MicrosoftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Microsoft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MicrosoftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MicrosoftAggregateArgs>(args: Subset<T, MicrosoftAggregateArgs>): Prisma.PrismaPromise<GetMicrosoftAggregateType<T>>

    /**
     * Group by Microsoft.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {microsoftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends microsoftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: microsoftGroupByArgs['orderBy'] }
        : { orderBy?: microsoftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, microsoftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMicrosoftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the microsoft model
   */
  readonly fields: microsoftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for microsoft.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__microsoftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the microsoft model
   */ 
  interface microsoftFieldRefs {
    readonly cve: FieldRef<"microsoft", 'String'>
    readonly release_date: FieldRef<"microsoft", 'String'>
    readonly revision_date: FieldRef<"microsoft", 'String'>
    readonly cve_link: FieldRef<"microsoft", 'String'>
    readonly cve_title: FieldRef<"microsoft", 'String'>
    readonly impact: FieldRef<"microsoft", 'String'>
    readonly severity: FieldRef<"microsoft", 'String'>
    readonly tag: FieldRef<"microsoft", 'String'>
  }
    

  // Custom InputTypes

  /**
   * microsoft findUnique
   */
  export type microsoftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter, which microsoft to fetch.
     */
    where: microsoftWhereUniqueInput
  }


  /**
   * microsoft findUniqueOrThrow
   */
  export type microsoftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter, which microsoft to fetch.
     */
    where: microsoftWhereUniqueInput
  }


  /**
   * microsoft findFirst
   */
  export type microsoftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter, which microsoft to fetch.
     */
    where?: microsoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microsofts to fetch.
     */
    orderBy?: microsoftOrderByWithRelationInput | microsoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for microsofts.
     */
    cursor?: microsoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microsofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microsofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of microsofts.
     */
    distinct?: MicrosoftScalarFieldEnum | MicrosoftScalarFieldEnum[]
  }


  /**
   * microsoft findFirstOrThrow
   */
  export type microsoftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter, which microsoft to fetch.
     */
    where?: microsoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microsofts to fetch.
     */
    orderBy?: microsoftOrderByWithRelationInput | microsoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for microsofts.
     */
    cursor?: microsoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microsofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microsofts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of microsofts.
     */
    distinct?: MicrosoftScalarFieldEnum | MicrosoftScalarFieldEnum[]
  }


  /**
   * microsoft findMany
   */
  export type microsoftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter, which microsofts to fetch.
     */
    where?: microsoftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of microsofts to fetch.
     */
    orderBy?: microsoftOrderByWithRelationInput | microsoftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing microsofts.
     */
    cursor?: microsoftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` microsofts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` microsofts.
     */
    skip?: number
    distinct?: MicrosoftScalarFieldEnum | MicrosoftScalarFieldEnum[]
  }


  /**
   * microsoft create
   */
  export type microsoftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * The data needed to create a microsoft.
     */
    data: XOR<microsoftCreateInput, microsoftUncheckedCreateInput>
  }


  /**
   * microsoft createMany
   */
  export type microsoftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many microsofts.
     */
    data: microsoftCreateManyInput | microsoftCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * microsoft update
   */
  export type microsoftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * The data needed to update a microsoft.
     */
    data: XOR<microsoftUpdateInput, microsoftUncheckedUpdateInput>
    /**
     * Choose, which microsoft to update.
     */
    where: microsoftWhereUniqueInput
  }


  /**
   * microsoft updateMany
   */
  export type microsoftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update microsofts.
     */
    data: XOR<microsoftUpdateManyMutationInput, microsoftUncheckedUpdateManyInput>
    /**
     * Filter which microsofts to update
     */
    where?: microsoftWhereInput
  }


  /**
   * microsoft upsert
   */
  export type microsoftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * The filter to search for the microsoft to update in case it exists.
     */
    where: microsoftWhereUniqueInput
    /**
     * In case the microsoft found by the `where` argument doesn't exist, create a new microsoft with this data.
     */
    create: XOR<microsoftCreateInput, microsoftUncheckedCreateInput>
    /**
     * In case the microsoft was found with the provided `where` argument, update it with this data.
     */
    update: XOR<microsoftUpdateInput, microsoftUncheckedUpdateInput>
  }


  /**
   * microsoft delete
   */
  export type microsoftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
    /**
     * Filter which microsoft to delete.
     */
    where: microsoftWhereUniqueInput
  }


  /**
   * microsoft deleteMany
   */
  export type microsoftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which microsofts to delete
     */
    where?: microsoftWhereInput
  }


  /**
   * microsoft without action
   */
  export type microsoftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the microsoft
     */
    select?: microsoftSelect<ExtArgs> | null
  }



  /**
   * Model hackernews
   */

  export type AggregateHackernews = {
    _count: HackernewsCountAggregateOutputType | null
    _min: HackernewsMinAggregateOutputType | null
    _max: HackernewsMaxAggregateOutputType | null
  }

  export type HackernewsMinAggregateOutputType = {
    title: string | null
    link: string | null
    img: string | null
    date: string | null
    description: string | null
    detail: string | null
  }

  export type HackernewsMaxAggregateOutputType = {
    title: string | null
    link: string | null
    img: string | null
    date: string | null
    description: string | null
    detail: string | null
  }

  export type HackernewsCountAggregateOutputType = {
    title: number
    link: number
    img: number
    date: number
    description: number
    detail: number
    _all: number
  }


  export type HackernewsMinAggregateInputType = {
    title?: true
    link?: true
    img?: true
    date?: true
    description?: true
    detail?: true
  }

  export type HackernewsMaxAggregateInputType = {
    title?: true
    link?: true
    img?: true
    date?: true
    description?: true
    detail?: true
  }

  export type HackernewsCountAggregateInputType = {
    title?: true
    link?: true
    img?: true
    date?: true
    description?: true
    detail?: true
    _all?: true
  }

  export type HackernewsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hackernews to aggregate.
     */
    where?: hackernewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hackernews to fetch.
     */
    orderBy?: hackernewsOrderByWithRelationInput | hackernewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: hackernewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hackernews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hackernews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned hackernews
    **/
    _count?: true | HackernewsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HackernewsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HackernewsMaxAggregateInputType
  }

  export type GetHackernewsAggregateType<T extends HackernewsAggregateArgs> = {
        [P in keyof T & keyof AggregateHackernews]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHackernews[P]>
      : GetScalarType<T[P], AggregateHackernews[P]>
  }




  export type hackernewsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: hackernewsWhereInput
    orderBy?: hackernewsOrderByWithAggregationInput | hackernewsOrderByWithAggregationInput[]
    by: HackernewsScalarFieldEnum[] | HackernewsScalarFieldEnum
    having?: hackernewsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HackernewsCountAggregateInputType | true
    _min?: HackernewsMinAggregateInputType
    _max?: HackernewsMaxAggregateInputType
  }

  export type HackernewsGroupByOutputType = {
    title: string
    link: string
    img: string
    date: string
    description: string
    detail: string
    _count: HackernewsCountAggregateOutputType | null
    _min: HackernewsMinAggregateOutputType | null
    _max: HackernewsMaxAggregateOutputType | null
  }

  type GetHackernewsGroupByPayload<T extends hackernewsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HackernewsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HackernewsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HackernewsGroupByOutputType[P]>
            : GetScalarType<T[P], HackernewsGroupByOutputType[P]>
        }
      >
    >


  export type hackernewsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    title?: boolean
    link?: boolean
    img?: boolean
    date?: boolean
    description?: boolean
    detail?: boolean
  }, ExtArgs["result"]["hackernews"]>

  export type hackernewsSelectScalar = {
    title?: boolean
    link?: boolean
    img?: boolean
    date?: boolean
    description?: boolean
    detail?: boolean
  }


  export type $hackernewsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "hackernews"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      title: string
      link: string
      img: string
      date: string
      description: string
      detail: string
    }, ExtArgs["result"]["hackernews"]>
    composites: {}
  }


  type hackernewsGetPayload<S extends boolean | null | undefined | hackernewsDefaultArgs> = $Result.GetResult<Prisma.$hackernewsPayload, S>

  type hackernewsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<hackernewsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HackernewsCountAggregateInputType | true
    }

  export interface hackernewsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['hackernews'], meta: { name: 'hackernews' } }
    /**
     * Find zero or one Hackernews that matches the filter.
     * @param {hackernewsFindUniqueArgs} args - Arguments to find a Hackernews
     * @example
     * // Get one Hackernews
     * const hackernews = await prisma.hackernews.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends hackernewsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsFindUniqueArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Hackernews that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {hackernewsFindUniqueOrThrowArgs} args - Arguments to find a Hackernews
     * @example
     * // Get one Hackernews
     * const hackernews = await prisma.hackernews.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends hackernewsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Hackernews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsFindFirstArgs} args - Arguments to find a Hackernews
     * @example
     * // Get one Hackernews
     * const hackernews = await prisma.hackernews.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends hackernewsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsFindFirstArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Hackernews that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsFindFirstOrThrowArgs} args - Arguments to find a Hackernews
     * @example
     * // Get one Hackernews
     * const hackernews = await prisma.hackernews.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends hackernewsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Hackernews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hackernews
     * const hackernews = await prisma.hackernews.findMany()
     * 
     * // Get first 10 Hackernews
     * const hackernews = await prisma.hackernews.findMany({ take: 10 })
     * 
     * // Only select the `title`
     * const hackernewsWithTitleOnly = await prisma.hackernews.findMany({ select: { title: true } })
     * 
    **/
    findMany<T extends hackernewsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Hackernews.
     * @param {hackernewsCreateArgs} args - Arguments to create a Hackernews.
     * @example
     * // Create one Hackernews
     * const Hackernews = await prisma.hackernews.create({
     *   data: {
     *     // ... data to create a Hackernews
     *   }
     * })
     * 
    **/
    create<T extends hackernewsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsCreateArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Hackernews.
     *     @param {hackernewsCreateManyArgs} args - Arguments to create many Hackernews.
     *     @example
     *     // Create many Hackernews
     *     const hackernews = await prisma.hackernews.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends hackernewsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Hackernews.
     * @param {hackernewsDeleteArgs} args - Arguments to delete one Hackernews.
     * @example
     * // Delete one Hackernews
     * const Hackernews = await prisma.hackernews.delete({
     *   where: {
     *     // ... filter to delete one Hackernews
     *   }
     * })
     * 
    **/
    delete<T extends hackernewsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsDeleteArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Hackernews.
     * @param {hackernewsUpdateArgs} args - Arguments to update one Hackernews.
     * @example
     * // Update one Hackernews
     * const hackernews = await prisma.hackernews.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends hackernewsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsUpdateArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Hackernews.
     * @param {hackernewsDeleteManyArgs} args - Arguments to filter Hackernews to delete.
     * @example
     * // Delete a few Hackernews
     * const { count } = await prisma.hackernews.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends hackernewsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, hackernewsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hackernews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hackernews
     * const hackernews = await prisma.hackernews.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends hackernewsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hackernews.
     * @param {hackernewsUpsertArgs} args - Arguments to update or create a Hackernews.
     * @example
     * // Update or create a Hackernews
     * const hackernews = await prisma.hackernews.upsert({
     *   create: {
     *     // ... data to create a Hackernews
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hackernews we want to update
     *   }
     * })
    **/
    upsert<T extends hackernewsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, hackernewsUpsertArgs<ExtArgs>>
    ): Prisma__hackernewsClient<$Result.GetResult<Prisma.$hackernewsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Hackernews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsCountArgs} args - Arguments to filter Hackernews to count.
     * @example
     * // Count the number of Hackernews
     * const count = await prisma.hackernews.count({
     *   where: {
     *     // ... the filter for the Hackernews we want to count
     *   }
     * })
    **/
    count<T extends hackernewsCountArgs>(
      args?: Subset<T, hackernewsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HackernewsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hackernews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HackernewsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HackernewsAggregateArgs>(args: Subset<T, HackernewsAggregateArgs>): Prisma.PrismaPromise<GetHackernewsAggregateType<T>>

    /**
     * Group by Hackernews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {hackernewsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends hackernewsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: hackernewsGroupByArgs['orderBy'] }
        : { orderBy?: hackernewsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, hackernewsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHackernewsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the hackernews model
   */
  readonly fields: hackernewsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for hackernews.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__hackernewsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the hackernews model
   */ 
  interface hackernewsFieldRefs {
    readonly title: FieldRef<"hackernews", 'String'>
    readonly link: FieldRef<"hackernews", 'String'>
    readonly img: FieldRef<"hackernews", 'String'>
    readonly date: FieldRef<"hackernews", 'String'>
    readonly description: FieldRef<"hackernews", 'String'>
    readonly detail: FieldRef<"hackernews", 'String'>
  }
    

  // Custom InputTypes

  /**
   * hackernews findUnique
   */
  export type hackernewsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter, which hackernews to fetch.
     */
    where: hackernewsWhereUniqueInput
  }


  /**
   * hackernews findUniqueOrThrow
   */
  export type hackernewsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter, which hackernews to fetch.
     */
    where: hackernewsWhereUniqueInput
  }


  /**
   * hackernews findFirst
   */
  export type hackernewsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter, which hackernews to fetch.
     */
    where?: hackernewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hackernews to fetch.
     */
    orderBy?: hackernewsOrderByWithRelationInput | hackernewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hackernews.
     */
    cursor?: hackernewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hackernews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hackernews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hackernews.
     */
    distinct?: HackernewsScalarFieldEnum | HackernewsScalarFieldEnum[]
  }


  /**
   * hackernews findFirstOrThrow
   */
  export type hackernewsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter, which hackernews to fetch.
     */
    where?: hackernewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hackernews to fetch.
     */
    orderBy?: hackernewsOrderByWithRelationInput | hackernewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for hackernews.
     */
    cursor?: hackernewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hackernews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hackernews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of hackernews.
     */
    distinct?: HackernewsScalarFieldEnum | HackernewsScalarFieldEnum[]
  }


  /**
   * hackernews findMany
   */
  export type hackernewsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter, which hackernews to fetch.
     */
    where?: hackernewsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of hackernews to fetch.
     */
    orderBy?: hackernewsOrderByWithRelationInput | hackernewsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing hackernews.
     */
    cursor?: hackernewsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` hackernews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` hackernews.
     */
    skip?: number
    distinct?: HackernewsScalarFieldEnum | HackernewsScalarFieldEnum[]
  }


  /**
   * hackernews create
   */
  export type hackernewsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * The data needed to create a hackernews.
     */
    data: XOR<hackernewsCreateInput, hackernewsUncheckedCreateInput>
  }


  /**
   * hackernews createMany
   */
  export type hackernewsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many hackernews.
     */
    data: hackernewsCreateManyInput | hackernewsCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * hackernews update
   */
  export type hackernewsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * The data needed to update a hackernews.
     */
    data: XOR<hackernewsUpdateInput, hackernewsUncheckedUpdateInput>
    /**
     * Choose, which hackernews to update.
     */
    where: hackernewsWhereUniqueInput
  }


  /**
   * hackernews updateMany
   */
  export type hackernewsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update hackernews.
     */
    data: XOR<hackernewsUpdateManyMutationInput, hackernewsUncheckedUpdateManyInput>
    /**
     * Filter which hackernews to update
     */
    where?: hackernewsWhereInput
  }


  /**
   * hackernews upsert
   */
  export type hackernewsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * The filter to search for the hackernews to update in case it exists.
     */
    where: hackernewsWhereUniqueInput
    /**
     * In case the hackernews found by the `where` argument doesn't exist, create a new hackernews with this data.
     */
    create: XOR<hackernewsCreateInput, hackernewsUncheckedCreateInput>
    /**
     * In case the hackernews was found with the provided `where` argument, update it with this data.
     */
    update: XOR<hackernewsUpdateInput, hackernewsUncheckedUpdateInput>
  }


  /**
   * hackernews delete
   */
  export type hackernewsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
    /**
     * Filter which hackernews to delete.
     */
    where: hackernewsWhereUniqueInput
  }


  /**
   * hackernews deleteMany
   */
  export type hackernewsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which hackernews to delete
     */
    where?: hackernewsWhereInput
  }


  /**
   * hackernews without action
   */
  export type hackernewsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the hackernews
     */
    select?: hackernewsSelect<ExtArgs> | null
  }



  /**
   * Model Redhat
   */

  export type AggregateRedhat = {
    _count: RedhatCountAggregateOutputType | null
    _min: RedhatMinAggregateOutputType | null
    _max: RedhatMaxAggregateOutputType | null
  }

  export type RedhatMinAggregateOutputType = {
    id: string | null
    RHSA: string | null
    severity: string | null
    released_on: string | null
    resource_url: string | null
  }

  export type RedhatMaxAggregateOutputType = {
    id: string | null
    RHSA: string | null
    severity: string | null
    released_on: string | null
    resource_url: string | null
  }

  export type RedhatCountAggregateOutputType = {
    id: number
    RHSA: number
    severity: number
    released_on: number
    CVEs: number
    bugzillas: number
    released_packages: number
    resource_url: number
    _all: number
  }


  export type RedhatMinAggregateInputType = {
    id?: true
    RHSA?: true
    severity?: true
    released_on?: true
    resource_url?: true
  }

  export type RedhatMaxAggregateInputType = {
    id?: true
    RHSA?: true
    severity?: true
    released_on?: true
    resource_url?: true
  }

  export type RedhatCountAggregateInputType = {
    id?: true
    RHSA?: true
    severity?: true
    released_on?: true
    CVEs?: true
    bugzillas?: true
    released_packages?: true
    resource_url?: true
    _all?: true
  }

  export type RedhatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat to aggregate.
     */
    where?: RedhatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhats to fetch.
     */
    orderBy?: RedhatOrderByWithRelationInput | RedhatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RedhatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhats
    **/
    _count?: true | RedhatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RedhatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RedhatMaxAggregateInputType
  }

  export type GetRedhatAggregateType<T extends RedhatAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat[P]>
      : GetScalarType<T[P], AggregateRedhat[P]>
  }




  export type RedhatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RedhatWhereInput
    orderBy?: RedhatOrderByWithAggregationInput | RedhatOrderByWithAggregationInput[]
    by: RedhatScalarFieldEnum[] | RedhatScalarFieldEnum
    having?: RedhatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RedhatCountAggregateInputType | true
    _min?: RedhatMinAggregateInputType
    _max?: RedhatMaxAggregateInputType
  }

  export type RedhatGroupByOutputType = {
    id: string
    RHSA: string
    severity: string
    released_on: string
    CVEs: string[]
    bugzillas: string[]
    released_packages: string[]
    resource_url: string
    _count: RedhatCountAggregateOutputType | null
    _min: RedhatMinAggregateOutputType | null
    _max: RedhatMaxAggregateOutputType | null
  }

  type GetRedhatGroupByPayload<T extends RedhatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RedhatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RedhatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RedhatGroupByOutputType[P]>
            : GetScalarType<T[P], RedhatGroupByOutputType[P]>
        }
      >
    >


  export type RedhatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    RHSA?: boolean
    severity?: boolean
    released_on?: boolean
    CVEs?: boolean
    bugzillas?: boolean
    released_packages?: boolean
    resource_url?: boolean
    document?: boolean | Redhat$documentArgs<ExtArgs>
    vulnerabilities?: boolean | Redhat$vulnerabilitiesArgs<ExtArgs>
    _count?: boolean | RedhatCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redhat"]>

  export type RedhatSelectScalar = {
    id?: boolean
    RHSA?: boolean
    severity?: boolean
    released_on?: boolean
    CVEs?: boolean
    bugzillas?: boolean
    released_packages?: boolean
    resource_url?: boolean
  }

  export type RedhatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat$documentArgs<ExtArgs>
    vulnerabilities?: boolean | Redhat$vulnerabilitiesArgs<ExtArgs>
    _count?: boolean | RedhatCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $RedhatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
      vulnerabilities: Prisma.$Redhat_VulnerabilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      RHSA: string
      severity: string
      released_on: string
      CVEs: string[]
      bugzillas: string[]
      released_packages: string[]
      resource_url: string
    }, ExtArgs["result"]["redhat"]>
    composites: {}
  }


  type RedhatGetPayload<S extends boolean | null | undefined | RedhatDefaultArgs> = $Result.GetResult<Prisma.$RedhatPayload, S>

  type RedhatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RedhatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RedhatCountAggregateInputType | true
    }

  export interface RedhatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat'], meta: { name: 'Redhat' } }
    /**
     * Find zero or one Redhat that matches the filter.
     * @param {RedhatFindUniqueArgs} args - Arguments to find a Redhat
     * @example
     * // Get one Redhat
     * const redhat = await prisma.redhat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends RedhatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatFindUniqueArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {RedhatFindUniqueOrThrowArgs} args - Arguments to find a Redhat
     * @example
     * // Get one Redhat
     * const redhat = await prisma.redhat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends RedhatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatFindFirstArgs} args - Arguments to find a Redhat
     * @example
     * // Get one Redhat
     * const redhat = await prisma.redhat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends RedhatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatFindFirstArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatFindFirstOrThrowArgs} args - Arguments to find a Redhat
     * @example
     * // Get one Redhat
     * const redhat = await prisma.redhat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends RedhatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhats
     * const redhats = await prisma.redhat.findMany()
     * 
     * // Get first 10 Redhats
     * const redhats = await prisma.redhat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhatWithIdOnly = await prisma.redhat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends RedhatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat.
     * @param {RedhatCreateArgs} args - Arguments to create a Redhat.
     * @example
     * // Create one Redhat
     * const Redhat = await prisma.redhat.create({
     *   data: {
     *     // ... data to create a Redhat
     *   }
     * })
     * 
    **/
    create<T extends RedhatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatCreateArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhats.
     *     @param {RedhatCreateManyArgs} args - Arguments to create many Redhats.
     *     @example
     *     // Create many Redhats
     *     const redhat = await prisma.redhat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends RedhatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat.
     * @param {RedhatDeleteArgs} args - Arguments to delete one Redhat.
     * @example
     * // Delete one Redhat
     * const Redhat = await prisma.redhat.delete({
     *   where: {
     *     // ... filter to delete one Redhat
     *   }
     * })
     * 
    **/
    delete<T extends RedhatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatDeleteArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat.
     * @param {RedhatUpdateArgs} args - Arguments to update one Redhat.
     * @example
     * // Update one Redhat
     * const redhat = await prisma.redhat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends RedhatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatUpdateArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhats.
     * @param {RedhatDeleteManyArgs} args - Arguments to filter Redhats to delete.
     * @example
     * // Delete a few Redhats
     * const { count } = await prisma.redhat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends RedhatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, RedhatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhats
     * const redhat = await prisma.redhat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends RedhatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat.
     * @param {RedhatUpsertArgs} args - Arguments to update or create a Redhat.
     * @example
     * // Update or create a Redhat
     * const redhat = await prisma.redhat.upsert({
     *   create: {
     *     // ... data to create a Redhat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat we want to update
     *   }
     * })
    **/
    upsert<T extends RedhatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, RedhatUpsertArgs<ExtArgs>>
    ): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatCountArgs} args - Arguments to filter Redhats to count.
     * @example
     * // Count the number of Redhats
     * const count = await prisma.redhat.count({
     *   where: {
     *     // ... the filter for the Redhats we want to count
     *   }
     * })
    **/
    count<T extends RedhatCountArgs>(
      args?: Subset<T, RedhatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RedhatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RedhatAggregateArgs>(args: Subset<T, RedhatAggregateArgs>): Prisma.PrismaPromise<GetRedhatAggregateType<T>>

    /**
     * Group by Redhat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RedhatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RedhatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RedhatGroupByArgs['orderBy'] }
        : { orderBy?: RedhatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RedhatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat model
   */
  readonly fields: RedhatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RedhatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    vulnerabilities<T extends Redhat$vulnerabilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Redhat$vulnerabilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat model
   */ 
  interface RedhatFieldRefs {
    readonly id: FieldRef<"Redhat", 'String'>
    readonly RHSA: FieldRef<"Redhat", 'String'>
    readonly severity: FieldRef<"Redhat", 'String'>
    readonly released_on: FieldRef<"Redhat", 'String'>
    readonly CVEs: FieldRef<"Redhat", 'String[]'>
    readonly bugzillas: FieldRef<"Redhat", 'String[]'>
    readonly released_packages: FieldRef<"Redhat", 'String[]'>
    readonly resource_url: FieldRef<"Redhat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat findUnique
   */
  export type RedhatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat to fetch.
     */
    where: RedhatWhereUniqueInput
  }


  /**
   * Redhat findUniqueOrThrow
   */
  export type RedhatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat to fetch.
     */
    where: RedhatWhereUniqueInput
  }


  /**
   * Redhat findFirst
   */
  export type RedhatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat to fetch.
     */
    where?: RedhatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhats to fetch.
     */
    orderBy?: RedhatOrderByWithRelationInput | RedhatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhats.
     */
    cursor?: RedhatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhats.
     */
    distinct?: RedhatScalarFieldEnum | RedhatScalarFieldEnum[]
  }


  /**
   * Redhat findFirstOrThrow
   */
  export type RedhatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat to fetch.
     */
    where?: RedhatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhats to fetch.
     */
    orderBy?: RedhatOrderByWithRelationInput | RedhatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhats.
     */
    cursor?: RedhatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhats.
     */
    distinct?: RedhatScalarFieldEnum | RedhatScalarFieldEnum[]
  }


  /**
   * Redhat findMany
   */
  export type RedhatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter, which Redhats to fetch.
     */
    where?: RedhatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhats to fetch.
     */
    orderBy?: RedhatOrderByWithRelationInput | RedhatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhats.
     */
    cursor?: RedhatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhats.
     */
    skip?: number
    distinct?: RedhatScalarFieldEnum | RedhatScalarFieldEnum[]
  }


  /**
   * Redhat create
   */
  export type RedhatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat.
     */
    data: XOR<RedhatCreateInput, RedhatUncheckedCreateInput>
  }


  /**
   * Redhat createMany
   */
  export type RedhatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhats.
     */
    data: RedhatCreateManyInput | RedhatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat update
   */
  export type RedhatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat.
     */
    data: XOR<RedhatUpdateInput, RedhatUncheckedUpdateInput>
    /**
     * Choose, which Redhat to update.
     */
    where: RedhatWhereUniqueInput
  }


  /**
   * Redhat updateMany
   */
  export type RedhatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhats.
     */
    data: XOR<RedhatUpdateManyMutationInput, RedhatUncheckedUpdateManyInput>
    /**
     * Filter which Redhats to update
     */
    where?: RedhatWhereInput
  }


  /**
   * Redhat upsert
   */
  export type RedhatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat to update in case it exists.
     */
    where: RedhatWhereUniqueInput
    /**
     * In case the Redhat found by the `where` argument doesn't exist, create a new Redhat with this data.
     */
    create: XOR<RedhatCreateInput, RedhatUncheckedCreateInput>
    /**
     * In case the Redhat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RedhatUpdateInput, RedhatUncheckedUpdateInput>
  }


  /**
   * Redhat delete
   */
  export type RedhatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    /**
     * Filter which Redhat to delete.
     */
    where: RedhatWhereUniqueInput
  }


  /**
   * Redhat deleteMany
   */
  export type RedhatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhats to delete
     */
    where?: RedhatWhereInput
  }


  /**
   * Redhat.document
   */
  export type Redhat$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat.vulnerabilities
   */
  export type Redhat$vulnerabilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
    orderBy?: Redhat_VulnerabilityOrderByWithRelationInput | Redhat_VulnerabilityOrderByWithRelationInput[]
    cursor?: Redhat_VulnerabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_VulnerabilityScalarFieldEnum | Redhat_VulnerabilityScalarFieldEnum[]
  }


  /**
   * Redhat without action
   */
  export type RedhatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Document
   */

  export type AggregateRedhat_Document = {
    _count: Redhat_DocumentCountAggregateOutputType | null
    _min: Redhat_DocumentMinAggregateOutputType | null
    _max: Redhat_DocumentMaxAggregateOutputType | null
  }

  export type Redhat_DocumentMinAggregateOutputType = {
    id: string | null
    category: string | null
    csaf_version: string | null
    lang: string | null
    title: string | null
    redhatId: string | null
    aggregateSeverityId: string | null
    distributionId: string | null
    publisherId: string | null
  }

  export type Redhat_DocumentMaxAggregateOutputType = {
    id: string | null
    category: string | null
    csaf_version: string | null
    lang: string | null
    title: string | null
    redhatId: string | null
    aggregateSeverityId: string | null
    distributionId: string | null
    publisherId: string | null
  }

  export type Redhat_DocumentCountAggregateOutputType = {
    id: number
    category: number
    csaf_version: number
    lang: number
    title: number
    redhatId: number
    aggregateSeverityId: number
    distributionId: number
    publisherId: number
    _all: number
  }


  export type Redhat_DocumentMinAggregateInputType = {
    id?: true
    category?: true
    csaf_version?: true
    lang?: true
    title?: true
    redhatId?: true
    aggregateSeverityId?: true
    distributionId?: true
    publisherId?: true
  }

  export type Redhat_DocumentMaxAggregateInputType = {
    id?: true
    category?: true
    csaf_version?: true
    lang?: true
    title?: true
    redhatId?: true
    aggregateSeverityId?: true
    distributionId?: true
    publisherId?: true
  }

  export type Redhat_DocumentCountAggregateInputType = {
    id?: true
    category?: true
    csaf_version?: true
    lang?: true
    title?: true
    redhatId?: true
    aggregateSeverityId?: true
    distributionId?: true
    publisherId?: true
    _all?: true
  }

  export type Redhat_DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Document to aggregate.
     */
    where?: Redhat_DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Documents to fetch.
     */
    orderBy?: Redhat_DocumentOrderByWithRelationInput | Redhat_DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Documents
    **/
    _count?: true | Redhat_DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_DocumentMaxAggregateInputType
  }

  export type GetRedhat_DocumentAggregateType<T extends Redhat_DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Document]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Document[P]>
      : GetScalarType<T[P], AggregateRedhat_Document[P]>
  }




  export type Redhat_DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_DocumentWhereInput
    orderBy?: Redhat_DocumentOrderByWithAggregationInput | Redhat_DocumentOrderByWithAggregationInput[]
    by: Redhat_DocumentScalarFieldEnum[] | Redhat_DocumentScalarFieldEnum
    having?: Redhat_DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_DocumentCountAggregateInputType | true
    _min?: Redhat_DocumentMinAggregateInputType
    _max?: Redhat_DocumentMaxAggregateInputType
  }

  export type Redhat_DocumentGroupByOutputType = {
    id: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId: string | null
    aggregateSeverityId: string | null
    distributionId: string | null
    publisherId: string | null
    _count: Redhat_DocumentCountAggregateOutputType | null
    _min: Redhat_DocumentMinAggregateOutputType | null
    _max: Redhat_DocumentMaxAggregateOutputType | null
  }

  type GetRedhat_DocumentGroupByPayload<T extends Redhat_DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_DocumentGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    csaf_version?: boolean
    lang?: boolean
    title?: boolean
    redhatId?: boolean
    aggregateSeverityId?: boolean
    distributionId?: boolean
    publisherId?: boolean
    aggregate_severity?: boolean | Redhat_Document$aggregate_severityArgs<ExtArgs>
    distribution?: boolean | Redhat_Document$distributionArgs<ExtArgs>
    publisher?: boolean | Redhat_Document$publisherArgs<ExtArgs>
    notes?: boolean | Redhat_Document$notesArgs<ExtArgs>
    references?: boolean | Redhat_Document$referencesArgs<ExtArgs>
    redhat?: boolean | Redhat_Document$redhatArgs<ExtArgs>
    tracking?: boolean | Redhat_Document$trackingArgs<ExtArgs>
    _count?: boolean | Redhat_DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Document"]>

  export type Redhat_DocumentSelectScalar = {
    id?: boolean
    category?: boolean
    csaf_version?: boolean
    lang?: boolean
    title?: boolean
    redhatId?: boolean
    aggregateSeverityId?: boolean
    distributionId?: boolean
    publisherId?: boolean
  }

  export type Redhat_DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    aggregate_severity?: boolean | Redhat_Document$aggregate_severityArgs<ExtArgs>
    distribution?: boolean | Redhat_Document$distributionArgs<ExtArgs>
    publisher?: boolean | Redhat_Document$publisherArgs<ExtArgs>
    notes?: boolean | Redhat_Document$notesArgs<ExtArgs>
    references?: boolean | Redhat_Document$referencesArgs<ExtArgs>
    redhat?: boolean | Redhat_Document$redhatArgs<ExtArgs>
    tracking?: boolean | Redhat_Document$trackingArgs<ExtArgs>
    _count?: boolean | Redhat_DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Redhat_DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Document"
    objects: {
      aggregate_severity: Prisma.$Redhat_AggregateSeverityPayload<ExtArgs> | null
      distribution: Prisma.$Redhat_DistributionPayload<ExtArgs> | null
      publisher: Prisma.$Redhat_PublisherPayload<ExtArgs> | null
      notes: Prisma.$Redhat_Document_NotePayload<ExtArgs>[]
      references: Prisma.$Redhat_Document_ReferencePayload<ExtArgs>[]
      redhat: Prisma.$RedhatPayload<ExtArgs> | null
      tracking: Prisma.$Redhat_TrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      csaf_version: string
      lang: string
      title: string
      redhatId: string | null
      aggregateSeverityId: string | null
      distributionId: string | null
      publisherId: string | null
    }, ExtArgs["result"]["redhat_Document"]>
    composites: {}
  }


  type Redhat_DocumentGetPayload<S extends boolean | null | undefined | Redhat_DocumentDefaultArgs> = $Result.GetResult<Prisma.$Redhat_DocumentPayload, S>

  type Redhat_DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_DocumentCountAggregateInputType | true
    }

  export interface Redhat_DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Document'], meta: { name: 'Redhat_Document' } }
    /**
     * Find zero or one Redhat_Document that matches the filter.
     * @param {Redhat_DocumentFindUniqueArgs} args - Arguments to find a Redhat_Document
     * @example
     * // Get one Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_DocumentFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Document that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_DocumentFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Document
     * @example
     * // Get one Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_DocumentFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentFindFirstArgs} args - Arguments to find a Redhat_Document
     * @example
     * // Get one Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_DocumentFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentFindFirstOrThrowArgs} args - Arguments to find a Redhat_Document
     * @example
     * // Get one Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_DocumentFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Documents
     * const redhat_Documents = await prisma.redhat_Document.findMany()
     * 
     * // Get first 10 Redhat_Documents
     * const redhat_Documents = await prisma.redhat_Document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_DocumentWithIdOnly = await prisma.redhat_Document.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_DocumentFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Document.
     * @param {Redhat_DocumentCreateArgs} args - Arguments to create a Redhat_Document.
     * @example
     * // Create one Redhat_Document
     * const Redhat_Document = await prisma.redhat_Document.create({
     *   data: {
     *     // ... data to create a Redhat_Document
     *   }
     * })
     * 
    **/
    create<T extends Redhat_DocumentCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentCreateArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Documents.
     *     @param {Redhat_DocumentCreateManyArgs} args - Arguments to create many Redhat_Documents.
     *     @example
     *     // Create many Redhat_Documents
     *     const redhat_Document = await prisma.redhat_Document.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_DocumentCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Document.
     * @param {Redhat_DocumentDeleteArgs} args - Arguments to delete one Redhat_Document.
     * @example
     * // Delete one Redhat_Document
     * const Redhat_Document = await prisma.redhat_Document.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Document
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_DocumentDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Document.
     * @param {Redhat_DocumentUpdateArgs} args - Arguments to update one Redhat_Document.
     * @example
     * // Update one Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_DocumentUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Documents.
     * @param {Redhat_DocumentDeleteManyArgs} args - Arguments to filter Redhat_Documents to delete.
     * @example
     * // Delete a few Redhat_Documents
     * const { count } = await prisma.redhat_Document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_DocumentDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DocumentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Documents
     * const redhat_Document = await prisma.redhat_Document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_DocumentUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Document.
     * @param {Redhat_DocumentUpsertArgs} args - Arguments to update or create a Redhat_Document.
     * @example
     * // Update or create a Redhat_Document
     * const redhat_Document = await prisma.redhat_Document.upsert({
     *   create: {
     *     // ... data to create a Redhat_Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Document we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_DocumentUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DocumentUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentCountArgs} args - Arguments to filter Redhat_Documents to count.
     * @example
     * // Count the number of Redhat_Documents
     * const count = await prisma.redhat_Document.count({
     *   where: {
     *     // ... the filter for the Redhat_Documents we want to count
     *   }
     * })
    **/
    count<T extends Redhat_DocumentCountArgs>(
      args?: Subset<T, Redhat_DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_DocumentAggregateArgs>(args: Subset<T, Redhat_DocumentAggregateArgs>): Prisma.PrismaPromise<GetRedhat_DocumentAggregateType<T>>

    /**
     * Group by Redhat_Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_DocumentGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_DocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Document model
   */
  readonly fields: Redhat_DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    aggregate_severity<T extends Redhat_Document$aggregate_severityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$aggregate_severityArgs<ExtArgs>>): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    distribution<T extends Redhat_Document$distributionArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$distributionArgs<ExtArgs>>): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    publisher<T extends Redhat_Document$publisherArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$publisherArgs<ExtArgs>>): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    notes<T extends Redhat_Document$notesArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findMany'> | Null>;

    references<T extends Redhat_Document$referencesArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    redhat<T extends Redhat_Document$redhatArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$redhatArgs<ExtArgs>>): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    tracking<T extends Redhat_Document$trackingArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document$trackingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Document model
   */ 
  interface Redhat_DocumentFieldRefs {
    readonly id: FieldRef<"Redhat_Document", 'String'>
    readonly category: FieldRef<"Redhat_Document", 'String'>
    readonly csaf_version: FieldRef<"Redhat_Document", 'String'>
    readonly lang: FieldRef<"Redhat_Document", 'String'>
    readonly title: FieldRef<"Redhat_Document", 'String'>
    readonly redhatId: FieldRef<"Redhat_Document", 'String'>
    readonly aggregateSeverityId: FieldRef<"Redhat_Document", 'String'>
    readonly distributionId: FieldRef<"Redhat_Document", 'String'>
    readonly publisherId: FieldRef<"Redhat_Document", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Document findUnique
   */
  export type Redhat_DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document to fetch.
     */
    where: Redhat_DocumentWhereUniqueInput
  }


  /**
   * Redhat_Document findUniqueOrThrow
   */
  export type Redhat_DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document to fetch.
     */
    where: Redhat_DocumentWhereUniqueInput
  }


  /**
   * Redhat_Document findFirst
   */
  export type Redhat_DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document to fetch.
     */
    where?: Redhat_DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Documents to fetch.
     */
    orderBy?: Redhat_DocumentOrderByWithRelationInput | Redhat_DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Documents.
     */
    cursor?: Redhat_DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Documents.
     */
    distinct?: Redhat_DocumentScalarFieldEnum | Redhat_DocumentScalarFieldEnum[]
  }


  /**
   * Redhat_Document findFirstOrThrow
   */
  export type Redhat_DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document to fetch.
     */
    where?: Redhat_DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Documents to fetch.
     */
    orderBy?: Redhat_DocumentOrderByWithRelationInput | Redhat_DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Documents.
     */
    cursor?: Redhat_DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Documents.
     */
    distinct?: Redhat_DocumentScalarFieldEnum | Redhat_DocumentScalarFieldEnum[]
  }


  /**
   * Redhat_Document findMany
   */
  export type Redhat_DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Documents to fetch.
     */
    where?: Redhat_DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Documents to fetch.
     */
    orderBy?: Redhat_DocumentOrderByWithRelationInput | Redhat_DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Documents.
     */
    cursor?: Redhat_DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Documents.
     */
    skip?: number
    distinct?: Redhat_DocumentScalarFieldEnum | Redhat_DocumentScalarFieldEnum[]
  }


  /**
   * Redhat_Document create
   */
  export type Redhat_DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Document.
     */
    data: XOR<Redhat_DocumentCreateInput, Redhat_DocumentUncheckedCreateInput>
  }


  /**
   * Redhat_Document createMany
   */
  export type Redhat_DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Documents.
     */
    data: Redhat_DocumentCreateManyInput | Redhat_DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Document update
   */
  export type Redhat_DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Document.
     */
    data: XOR<Redhat_DocumentUpdateInput, Redhat_DocumentUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Document to update.
     */
    where: Redhat_DocumentWhereUniqueInput
  }


  /**
   * Redhat_Document updateMany
   */
  export type Redhat_DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Documents.
     */
    data: XOR<Redhat_DocumentUpdateManyMutationInput, Redhat_DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Documents to update
     */
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Document upsert
   */
  export type Redhat_DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Document to update in case it exists.
     */
    where: Redhat_DocumentWhereUniqueInput
    /**
     * In case the Redhat_Document found by the `where` argument doesn't exist, create a new Redhat_Document with this data.
     */
    create: XOR<Redhat_DocumentCreateInput, Redhat_DocumentUncheckedCreateInput>
    /**
     * In case the Redhat_Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_DocumentUpdateInput, Redhat_DocumentUncheckedUpdateInput>
  }


  /**
   * Redhat_Document delete
   */
  export type Redhat_DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Document to delete.
     */
    where: Redhat_DocumentWhereUniqueInput
  }


  /**
   * Redhat_Document deleteMany
   */
  export type Redhat_DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Documents to delete
     */
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Document.aggregate_severity
   */
  export type Redhat_Document$aggregate_severityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    where?: Redhat_AggregateSeverityWhereInput
  }


  /**
   * Redhat_Document.distribution
   */
  export type Redhat_Document$distributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    where?: Redhat_DistributionWhereInput
  }


  /**
   * Redhat_Document.publisher
   */
  export type Redhat_Document$publisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    where?: Redhat_PublisherWhereInput
  }


  /**
   * Redhat_Document.notes
   */
  export type Redhat_Document$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    where?: Redhat_Document_NoteWhereInput
    orderBy?: Redhat_Document_NoteOrderByWithRelationInput | Redhat_Document_NoteOrderByWithRelationInput[]
    cursor?: Redhat_Document_NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Document_NoteScalarFieldEnum | Redhat_Document_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Document.references
   */
  export type Redhat_Document$referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    where?: Redhat_Document_ReferenceWhereInput
    orderBy?: Redhat_Document_ReferenceOrderByWithRelationInput | Redhat_Document_ReferenceOrderByWithRelationInput[]
    cursor?: Redhat_Document_ReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Document_ReferenceScalarFieldEnum | Redhat_Document_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Document.redhat
   */
  export type Redhat_Document$redhatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    where?: RedhatWhereInput
  }


  /**
   * Redhat_Document.tracking
   */
  export type Redhat_Document$trackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    where?: Redhat_TrackingWhereInput
    orderBy?: Redhat_TrackingOrderByWithRelationInput | Redhat_TrackingOrderByWithRelationInput[]
    cursor?: Redhat_TrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_TrackingScalarFieldEnum | Redhat_TrackingScalarFieldEnum[]
  }


  /**
   * Redhat_Document without action
   */
  export type Redhat_DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Tracking
   */

  export type AggregateRedhat_Tracking = {
    _count: Redhat_TrackingCountAggregateOutputType | null
    _min: Redhat_TrackingMinAggregateOutputType | null
    _max: Redhat_TrackingMaxAggregateOutputType | null
  }

  export type Redhat_TrackingMinAggregateOutputType = {
    id: string | null
    current_release_date: string | null
    ID: string | null
    documentId: string | null
  }

  export type Redhat_TrackingMaxAggregateOutputType = {
    id: string | null
    current_release_date: string | null
    ID: string | null
    documentId: string | null
  }

  export type Redhat_TrackingCountAggregateOutputType = {
    id: number
    current_release_date: number
    ID: number
    documentId: number
    _all: number
  }


  export type Redhat_TrackingMinAggregateInputType = {
    id?: true
    current_release_date?: true
    ID?: true
    documentId?: true
  }

  export type Redhat_TrackingMaxAggregateInputType = {
    id?: true
    current_release_date?: true
    ID?: true
    documentId?: true
  }

  export type Redhat_TrackingCountAggregateInputType = {
    id?: true
    current_release_date?: true
    ID?: true
    documentId?: true
    _all?: true
  }

  export type Redhat_TrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Tracking to aggregate.
     */
    where?: Redhat_TrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Trackings to fetch.
     */
    orderBy?: Redhat_TrackingOrderByWithRelationInput | Redhat_TrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_TrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Trackings
    **/
    _count?: true | Redhat_TrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_TrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_TrackingMaxAggregateInputType
  }

  export type GetRedhat_TrackingAggregateType<T extends Redhat_TrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Tracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Tracking[P]>
      : GetScalarType<T[P], AggregateRedhat_Tracking[P]>
  }




  export type Redhat_TrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_TrackingWhereInput
    orderBy?: Redhat_TrackingOrderByWithAggregationInput | Redhat_TrackingOrderByWithAggregationInput[]
    by: Redhat_TrackingScalarFieldEnum[] | Redhat_TrackingScalarFieldEnum
    having?: Redhat_TrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_TrackingCountAggregateInputType | true
    _min?: Redhat_TrackingMinAggregateInputType
    _max?: Redhat_TrackingMaxAggregateInputType
  }

  export type Redhat_TrackingGroupByOutputType = {
    id: string
    current_release_date: string
    ID: string
    documentId: string | null
    _count: Redhat_TrackingCountAggregateOutputType | null
    _min: Redhat_TrackingMinAggregateOutputType | null
    _max: Redhat_TrackingMaxAggregateOutputType | null
  }

  type GetRedhat_TrackingGroupByPayload<T extends Redhat_TrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_TrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_TrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_TrackingGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_TrackingGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_TrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    current_release_date?: boolean
    ID?: boolean
    documentId?: boolean
    document?: boolean | Redhat_Tracking$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Tracking"]>

  export type Redhat_TrackingSelectScalar = {
    id?: boolean
    current_release_date?: boolean
    ID?: boolean
    documentId?: boolean
  }

  export type Redhat_TrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat_Tracking$documentArgs<ExtArgs>
  }


  export type $Redhat_TrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Tracking"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      current_release_date: string
      ID: string
      documentId: string | null
    }, ExtArgs["result"]["redhat_Tracking"]>
    composites: {}
  }


  type Redhat_TrackingGetPayload<S extends boolean | null | undefined | Redhat_TrackingDefaultArgs> = $Result.GetResult<Prisma.$Redhat_TrackingPayload, S>

  type Redhat_TrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_TrackingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_TrackingCountAggregateInputType | true
    }

  export interface Redhat_TrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Tracking'], meta: { name: 'Redhat_Tracking' } }
    /**
     * Find zero or one Redhat_Tracking that matches the filter.
     * @param {Redhat_TrackingFindUniqueArgs} args - Arguments to find a Redhat_Tracking
     * @example
     * // Get one Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_TrackingFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Tracking that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_TrackingFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Tracking
     * @example
     * // Get one Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_TrackingFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Tracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingFindFirstArgs} args - Arguments to find a Redhat_Tracking
     * @example
     * // Get one Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_TrackingFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Tracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingFindFirstOrThrowArgs} args - Arguments to find a Redhat_Tracking
     * @example
     * // Get one Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_TrackingFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Trackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Trackings
     * const redhat_Trackings = await prisma.redhat_Tracking.findMany()
     * 
     * // Get first 10 Redhat_Trackings
     * const redhat_Trackings = await prisma.redhat_Tracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_TrackingWithIdOnly = await prisma.redhat_Tracking.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_TrackingFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Tracking.
     * @param {Redhat_TrackingCreateArgs} args - Arguments to create a Redhat_Tracking.
     * @example
     * // Create one Redhat_Tracking
     * const Redhat_Tracking = await prisma.redhat_Tracking.create({
     *   data: {
     *     // ... data to create a Redhat_Tracking
     *   }
     * })
     * 
    **/
    create<T extends Redhat_TrackingCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingCreateArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Trackings.
     *     @param {Redhat_TrackingCreateManyArgs} args - Arguments to create many Redhat_Trackings.
     *     @example
     *     // Create many Redhat_Trackings
     *     const redhat_Tracking = await prisma.redhat_Tracking.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_TrackingCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Tracking.
     * @param {Redhat_TrackingDeleteArgs} args - Arguments to delete one Redhat_Tracking.
     * @example
     * // Delete one Redhat_Tracking
     * const Redhat_Tracking = await prisma.redhat_Tracking.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Tracking
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_TrackingDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Tracking.
     * @param {Redhat_TrackingUpdateArgs} args - Arguments to update one Redhat_Tracking.
     * @example
     * // Update one Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_TrackingUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Trackings.
     * @param {Redhat_TrackingDeleteManyArgs} args - Arguments to filter Redhat_Trackings to delete.
     * @example
     * // Delete a few Redhat_Trackings
     * const { count } = await prisma.redhat_Tracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_TrackingDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TrackingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Trackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Trackings
     * const redhat_Tracking = await prisma.redhat_Tracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_TrackingUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Tracking.
     * @param {Redhat_TrackingUpsertArgs} args - Arguments to update or create a Redhat_Tracking.
     * @example
     * // Update or create a Redhat_Tracking
     * const redhat_Tracking = await prisma.redhat_Tracking.upsert({
     *   create: {
     *     // ... data to create a Redhat_Tracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Tracking we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_TrackingUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TrackingUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_TrackingClient<$Result.GetResult<Prisma.$Redhat_TrackingPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Trackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingCountArgs} args - Arguments to filter Redhat_Trackings to count.
     * @example
     * // Count the number of Redhat_Trackings
     * const count = await prisma.redhat_Tracking.count({
     *   where: {
     *     // ... the filter for the Redhat_Trackings we want to count
     *   }
     * })
    **/
    count<T extends Redhat_TrackingCountArgs>(
      args?: Subset<T, Redhat_TrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_TrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Tracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_TrackingAggregateArgs>(args: Subset<T, Redhat_TrackingAggregateArgs>): Prisma.PrismaPromise<GetRedhat_TrackingAggregateType<T>>

    /**
     * Group by Redhat_Tracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_TrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_TrackingGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_TrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_TrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_TrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Tracking model
   */
  readonly fields: Redhat_TrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Tracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_TrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat_Tracking$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Tracking$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Tracking model
   */ 
  interface Redhat_TrackingFieldRefs {
    readonly id: FieldRef<"Redhat_Tracking", 'String'>
    readonly current_release_date: FieldRef<"Redhat_Tracking", 'String'>
    readonly ID: FieldRef<"Redhat_Tracking", 'String'>
    readonly documentId: FieldRef<"Redhat_Tracking", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Tracking findUnique
   */
  export type Redhat_TrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tracking to fetch.
     */
    where: Redhat_TrackingWhereUniqueInput
  }


  /**
   * Redhat_Tracking findUniqueOrThrow
   */
  export type Redhat_TrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tracking to fetch.
     */
    where: Redhat_TrackingWhereUniqueInput
  }


  /**
   * Redhat_Tracking findFirst
   */
  export type Redhat_TrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tracking to fetch.
     */
    where?: Redhat_TrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Trackings to fetch.
     */
    orderBy?: Redhat_TrackingOrderByWithRelationInput | Redhat_TrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Trackings.
     */
    cursor?: Redhat_TrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Trackings.
     */
    distinct?: Redhat_TrackingScalarFieldEnum | Redhat_TrackingScalarFieldEnum[]
  }


  /**
   * Redhat_Tracking findFirstOrThrow
   */
  export type Redhat_TrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tracking to fetch.
     */
    where?: Redhat_TrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Trackings to fetch.
     */
    orderBy?: Redhat_TrackingOrderByWithRelationInput | Redhat_TrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Trackings.
     */
    cursor?: Redhat_TrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Trackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Trackings.
     */
    distinct?: Redhat_TrackingScalarFieldEnum | Redhat_TrackingScalarFieldEnum[]
  }


  /**
   * Redhat_Tracking findMany
   */
  export type Redhat_TrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Trackings to fetch.
     */
    where?: Redhat_TrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Trackings to fetch.
     */
    orderBy?: Redhat_TrackingOrderByWithRelationInput | Redhat_TrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Trackings.
     */
    cursor?: Redhat_TrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Trackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Trackings.
     */
    skip?: number
    distinct?: Redhat_TrackingScalarFieldEnum | Redhat_TrackingScalarFieldEnum[]
  }


  /**
   * Redhat_Tracking create
   */
  export type Redhat_TrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Tracking.
     */
    data: XOR<Redhat_TrackingCreateInput, Redhat_TrackingUncheckedCreateInput>
  }


  /**
   * Redhat_Tracking createMany
   */
  export type Redhat_TrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Trackings.
     */
    data: Redhat_TrackingCreateManyInput | Redhat_TrackingCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Tracking update
   */
  export type Redhat_TrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Tracking.
     */
    data: XOR<Redhat_TrackingUpdateInput, Redhat_TrackingUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Tracking to update.
     */
    where: Redhat_TrackingWhereUniqueInput
  }


  /**
   * Redhat_Tracking updateMany
   */
  export type Redhat_TrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Trackings.
     */
    data: XOR<Redhat_TrackingUpdateManyMutationInput, Redhat_TrackingUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Trackings to update
     */
    where?: Redhat_TrackingWhereInput
  }


  /**
   * Redhat_Tracking upsert
   */
  export type Redhat_TrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Tracking to update in case it exists.
     */
    where: Redhat_TrackingWhereUniqueInput
    /**
     * In case the Redhat_Tracking found by the `where` argument doesn't exist, create a new Redhat_Tracking with this data.
     */
    create: XOR<Redhat_TrackingCreateInput, Redhat_TrackingUncheckedCreateInput>
    /**
     * In case the Redhat_Tracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_TrackingUpdateInput, Redhat_TrackingUncheckedUpdateInput>
  }


  /**
   * Redhat_Tracking delete
   */
  export type Redhat_TrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Tracking to delete.
     */
    where: Redhat_TrackingWhereUniqueInput
  }


  /**
   * Redhat_Tracking deleteMany
   */
  export type Redhat_TrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Trackings to delete
     */
    where?: Redhat_TrackingWhereInput
  }


  /**
   * Redhat_Tracking.document
   */
  export type Redhat_Tracking$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Tracking without action
   */
  export type Redhat_TrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tracking
     */
    select?: Redhat_TrackingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TrackingInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_AggregateSeverity
   */

  export type AggregateRedhat_AggregateSeverity = {
    _count: Redhat_AggregateSeverityCountAggregateOutputType | null
    _min: Redhat_AggregateSeverityMinAggregateOutputType | null
    _max: Redhat_AggregateSeverityMaxAggregateOutputType | null
  }

  export type Redhat_AggregateSeverityMinAggregateOutputType = {
    id: string | null
    namespace: string | null
    text: string | null
    documentId: string | null
  }

  export type Redhat_AggregateSeverityMaxAggregateOutputType = {
    id: string | null
    namespace: string | null
    text: string | null
    documentId: string | null
  }

  export type Redhat_AggregateSeverityCountAggregateOutputType = {
    id: number
    namespace: number
    text: number
    documentId: number
    _all: number
  }


  export type Redhat_AggregateSeverityMinAggregateInputType = {
    id?: true
    namespace?: true
    text?: true
    documentId?: true
  }

  export type Redhat_AggregateSeverityMaxAggregateInputType = {
    id?: true
    namespace?: true
    text?: true
    documentId?: true
  }

  export type Redhat_AggregateSeverityCountAggregateInputType = {
    id?: true
    namespace?: true
    text?: true
    documentId?: true
    _all?: true
  }

  export type Redhat_AggregateSeverityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_AggregateSeverity to aggregate.
     */
    where?: Redhat_AggregateSeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_AggregateSeverities to fetch.
     */
    orderBy?: Redhat_AggregateSeverityOrderByWithRelationInput | Redhat_AggregateSeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_AggregateSeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_AggregateSeverities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_AggregateSeverities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_AggregateSeverities
    **/
    _count?: true | Redhat_AggregateSeverityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_AggregateSeverityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_AggregateSeverityMaxAggregateInputType
  }

  export type GetRedhat_AggregateSeverityAggregateType<T extends Redhat_AggregateSeverityAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_AggregateSeverity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_AggregateSeverity[P]>
      : GetScalarType<T[P], AggregateRedhat_AggregateSeverity[P]>
  }




  export type Redhat_AggregateSeverityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_AggregateSeverityWhereInput
    orderBy?: Redhat_AggregateSeverityOrderByWithAggregationInput | Redhat_AggregateSeverityOrderByWithAggregationInput[]
    by: Redhat_AggregateSeverityScalarFieldEnum[] | Redhat_AggregateSeverityScalarFieldEnum
    having?: Redhat_AggregateSeverityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_AggregateSeverityCountAggregateInputType | true
    _min?: Redhat_AggregateSeverityMinAggregateInputType
    _max?: Redhat_AggregateSeverityMaxAggregateInputType
  }

  export type Redhat_AggregateSeverityGroupByOutputType = {
    id: string
    namespace: string
    text: string
    documentId: string | null
    _count: Redhat_AggregateSeverityCountAggregateOutputType | null
    _min: Redhat_AggregateSeverityMinAggregateOutputType | null
    _max: Redhat_AggregateSeverityMaxAggregateOutputType | null
  }

  type GetRedhat_AggregateSeverityGroupByPayload<T extends Redhat_AggregateSeverityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_AggregateSeverityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_AggregateSeverityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_AggregateSeverityGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_AggregateSeverityGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_AggregateSeveritySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    namespace?: boolean
    text?: boolean
    documentId?: boolean
    document?: boolean | Redhat_AggregateSeverity$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_AggregateSeverity"]>

  export type Redhat_AggregateSeveritySelectScalar = {
    id?: boolean
    namespace?: boolean
    text?: boolean
    documentId?: boolean
  }

  export type Redhat_AggregateSeverityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat_AggregateSeverity$documentArgs<ExtArgs>
  }


  export type $Redhat_AggregateSeverityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_AggregateSeverity"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      namespace: string
      text: string
      documentId: string | null
    }, ExtArgs["result"]["redhat_AggregateSeverity"]>
    composites: {}
  }


  type Redhat_AggregateSeverityGetPayload<S extends boolean | null | undefined | Redhat_AggregateSeverityDefaultArgs> = $Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload, S>

  type Redhat_AggregateSeverityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_AggregateSeverityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_AggregateSeverityCountAggregateInputType | true
    }

  export interface Redhat_AggregateSeverityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_AggregateSeverity'], meta: { name: 'Redhat_AggregateSeverity' } }
    /**
     * Find zero or one Redhat_AggregateSeverity that matches the filter.
     * @param {Redhat_AggregateSeverityFindUniqueArgs} args - Arguments to find a Redhat_AggregateSeverity
     * @example
     * // Get one Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_AggregateSeverityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_AggregateSeverity that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_AggregateSeverityFindUniqueOrThrowArgs} args - Arguments to find a Redhat_AggregateSeverity
     * @example
     * // Get one Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_AggregateSeverityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_AggregateSeverity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityFindFirstArgs} args - Arguments to find a Redhat_AggregateSeverity
     * @example
     * // Get one Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_AggregateSeverityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_AggregateSeverity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityFindFirstOrThrowArgs} args - Arguments to find a Redhat_AggregateSeverity
     * @example
     * // Get one Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_AggregateSeverityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_AggregateSeverities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_AggregateSeverities
     * const redhat_AggregateSeverities = await prisma.redhat_AggregateSeverity.findMany()
     * 
     * // Get first 10 Redhat_AggregateSeverities
     * const redhat_AggregateSeverities = await prisma.redhat_AggregateSeverity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_AggregateSeverityWithIdOnly = await prisma.redhat_AggregateSeverity.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_AggregateSeverityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_AggregateSeverity.
     * @param {Redhat_AggregateSeverityCreateArgs} args - Arguments to create a Redhat_AggregateSeverity.
     * @example
     * // Create one Redhat_AggregateSeverity
     * const Redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.create({
     *   data: {
     *     // ... data to create a Redhat_AggregateSeverity
     *   }
     * })
     * 
    **/
    create<T extends Redhat_AggregateSeverityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityCreateArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_AggregateSeverities.
     *     @param {Redhat_AggregateSeverityCreateManyArgs} args - Arguments to create many Redhat_AggregateSeverities.
     *     @example
     *     // Create many Redhat_AggregateSeverities
     *     const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_AggregateSeverityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_AggregateSeverity.
     * @param {Redhat_AggregateSeverityDeleteArgs} args - Arguments to delete one Redhat_AggregateSeverity.
     * @example
     * // Delete one Redhat_AggregateSeverity
     * const Redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.delete({
     *   where: {
     *     // ... filter to delete one Redhat_AggregateSeverity
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_AggregateSeverityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_AggregateSeverity.
     * @param {Redhat_AggregateSeverityUpdateArgs} args - Arguments to update one Redhat_AggregateSeverity.
     * @example
     * // Update one Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_AggregateSeverityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_AggregateSeverities.
     * @param {Redhat_AggregateSeverityDeleteManyArgs} args - Arguments to filter Redhat_AggregateSeverities to delete.
     * @example
     * // Delete a few Redhat_AggregateSeverities
     * const { count } = await prisma.redhat_AggregateSeverity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_AggregateSeverityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_AggregateSeverityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_AggregateSeverities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_AggregateSeverities
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_AggregateSeverityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_AggregateSeverity.
     * @param {Redhat_AggregateSeverityUpsertArgs} args - Arguments to update or create a Redhat_AggregateSeverity.
     * @example
     * // Update or create a Redhat_AggregateSeverity
     * const redhat_AggregateSeverity = await prisma.redhat_AggregateSeverity.upsert({
     *   create: {
     *     // ... data to create a Redhat_AggregateSeverity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_AggregateSeverity we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_AggregateSeverityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_AggregateSeverityUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_AggregateSeverityClient<$Result.GetResult<Prisma.$Redhat_AggregateSeverityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_AggregateSeverities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityCountArgs} args - Arguments to filter Redhat_AggregateSeverities to count.
     * @example
     * // Count the number of Redhat_AggregateSeverities
     * const count = await prisma.redhat_AggregateSeverity.count({
     *   where: {
     *     // ... the filter for the Redhat_AggregateSeverities we want to count
     *   }
     * })
    **/
    count<T extends Redhat_AggregateSeverityCountArgs>(
      args?: Subset<T, Redhat_AggregateSeverityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_AggregateSeverityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_AggregateSeverity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_AggregateSeverityAggregateArgs>(args: Subset<T, Redhat_AggregateSeverityAggregateArgs>): Prisma.PrismaPromise<GetRedhat_AggregateSeverityAggregateType<T>>

    /**
     * Group by Redhat_AggregateSeverity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_AggregateSeverityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_AggregateSeverityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_AggregateSeverityGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_AggregateSeverityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_AggregateSeverityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_AggregateSeverityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_AggregateSeverity model
   */
  readonly fields: Redhat_AggregateSeverityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_AggregateSeverity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_AggregateSeverityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat_AggregateSeverity$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_AggregateSeverity$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_AggregateSeverity model
   */ 
  interface Redhat_AggregateSeverityFieldRefs {
    readonly id: FieldRef<"Redhat_AggregateSeverity", 'String'>
    readonly namespace: FieldRef<"Redhat_AggregateSeverity", 'String'>
    readonly text: FieldRef<"Redhat_AggregateSeverity", 'String'>
    readonly documentId: FieldRef<"Redhat_AggregateSeverity", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_AggregateSeverity findUnique
   */
  export type Redhat_AggregateSeverityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_AggregateSeverity to fetch.
     */
    where: Redhat_AggregateSeverityWhereUniqueInput
  }


  /**
   * Redhat_AggregateSeverity findUniqueOrThrow
   */
  export type Redhat_AggregateSeverityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_AggregateSeverity to fetch.
     */
    where: Redhat_AggregateSeverityWhereUniqueInput
  }


  /**
   * Redhat_AggregateSeverity findFirst
   */
  export type Redhat_AggregateSeverityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_AggregateSeverity to fetch.
     */
    where?: Redhat_AggregateSeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_AggregateSeverities to fetch.
     */
    orderBy?: Redhat_AggregateSeverityOrderByWithRelationInput | Redhat_AggregateSeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_AggregateSeverities.
     */
    cursor?: Redhat_AggregateSeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_AggregateSeverities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_AggregateSeverities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_AggregateSeverities.
     */
    distinct?: Redhat_AggregateSeverityScalarFieldEnum | Redhat_AggregateSeverityScalarFieldEnum[]
  }


  /**
   * Redhat_AggregateSeverity findFirstOrThrow
   */
  export type Redhat_AggregateSeverityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_AggregateSeverity to fetch.
     */
    where?: Redhat_AggregateSeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_AggregateSeverities to fetch.
     */
    orderBy?: Redhat_AggregateSeverityOrderByWithRelationInput | Redhat_AggregateSeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_AggregateSeverities.
     */
    cursor?: Redhat_AggregateSeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_AggregateSeverities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_AggregateSeverities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_AggregateSeverities.
     */
    distinct?: Redhat_AggregateSeverityScalarFieldEnum | Redhat_AggregateSeverityScalarFieldEnum[]
  }


  /**
   * Redhat_AggregateSeverity findMany
   */
  export type Redhat_AggregateSeverityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_AggregateSeverities to fetch.
     */
    where?: Redhat_AggregateSeverityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_AggregateSeverities to fetch.
     */
    orderBy?: Redhat_AggregateSeverityOrderByWithRelationInput | Redhat_AggregateSeverityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_AggregateSeverities.
     */
    cursor?: Redhat_AggregateSeverityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_AggregateSeverities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_AggregateSeverities.
     */
    skip?: number
    distinct?: Redhat_AggregateSeverityScalarFieldEnum | Redhat_AggregateSeverityScalarFieldEnum[]
  }


  /**
   * Redhat_AggregateSeverity create
   */
  export type Redhat_AggregateSeverityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_AggregateSeverity.
     */
    data: XOR<Redhat_AggregateSeverityCreateInput, Redhat_AggregateSeverityUncheckedCreateInput>
  }


  /**
   * Redhat_AggregateSeverity createMany
   */
  export type Redhat_AggregateSeverityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_AggregateSeverities.
     */
    data: Redhat_AggregateSeverityCreateManyInput | Redhat_AggregateSeverityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_AggregateSeverity update
   */
  export type Redhat_AggregateSeverityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_AggregateSeverity.
     */
    data: XOR<Redhat_AggregateSeverityUpdateInput, Redhat_AggregateSeverityUncheckedUpdateInput>
    /**
     * Choose, which Redhat_AggregateSeverity to update.
     */
    where: Redhat_AggregateSeverityWhereUniqueInput
  }


  /**
   * Redhat_AggregateSeverity updateMany
   */
  export type Redhat_AggregateSeverityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_AggregateSeverities.
     */
    data: XOR<Redhat_AggregateSeverityUpdateManyMutationInput, Redhat_AggregateSeverityUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_AggregateSeverities to update
     */
    where?: Redhat_AggregateSeverityWhereInput
  }


  /**
   * Redhat_AggregateSeverity upsert
   */
  export type Redhat_AggregateSeverityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_AggregateSeverity to update in case it exists.
     */
    where: Redhat_AggregateSeverityWhereUniqueInput
    /**
     * In case the Redhat_AggregateSeverity found by the `where` argument doesn't exist, create a new Redhat_AggregateSeverity with this data.
     */
    create: XOR<Redhat_AggregateSeverityCreateInput, Redhat_AggregateSeverityUncheckedCreateInput>
    /**
     * In case the Redhat_AggregateSeverity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_AggregateSeverityUpdateInput, Redhat_AggregateSeverityUncheckedUpdateInput>
  }


  /**
   * Redhat_AggregateSeverity delete
   */
  export type Redhat_AggregateSeverityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
    /**
     * Filter which Redhat_AggregateSeverity to delete.
     */
    where: Redhat_AggregateSeverityWhereUniqueInput
  }


  /**
   * Redhat_AggregateSeverity deleteMany
   */
  export type Redhat_AggregateSeverityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_AggregateSeverities to delete
     */
    where?: Redhat_AggregateSeverityWhereInput
  }


  /**
   * Redhat_AggregateSeverity.document
   */
  export type Redhat_AggregateSeverity$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_AggregateSeverity without action
   */
  export type Redhat_AggregateSeverityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_AggregateSeverity
     */
    select?: Redhat_AggregateSeveritySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_AggregateSeverityInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Distribution
   */

  export type AggregateRedhat_Distribution = {
    _count: Redhat_DistributionCountAggregateOutputType | null
    _min: Redhat_DistributionMinAggregateOutputType | null
    _max: Redhat_DistributionMaxAggregateOutputType | null
  }

  export type Redhat_DistributionMinAggregateOutputType = {
    id: string | null
    text: string | null
    documentId: string | null
    tlpId: string | null
  }

  export type Redhat_DistributionMaxAggregateOutputType = {
    id: string | null
    text: string | null
    documentId: string | null
    tlpId: string | null
  }

  export type Redhat_DistributionCountAggregateOutputType = {
    id: number
    text: number
    documentId: number
    tlpId: number
    _all: number
  }


  export type Redhat_DistributionMinAggregateInputType = {
    id?: true
    text?: true
    documentId?: true
    tlpId?: true
  }

  export type Redhat_DistributionMaxAggregateInputType = {
    id?: true
    text?: true
    documentId?: true
    tlpId?: true
  }

  export type Redhat_DistributionCountAggregateInputType = {
    id?: true
    text?: true
    documentId?: true
    tlpId?: true
    _all?: true
  }

  export type Redhat_DistributionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Distribution to aggregate.
     */
    where?: Redhat_DistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Distributions to fetch.
     */
    orderBy?: Redhat_DistributionOrderByWithRelationInput | Redhat_DistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_DistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Distributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Distributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Distributions
    **/
    _count?: true | Redhat_DistributionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_DistributionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_DistributionMaxAggregateInputType
  }

  export type GetRedhat_DistributionAggregateType<T extends Redhat_DistributionAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Distribution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Distribution[P]>
      : GetScalarType<T[P], AggregateRedhat_Distribution[P]>
  }




  export type Redhat_DistributionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_DistributionWhereInput
    orderBy?: Redhat_DistributionOrderByWithAggregationInput | Redhat_DistributionOrderByWithAggregationInput[]
    by: Redhat_DistributionScalarFieldEnum[] | Redhat_DistributionScalarFieldEnum
    having?: Redhat_DistributionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_DistributionCountAggregateInputType | true
    _min?: Redhat_DistributionMinAggregateInputType
    _max?: Redhat_DistributionMaxAggregateInputType
  }

  export type Redhat_DistributionGroupByOutputType = {
    id: string
    text: string
    documentId: string | null
    tlpId: string | null
    _count: Redhat_DistributionCountAggregateOutputType | null
    _min: Redhat_DistributionMinAggregateOutputType | null
    _max: Redhat_DistributionMaxAggregateOutputType | null
  }

  type GetRedhat_DistributionGroupByPayload<T extends Redhat_DistributionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_DistributionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_DistributionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_DistributionGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_DistributionGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_DistributionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    text?: boolean
    documentId?: boolean
    tlpId?: boolean
    tlp?: boolean | Redhat_Distribution$tlpArgs<ExtArgs>
    document?: boolean | Redhat_Distribution$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Distribution"]>

  export type Redhat_DistributionSelectScalar = {
    id?: boolean
    text?: boolean
    documentId?: boolean
    tlpId?: boolean
  }

  export type Redhat_DistributionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tlp?: boolean | Redhat_Distribution$tlpArgs<ExtArgs>
    document?: boolean | Redhat_Distribution$documentArgs<ExtArgs>
  }


  export type $Redhat_DistributionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Distribution"
    objects: {
      tlp: Prisma.$Redhat_TlpPayload<ExtArgs> | null
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      text: string
      documentId: string | null
      tlpId: string | null
    }, ExtArgs["result"]["redhat_Distribution"]>
    composites: {}
  }


  type Redhat_DistributionGetPayload<S extends boolean | null | undefined | Redhat_DistributionDefaultArgs> = $Result.GetResult<Prisma.$Redhat_DistributionPayload, S>

  type Redhat_DistributionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_DistributionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_DistributionCountAggregateInputType | true
    }

  export interface Redhat_DistributionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Distribution'], meta: { name: 'Redhat_Distribution' } }
    /**
     * Find zero or one Redhat_Distribution that matches the filter.
     * @param {Redhat_DistributionFindUniqueArgs} args - Arguments to find a Redhat_Distribution
     * @example
     * // Get one Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_DistributionFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Distribution that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_DistributionFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Distribution
     * @example
     * // Get one Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_DistributionFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Distribution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionFindFirstArgs} args - Arguments to find a Redhat_Distribution
     * @example
     * // Get one Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_DistributionFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Distribution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionFindFirstOrThrowArgs} args - Arguments to find a Redhat_Distribution
     * @example
     * // Get one Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_DistributionFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Distributions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Distributions
     * const redhat_Distributions = await prisma.redhat_Distribution.findMany()
     * 
     * // Get first 10 Redhat_Distributions
     * const redhat_Distributions = await prisma.redhat_Distribution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_DistributionWithIdOnly = await prisma.redhat_Distribution.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_DistributionFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Distribution.
     * @param {Redhat_DistributionCreateArgs} args - Arguments to create a Redhat_Distribution.
     * @example
     * // Create one Redhat_Distribution
     * const Redhat_Distribution = await prisma.redhat_Distribution.create({
     *   data: {
     *     // ... data to create a Redhat_Distribution
     *   }
     * })
     * 
    **/
    create<T extends Redhat_DistributionCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionCreateArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Distributions.
     *     @param {Redhat_DistributionCreateManyArgs} args - Arguments to create many Redhat_Distributions.
     *     @example
     *     // Create many Redhat_Distributions
     *     const redhat_Distribution = await prisma.redhat_Distribution.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_DistributionCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Distribution.
     * @param {Redhat_DistributionDeleteArgs} args - Arguments to delete one Redhat_Distribution.
     * @example
     * // Delete one Redhat_Distribution
     * const Redhat_Distribution = await prisma.redhat_Distribution.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Distribution
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_DistributionDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Distribution.
     * @param {Redhat_DistributionUpdateArgs} args - Arguments to update one Redhat_Distribution.
     * @example
     * // Update one Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_DistributionUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Distributions.
     * @param {Redhat_DistributionDeleteManyArgs} args - Arguments to filter Redhat_Distributions to delete.
     * @example
     * // Delete a few Redhat_Distributions
     * const { count } = await prisma.redhat_Distribution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_DistributionDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_DistributionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Distributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Distributions
     * const redhat_Distribution = await prisma.redhat_Distribution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_DistributionUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Distribution.
     * @param {Redhat_DistributionUpsertArgs} args - Arguments to update or create a Redhat_Distribution.
     * @example
     * // Update or create a Redhat_Distribution
     * const redhat_Distribution = await prisma.redhat_Distribution.upsert({
     *   create: {
     *     // ... data to create a Redhat_Distribution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Distribution we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_DistributionUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_DistributionUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Distributions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionCountArgs} args - Arguments to filter Redhat_Distributions to count.
     * @example
     * // Count the number of Redhat_Distributions
     * const count = await prisma.redhat_Distribution.count({
     *   where: {
     *     // ... the filter for the Redhat_Distributions we want to count
     *   }
     * })
    **/
    count<T extends Redhat_DistributionCountArgs>(
      args?: Subset<T, Redhat_DistributionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_DistributionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Distribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_DistributionAggregateArgs>(args: Subset<T, Redhat_DistributionAggregateArgs>): Prisma.PrismaPromise<GetRedhat_DistributionAggregateType<T>>

    /**
     * Group by Redhat_Distribution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_DistributionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_DistributionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_DistributionGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_DistributionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_DistributionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_DistributionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Distribution model
   */
  readonly fields: Redhat_DistributionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Distribution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_DistributionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    tlp<T extends Redhat_Distribution$tlpArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Distribution$tlpArgs<ExtArgs>>): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    document<T extends Redhat_Distribution$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Distribution$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Distribution model
   */ 
  interface Redhat_DistributionFieldRefs {
    readonly id: FieldRef<"Redhat_Distribution", 'String'>
    readonly text: FieldRef<"Redhat_Distribution", 'String'>
    readonly documentId: FieldRef<"Redhat_Distribution", 'String'>
    readonly tlpId: FieldRef<"Redhat_Distribution", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Distribution findUnique
   */
  export type Redhat_DistributionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Distribution to fetch.
     */
    where: Redhat_DistributionWhereUniqueInput
  }


  /**
   * Redhat_Distribution findUniqueOrThrow
   */
  export type Redhat_DistributionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Distribution to fetch.
     */
    where: Redhat_DistributionWhereUniqueInput
  }


  /**
   * Redhat_Distribution findFirst
   */
  export type Redhat_DistributionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Distribution to fetch.
     */
    where?: Redhat_DistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Distributions to fetch.
     */
    orderBy?: Redhat_DistributionOrderByWithRelationInput | Redhat_DistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Distributions.
     */
    cursor?: Redhat_DistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Distributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Distributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Distributions.
     */
    distinct?: Redhat_DistributionScalarFieldEnum | Redhat_DistributionScalarFieldEnum[]
  }


  /**
   * Redhat_Distribution findFirstOrThrow
   */
  export type Redhat_DistributionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Distribution to fetch.
     */
    where?: Redhat_DistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Distributions to fetch.
     */
    orderBy?: Redhat_DistributionOrderByWithRelationInput | Redhat_DistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Distributions.
     */
    cursor?: Redhat_DistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Distributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Distributions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Distributions.
     */
    distinct?: Redhat_DistributionScalarFieldEnum | Redhat_DistributionScalarFieldEnum[]
  }


  /**
   * Redhat_Distribution findMany
   */
  export type Redhat_DistributionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Distributions to fetch.
     */
    where?: Redhat_DistributionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Distributions to fetch.
     */
    orderBy?: Redhat_DistributionOrderByWithRelationInput | Redhat_DistributionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Distributions.
     */
    cursor?: Redhat_DistributionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Distributions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Distributions.
     */
    skip?: number
    distinct?: Redhat_DistributionScalarFieldEnum | Redhat_DistributionScalarFieldEnum[]
  }


  /**
   * Redhat_Distribution create
   */
  export type Redhat_DistributionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Distribution.
     */
    data: XOR<Redhat_DistributionCreateInput, Redhat_DistributionUncheckedCreateInput>
  }


  /**
   * Redhat_Distribution createMany
   */
  export type Redhat_DistributionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Distributions.
     */
    data: Redhat_DistributionCreateManyInput | Redhat_DistributionCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Distribution update
   */
  export type Redhat_DistributionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Distribution.
     */
    data: XOR<Redhat_DistributionUpdateInput, Redhat_DistributionUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Distribution to update.
     */
    where: Redhat_DistributionWhereUniqueInput
  }


  /**
   * Redhat_Distribution updateMany
   */
  export type Redhat_DistributionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Distributions.
     */
    data: XOR<Redhat_DistributionUpdateManyMutationInput, Redhat_DistributionUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Distributions to update
     */
    where?: Redhat_DistributionWhereInput
  }


  /**
   * Redhat_Distribution upsert
   */
  export type Redhat_DistributionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Distribution to update in case it exists.
     */
    where: Redhat_DistributionWhereUniqueInput
    /**
     * In case the Redhat_Distribution found by the `where` argument doesn't exist, create a new Redhat_Distribution with this data.
     */
    create: XOR<Redhat_DistributionCreateInput, Redhat_DistributionUncheckedCreateInput>
    /**
     * In case the Redhat_Distribution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_DistributionUpdateInput, Redhat_DistributionUncheckedUpdateInput>
  }


  /**
   * Redhat_Distribution delete
   */
  export type Redhat_DistributionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Distribution to delete.
     */
    where: Redhat_DistributionWhereUniqueInput
  }


  /**
   * Redhat_Distribution deleteMany
   */
  export type Redhat_DistributionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Distributions to delete
     */
    where?: Redhat_DistributionWhereInput
  }


  /**
   * Redhat_Distribution.tlp
   */
  export type Redhat_Distribution$tlpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    where?: Redhat_TlpWhereInput
  }


  /**
   * Redhat_Distribution.document
   */
  export type Redhat_Distribution$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Distribution without action
   */
  export type Redhat_DistributionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Tlp
   */

  export type AggregateRedhat_Tlp = {
    _count: Redhat_TlpCountAggregateOutputType | null
    _min: Redhat_TlpMinAggregateOutputType | null
    _max: Redhat_TlpMaxAggregateOutputType | null
  }

  export type Redhat_TlpMinAggregateOutputType = {
    id: string | null
    label: string | null
    url: string | null
    distributionId: string | null
  }

  export type Redhat_TlpMaxAggregateOutputType = {
    id: string | null
    label: string | null
    url: string | null
    distributionId: string | null
  }

  export type Redhat_TlpCountAggregateOutputType = {
    id: number
    label: number
    url: number
    distributionId: number
    _all: number
  }


  export type Redhat_TlpMinAggregateInputType = {
    id?: true
    label?: true
    url?: true
    distributionId?: true
  }

  export type Redhat_TlpMaxAggregateInputType = {
    id?: true
    label?: true
    url?: true
    distributionId?: true
  }

  export type Redhat_TlpCountAggregateInputType = {
    id?: true
    label?: true
    url?: true
    distributionId?: true
    _all?: true
  }

  export type Redhat_TlpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Tlp to aggregate.
     */
    where?: Redhat_TlpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Tlps to fetch.
     */
    orderBy?: Redhat_TlpOrderByWithRelationInput | Redhat_TlpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_TlpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Tlps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Tlps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Tlps
    **/
    _count?: true | Redhat_TlpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_TlpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_TlpMaxAggregateInputType
  }

  export type GetRedhat_TlpAggregateType<T extends Redhat_TlpAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Tlp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Tlp[P]>
      : GetScalarType<T[P], AggregateRedhat_Tlp[P]>
  }




  export type Redhat_TlpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_TlpWhereInput
    orderBy?: Redhat_TlpOrderByWithAggregationInput | Redhat_TlpOrderByWithAggregationInput[]
    by: Redhat_TlpScalarFieldEnum[] | Redhat_TlpScalarFieldEnum
    having?: Redhat_TlpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_TlpCountAggregateInputType | true
    _min?: Redhat_TlpMinAggregateInputType
    _max?: Redhat_TlpMaxAggregateInputType
  }

  export type Redhat_TlpGroupByOutputType = {
    id: string
    label: string
    url: string
    distributionId: string | null
    _count: Redhat_TlpCountAggregateOutputType | null
    _min: Redhat_TlpMinAggregateOutputType | null
    _max: Redhat_TlpMaxAggregateOutputType | null
  }

  type GetRedhat_TlpGroupByPayload<T extends Redhat_TlpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_TlpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_TlpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_TlpGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_TlpGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_TlpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    url?: boolean
    distributionId?: boolean
    distribution?: boolean | Redhat_Tlp$distributionArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Tlp"]>

  export type Redhat_TlpSelectScalar = {
    id?: boolean
    label?: boolean
    url?: boolean
    distributionId?: boolean
  }

  export type Redhat_TlpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    distribution?: boolean | Redhat_Tlp$distributionArgs<ExtArgs>
  }


  export type $Redhat_TlpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Tlp"
    objects: {
      distribution: Prisma.$Redhat_DistributionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      url: string
      distributionId: string | null
    }, ExtArgs["result"]["redhat_Tlp"]>
    composites: {}
  }


  type Redhat_TlpGetPayload<S extends boolean | null | undefined | Redhat_TlpDefaultArgs> = $Result.GetResult<Prisma.$Redhat_TlpPayload, S>

  type Redhat_TlpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_TlpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_TlpCountAggregateInputType | true
    }

  export interface Redhat_TlpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Tlp'], meta: { name: 'Redhat_Tlp' } }
    /**
     * Find zero or one Redhat_Tlp that matches the filter.
     * @param {Redhat_TlpFindUniqueArgs} args - Arguments to find a Redhat_Tlp
     * @example
     * // Get one Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_TlpFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Tlp that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_TlpFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Tlp
     * @example
     * // Get one Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_TlpFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Tlp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpFindFirstArgs} args - Arguments to find a Redhat_Tlp
     * @example
     * // Get one Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_TlpFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Tlp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpFindFirstOrThrowArgs} args - Arguments to find a Redhat_Tlp
     * @example
     * // Get one Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_TlpFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Tlps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Tlps
     * const redhat_Tlps = await prisma.redhat_Tlp.findMany()
     * 
     * // Get first 10 Redhat_Tlps
     * const redhat_Tlps = await prisma.redhat_Tlp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_TlpWithIdOnly = await prisma.redhat_Tlp.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_TlpFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Tlp.
     * @param {Redhat_TlpCreateArgs} args - Arguments to create a Redhat_Tlp.
     * @example
     * // Create one Redhat_Tlp
     * const Redhat_Tlp = await prisma.redhat_Tlp.create({
     *   data: {
     *     // ... data to create a Redhat_Tlp
     *   }
     * })
     * 
    **/
    create<T extends Redhat_TlpCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpCreateArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Tlps.
     *     @param {Redhat_TlpCreateManyArgs} args - Arguments to create many Redhat_Tlps.
     *     @example
     *     // Create many Redhat_Tlps
     *     const redhat_Tlp = await prisma.redhat_Tlp.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_TlpCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Tlp.
     * @param {Redhat_TlpDeleteArgs} args - Arguments to delete one Redhat_Tlp.
     * @example
     * // Delete one Redhat_Tlp
     * const Redhat_Tlp = await prisma.redhat_Tlp.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Tlp
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_TlpDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Tlp.
     * @param {Redhat_TlpUpdateArgs} args - Arguments to update one Redhat_Tlp.
     * @example
     * // Update one Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_TlpUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Tlps.
     * @param {Redhat_TlpDeleteManyArgs} args - Arguments to filter Redhat_Tlps to delete.
     * @example
     * // Delete a few Redhat_Tlps
     * const { count } = await prisma.redhat_Tlp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_TlpDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_TlpDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Tlps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Tlps
     * const redhat_Tlp = await prisma.redhat_Tlp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_TlpUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Tlp.
     * @param {Redhat_TlpUpsertArgs} args - Arguments to update or create a Redhat_Tlp.
     * @example
     * // Update or create a Redhat_Tlp
     * const redhat_Tlp = await prisma.redhat_Tlp.upsert({
     *   create: {
     *     // ... data to create a Redhat_Tlp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Tlp we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_TlpUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_TlpUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_TlpClient<$Result.GetResult<Prisma.$Redhat_TlpPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Tlps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpCountArgs} args - Arguments to filter Redhat_Tlps to count.
     * @example
     * // Count the number of Redhat_Tlps
     * const count = await prisma.redhat_Tlp.count({
     *   where: {
     *     // ... the filter for the Redhat_Tlps we want to count
     *   }
     * })
    **/
    count<T extends Redhat_TlpCountArgs>(
      args?: Subset<T, Redhat_TlpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_TlpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Tlp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_TlpAggregateArgs>(args: Subset<T, Redhat_TlpAggregateArgs>): Prisma.PrismaPromise<GetRedhat_TlpAggregateType<T>>

    /**
     * Group by Redhat_Tlp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_TlpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_TlpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_TlpGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_TlpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_TlpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_TlpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Tlp model
   */
  readonly fields: Redhat_TlpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Tlp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_TlpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    distribution<T extends Redhat_Tlp$distributionArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Tlp$distributionArgs<ExtArgs>>): Prisma__Redhat_DistributionClient<$Result.GetResult<Prisma.$Redhat_DistributionPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Tlp model
   */ 
  interface Redhat_TlpFieldRefs {
    readonly id: FieldRef<"Redhat_Tlp", 'String'>
    readonly label: FieldRef<"Redhat_Tlp", 'String'>
    readonly url: FieldRef<"Redhat_Tlp", 'String'>
    readonly distributionId: FieldRef<"Redhat_Tlp", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Tlp findUnique
   */
  export type Redhat_TlpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tlp to fetch.
     */
    where: Redhat_TlpWhereUniqueInput
  }


  /**
   * Redhat_Tlp findUniqueOrThrow
   */
  export type Redhat_TlpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tlp to fetch.
     */
    where: Redhat_TlpWhereUniqueInput
  }


  /**
   * Redhat_Tlp findFirst
   */
  export type Redhat_TlpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tlp to fetch.
     */
    where?: Redhat_TlpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Tlps to fetch.
     */
    orderBy?: Redhat_TlpOrderByWithRelationInput | Redhat_TlpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Tlps.
     */
    cursor?: Redhat_TlpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Tlps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Tlps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Tlps.
     */
    distinct?: Redhat_TlpScalarFieldEnum | Redhat_TlpScalarFieldEnum[]
  }


  /**
   * Redhat_Tlp findFirstOrThrow
   */
  export type Redhat_TlpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tlp to fetch.
     */
    where?: Redhat_TlpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Tlps to fetch.
     */
    orderBy?: Redhat_TlpOrderByWithRelationInput | Redhat_TlpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Tlps.
     */
    cursor?: Redhat_TlpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Tlps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Tlps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Tlps.
     */
    distinct?: Redhat_TlpScalarFieldEnum | Redhat_TlpScalarFieldEnum[]
  }


  /**
   * Redhat_Tlp findMany
   */
  export type Redhat_TlpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Tlps to fetch.
     */
    where?: Redhat_TlpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Tlps to fetch.
     */
    orderBy?: Redhat_TlpOrderByWithRelationInput | Redhat_TlpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Tlps.
     */
    cursor?: Redhat_TlpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Tlps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Tlps.
     */
    skip?: number
    distinct?: Redhat_TlpScalarFieldEnum | Redhat_TlpScalarFieldEnum[]
  }


  /**
   * Redhat_Tlp create
   */
  export type Redhat_TlpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Tlp.
     */
    data: XOR<Redhat_TlpCreateInput, Redhat_TlpUncheckedCreateInput>
  }


  /**
   * Redhat_Tlp createMany
   */
  export type Redhat_TlpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Tlps.
     */
    data: Redhat_TlpCreateManyInput | Redhat_TlpCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Tlp update
   */
  export type Redhat_TlpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Tlp.
     */
    data: XOR<Redhat_TlpUpdateInput, Redhat_TlpUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Tlp to update.
     */
    where: Redhat_TlpWhereUniqueInput
  }


  /**
   * Redhat_Tlp updateMany
   */
  export type Redhat_TlpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Tlps.
     */
    data: XOR<Redhat_TlpUpdateManyMutationInput, Redhat_TlpUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Tlps to update
     */
    where?: Redhat_TlpWhereInput
  }


  /**
   * Redhat_Tlp upsert
   */
  export type Redhat_TlpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Tlp to update in case it exists.
     */
    where: Redhat_TlpWhereUniqueInput
    /**
     * In case the Redhat_Tlp found by the `where` argument doesn't exist, create a new Redhat_Tlp with this data.
     */
    create: XOR<Redhat_TlpCreateInput, Redhat_TlpUncheckedCreateInput>
    /**
     * In case the Redhat_Tlp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_TlpUpdateInput, Redhat_TlpUncheckedUpdateInput>
  }


  /**
   * Redhat_Tlp delete
   */
  export type Redhat_TlpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Tlp to delete.
     */
    where: Redhat_TlpWhereUniqueInput
  }


  /**
   * Redhat_Tlp deleteMany
   */
  export type Redhat_TlpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Tlps to delete
     */
    where?: Redhat_TlpWhereInput
  }


  /**
   * Redhat_Tlp.distribution
   */
  export type Redhat_Tlp$distributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Distribution
     */
    select?: Redhat_DistributionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DistributionInclude<ExtArgs> | null
    where?: Redhat_DistributionWhereInput
  }


  /**
   * Redhat_Tlp without action
   */
  export type Redhat_TlpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Tlp
     */
    select?: Redhat_TlpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_TlpInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Document_Note
   */

  export type AggregateRedhat_Document_Note = {
    _count: Redhat_Document_NoteCountAggregateOutputType | null
    _min: Redhat_Document_NoteMinAggregateOutputType | null
    _max: Redhat_Document_NoteMaxAggregateOutputType | null
  }

  export type Redhat_Document_NoteMinAggregateOutputType = {
    id: string | null
    category: string | null
    text: string | null
    title: string | null
    documentId: string | null
  }

  export type Redhat_Document_NoteMaxAggregateOutputType = {
    id: string | null
    category: string | null
    text: string | null
    title: string | null
    documentId: string | null
  }

  export type Redhat_Document_NoteCountAggregateOutputType = {
    id: number
    category: number
    text: number
    title: number
    documentId: number
    _all: number
  }


  export type Redhat_Document_NoteMinAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    documentId?: true
  }

  export type Redhat_Document_NoteMaxAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    documentId?: true
  }

  export type Redhat_Document_NoteCountAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    documentId?: true
    _all?: true
  }

  export type Redhat_Document_NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Document_Note to aggregate.
     */
    where?: Redhat_Document_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_Notes to fetch.
     */
    orderBy?: Redhat_Document_NoteOrderByWithRelationInput | Redhat_Document_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Document_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Document_Notes
    **/
    _count?: true | Redhat_Document_NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Document_NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Document_NoteMaxAggregateInputType
  }

  export type GetRedhat_Document_NoteAggregateType<T extends Redhat_Document_NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Document_Note]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Document_Note[P]>
      : GetScalarType<T[P], AggregateRedhat_Document_Note[P]>
  }




  export type Redhat_Document_NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Document_NoteWhereInput
    orderBy?: Redhat_Document_NoteOrderByWithAggregationInput | Redhat_Document_NoteOrderByWithAggregationInput[]
    by: Redhat_Document_NoteScalarFieldEnum[] | Redhat_Document_NoteScalarFieldEnum
    having?: Redhat_Document_NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Document_NoteCountAggregateInputType | true
    _min?: Redhat_Document_NoteMinAggregateInputType
    _max?: Redhat_Document_NoteMaxAggregateInputType
  }

  export type Redhat_Document_NoteGroupByOutputType = {
    id: string
    category: string
    text: string
    title: string
    documentId: string | null
    _count: Redhat_Document_NoteCountAggregateOutputType | null
    _min: Redhat_Document_NoteMinAggregateOutputType | null
    _max: Redhat_Document_NoteMaxAggregateOutputType | null
  }

  type GetRedhat_Document_NoteGroupByPayload<T extends Redhat_Document_NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Document_NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Document_NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Document_NoteGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Document_NoteGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Document_NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    text?: boolean
    title?: boolean
    documentId?: boolean
    document?: boolean | Redhat_Document_Note$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Document_Note"]>

  export type Redhat_Document_NoteSelectScalar = {
    id?: boolean
    category?: boolean
    text?: boolean
    title?: boolean
    documentId?: boolean
  }

  export type Redhat_Document_NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat_Document_Note$documentArgs<ExtArgs>
  }


  export type $Redhat_Document_NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Document_Note"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      text: string
      title: string
      documentId: string | null
    }, ExtArgs["result"]["redhat_Document_Note"]>
    composites: {}
  }


  type Redhat_Document_NoteGetPayload<S extends boolean | null | undefined | Redhat_Document_NoteDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Document_NotePayload, S>

  type Redhat_Document_NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Document_NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Document_NoteCountAggregateInputType | true
    }

  export interface Redhat_Document_NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Document_Note'], meta: { name: 'Redhat_Document_Note' } }
    /**
     * Find zero or one Redhat_Document_Note that matches the filter.
     * @param {Redhat_Document_NoteFindUniqueArgs} args - Arguments to find a Redhat_Document_Note
     * @example
     * // Get one Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Document_NoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Document_Note that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Document_NoteFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Document_Note
     * @example
     * // Get one Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Document_NoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Document_Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteFindFirstArgs} args - Arguments to find a Redhat_Document_Note
     * @example
     * // Get one Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Document_NoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Document_Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteFindFirstOrThrowArgs} args - Arguments to find a Redhat_Document_Note
     * @example
     * // Get one Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Document_NoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Document_Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Document_Notes
     * const redhat_Document_Notes = await prisma.redhat_Document_Note.findMany()
     * 
     * // Get first 10 Redhat_Document_Notes
     * const redhat_Document_Notes = await prisma.redhat_Document_Note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Document_NoteWithIdOnly = await prisma.redhat_Document_Note.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Document_NoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Document_Note.
     * @param {Redhat_Document_NoteCreateArgs} args - Arguments to create a Redhat_Document_Note.
     * @example
     * // Create one Redhat_Document_Note
     * const Redhat_Document_Note = await prisma.redhat_Document_Note.create({
     *   data: {
     *     // ... data to create a Redhat_Document_Note
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Document_NoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Document_Notes.
     *     @param {Redhat_Document_NoteCreateManyArgs} args - Arguments to create many Redhat_Document_Notes.
     *     @example
     *     // Create many Redhat_Document_Notes
     *     const redhat_Document_Note = await prisma.redhat_Document_Note.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Document_NoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Document_Note.
     * @param {Redhat_Document_NoteDeleteArgs} args - Arguments to delete one Redhat_Document_Note.
     * @example
     * // Delete one Redhat_Document_Note
     * const Redhat_Document_Note = await prisma.redhat_Document_Note.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Document_Note
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Document_NoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Document_Note.
     * @param {Redhat_Document_NoteUpdateArgs} args - Arguments to update one Redhat_Document_Note.
     * @example
     * // Update one Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Document_NoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Document_Notes.
     * @param {Redhat_Document_NoteDeleteManyArgs} args - Arguments to filter Redhat_Document_Notes to delete.
     * @example
     * // Delete a few Redhat_Document_Notes
     * const { count } = await prisma.redhat_Document_Note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Document_NoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_NoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Document_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Document_Notes
     * const redhat_Document_Note = await prisma.redhat_Document_Note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Document_NoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Document_Note.
     * @param {Redhat_Document_NoteUpsertArgs} args - Arguments to update or create a Redhat_Document_Note.
     * @example
     * // Update or create a Redhat_Document_Note
     * const redhat_Document_Note = await prisma.redhat_Document_Note.upsert({
     *   create: {
     *     // ... data to create a Redhat_Document_Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Document_Note we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Document_NoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_NoteUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Document_NoteClient<$Result.GetResult<Prisma.$Redhat_Document_NotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Document_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteCountArgs} args - Arguments to filter Redhat_Document_Notes to count.
     * @example
     * // Count the number of Redhat_Document_Notes
     * const count = await prisma.redhat_Document_Note.count({
     *   where: {
     *     // ... the filter for the Redhat_Document_Notes we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Document_NoteCountArgs>(
      args?: Subset<T, Redhat_Document_NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Document_NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Document_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Document_NoteAggregateArgs>(args: Subset<T, Redhat_Document_NoteAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Document_NoteAggregateType<T>>

    /**
     * Group by Redhat_Document_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Document_NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Document_NoteGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Document_NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Document_NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Document_NoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Document_Note model
   */
  readonly fields: Redhat_Document_NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Document_Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Document_NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat_Document_Note$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document_Note$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Document_Note model
   */ 
  interface Redhat_Document_NoteFieldRefs {
    readonly id: FieldRef<"Redhat_Document_Note", 'String'>
    readonly category: FieldRef<"Redhat_Document_Note", 'String'>
    readonly text: FieldRef<"Redhat_Document_Note", 'String'>
    readonly title: FieldRef<"Redhat_Document_Note", 'String'>
    readonly documentId: FieldRef<"Redhat_Document_Note", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Document_Note findUnique
   */
  export type Redhat_Document_NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Note to fetch.
     */
    where: Redhat_Document_NoteWhereUniqueInput
  }


  /**
   * Redhat_Document_Note findUniqueOrThrow
   */
  export type Redhat_Document_NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Note to fetch.
     */
    where: Redhat_Document_NoteWhereUniqueInput
  }


  /**
   * Redhat_Document_Note findFirst
   */
  export type Redhat_Document_NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Note to fetch.
     */
    where?: Redhat_Document_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_Notes to fetch.
     */
    orderBy?: Redhat_Document_NoteOrderByWithRelationInput | Redhat_Document_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Document_Notes.
     */
    cursor?: Redhat_Document_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Document_Notes.
     */
    distinct?: Redhat_Document_NoteScalarFieldEnum | Redhat_Document_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Note findFirstOrThrow
   */
  export type Redhat_Document_NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Note to fetch.
     */
    where?: Redhat_Document_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_Notes to fetch.
     */
    orderBy?: Redhat_Document_NoteOrderByWithRelationInput | Redhat_Document_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Document_Notes.
     */
    cursor?: Redhat_Document_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Document_Notes.
     */
    distinct?: Redhat_Document_NoteScalarFieldEnum | Redhat_Document_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Note findMany
   */
  export type Redhat_Document_NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Notes to fetch.
     */
    where?: Redhat_Document_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_Notes to fetch.
     */
    orderBy?: Redhat_Document_NoteOrderByWithRelationInput | Redhat_Document_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Document_Notes.
     */
    cursor?: Redhat_Document_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_Notes.
     */
    skip?: number
    distinct?: Redhat_Document_NoteScalarFieldEnum | Redhat_Document_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Note create
   */
  export type Redhat_Document_NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Document_Note.
     */
    data: XOR<Redhat_Document_NoteCreateInput, Redhat_Document_NoteUncheckedCreateInput>
  }


  /**
   * Redhat_Document_Note createMany
   */
  export type Redhat_Document_NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Document_Notes.
     */
    data: Redhat_Document_NoteCreateManyInput | Redhat_Document_NoteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Document_Note update
   */
  export type Redhat_Document_NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Document_Note.
     */
    data: XOR<Redhat_Document_NoteUpdateInput, Redhat_Document_NoteUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Document_Note to update.
     */
    where: Redhat_Document_NoteWhereUniqueInput
  }


  /**
   * Redhat_Document_Note updateMany
   */
  export type Redhat_Document_NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Document_Notes.
     */
    data: XOR<Redhat_Document_NoteUpdateManyMutationInput, Redhat_Document_NoteUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Document_Notes to update
     */
    where?: Redhat_Document_NoteWhereInput
  }


  /**
   * Redhat_Document_Note upsert
   */
  export type Redhat_Document_NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Document_Note to update in case it exists.
     */
    where: Redhat_Document_NoteWhereUniqueInput
    /**
     * In case the Redhat_Document_Note found by the `where` argument doesn't exist, create a new Redhat_Document_Note with this data.
     */
    create: XOR<Redhat_Document_NoteCreateInput, Redhat_Document_NoteUncheckedCreateInput>
    /**
     * In case the Redhat_Document_Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Document_NoteUpdateInput, Redhat_Document_NoteUncheckedUpdateInput>
  }


  /**
   * Redhat_Document_Note delete
   */
  export type Redhat_Document_NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Document_Note to delete.
     */
    where: Redhat_Document_NoteWhereUniqueInput
  }


  /**
   * Redhat_Document_Note deleteMany
   */
  export type Redhat_Document_NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Document_Notes to delete
     */
    where?: Redhat_Document_NoteWhereInput
  }


  /**
   * Redhat_Document_Note.document
   */
  export type Redhat_Document_Note$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Document_Note without action
   */
  export type Redhat_Document_NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Note
     */
    select?: Redhat_Document_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_NoteInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Publisher
   */

  export type AggregateRedhat_Publisher = {
    _count: Redhat_PublisherCountAggregateOutputType | null
    _min: Redhat_PublisherMinAggregateOutputType | null
    _max: Redhat_PublisherMaxAggregateOutputType | null
  }

  export type Redhat_PublisherMinAggregateOutputType = {
    id: string | null
    category: string | null
    contact_details: string | null
    issuing_authority: string | null
    name: string | null
    namespace: string | null
    documentId: string | null
  }

  export type Redhat_PublisherMaxAggregateOutputType = {
    id: string | null
    category: string | null
    contact_details: string | null
    issuing_authority: string | null
    name: string | null
    namespace: string | null
    documentId: string | null
  }

  export type Redhat_PublisherCountAggregateOutputType = {
    id: number
    category: number
    contact_details: number
    issuing_authority: number
    name: number
    namespace: number
    documentId: number
    _all: number
  }


  export type Redhat_PublisherMinAggregateInputType = {
    id?: true
    category?: true
    contact_details?: true
    issuing_authority?: true
    name?: true
    namespace?: true
    documentId?: true
  }

  export type Redhat_PublisherMaxAggregateInputType = {
    id?: true
    category?: true
    contact_details?: true
    issuing_authority?: true
    name?: true
    namespace?: true
    documentId?: true
  }

  export type Redhat_PublisherCountAggregateInputType = {
    id?: true
    category?: true
    contact_details?: true
    issuing_authority?: true
    name?: true
    namespace?: true
    documentId?: true
    _all?: true
  }

  export type Redhat_PublisherAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Publisher to aggregate.
     */
    where?: Redhat_PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Publishers to fetch.
     */
    orderBy?: Redhat_PublisherOrderByWithRelationInput | Redhat_PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Publishers
    **/
    _count?: true | Redhat_PublisherCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_PublisherMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_PublisherMaxAggregateInputType
  }

  export type GetRedhat_PublisherAggregateType<T extends Redhat_PublisherAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Publisher]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Publisher[P]>
      : GetScalarType<T[P], AggregateRedhat_Publisher[P]>
  }




  export type Redhat_PublisherGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_PublisherWhereInput
    orderBy?: Redhat_PublisherOrderByWithAggregationInput | Redhat_PublisherOrderByWithAggregationInput[]
    by: Redhat_PublisherScalarFieldEnum[] | Redhat_PublisherScalarFieldEnum
    having?: Redhat_PublisherScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_PublisherCountAggregateInputType | true
    _min?: Redhat_PublisherMinAggregateInputType
    _max?: Redhat_PublisherMaxAggregateInputType
  }

  export type Redhat_PublisherGroupByOutputType = {
    id: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
    documentId: string | null
    _count: Redhat_PublisherCountAggregateOutputType | null
    _min: Redhat_PublisherMinAggregateOutputType | null
    _max: Redhat_PublisherMaxAggregateOutputType | null
  }

  type GetRedhat_PublisherGroupByPayload<T extends Redhat_PublisherGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_PublisherGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_PublisherGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_PublisherGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_PublisherGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_PublisherSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    contact_details?: boolean
    issuing_authority?: boolean
    name?: boolean
    namespace?: boolean
    documentId?: boolean
    document?: boolean | Redhat_Publisher$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Publisher"]>

  export type Redhat_PublisherSelectScalar = {
    id?: boolean
    category?: boolean
    contact_details?: boolean
    issuing_authority?: boolean
    name?: boolean
    namespace?: boolean
    documentId?: boolean
  }

  export type Redhat_PublisherInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat_Publisher$documentArgs<ExtArgs>
  }


  export type $Redhat_PublisherPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Publisher"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      contact_details: string
      issuing_authority: string
      name: string
      namespace: string
      documentId: string | null
    }, ExtArgs["result"]["redhat_Publisher"]>
    composites: {}
  }


  type Redhat_PublisherGetPayload<S extends boolean | null | undefined | Redhat_PublisherDefaultArgs> = $Result.GetResult<Prisma.$Redhat_PublisherPayload, S>

  type Redhat_PublisherCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_PublisherFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_PublisherCountAggregateInputType | true
    }

  export interface Redhat_PublisherDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Publisher'], meta: { name: 'Redhat_Publisher' } }
    /**
     * Find zero or one Redhat_Publisher that matches the filter.
     * @param {Redhat_PublisherFindUniqueArgs} args - Arguments to find a Redhat_Publisher
     * @example
     * // Get one Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_PublisherFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Publisher that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_PublisherFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Publisher
     * @example
     * // Get one Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_PublisherFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Publisher that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherFindFirstArgs} args - Arguments to find a Redhat_Publisher
     * @example
     * // Get one Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_PublisherFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Publisher that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherFindFirstOrThrowArgs} args - Arguments to find a Redhat_Publisher
     * @example
     * // Get one Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_PublisherFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Publishers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Publishers
     * const redhat_Publishers = await prisma.redhat_Publisher.findMany()
     * 
     * // Get first 10 Redhat_Publishers
     * const redhat_Publishers = await prisma.redhat_Publisher.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_PublisherWithIdOnly = await prisma.redhat_Publisher.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_PublisherFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Publisher.
     * @param {Redhat_PublisherCreateArgs} args - Arguments to create a Redhat_Publisher.
     * @example
     * // Create one Redhat_Publisher
     * const Redhat_Publisher = await prisma.redhat_Publisher.create({
     *   data: {
     *     // ... data to create a Redhat_Publisher
     *   }
     * })
     * 
    **/
    create<T extends Redhat_PublisherCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherCreateArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Publishers.
     *     @param {Redhat_PublisherCreateManyArgs} args - Arguments to create many Redhat_Publishers.
     *     @example
     *     // Create many Redhat_Publishers
     *     const redhat_Publisher = await prisma.redhat_Publisher.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_PublisherCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Publisher.
     * @param {Redhat_PublisherDeleteArgs} args - Arguments to delete one Redhat_Publisher.
     * @example
     * // Delete one Redhat_Publisher
     * const Redhat_Publisher = await prisma.redhat_Publisher.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Publisher
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_PublisherDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Publisher.
     * @param {Redhat_PublisherUpdateArgs} args - Arguments to update one Redhat_Publisher.
     * @example
     * // Update one Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_PublisherUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Publishers.
     * @param {Redhat_PublisherDeleteManyArgs} args - Arguments to filter Redhat_Publishers to delete.
     * @example
     * // Delete a few Redhat_Publishers
     * const { count } = await prisma.redhat_Publisher.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_PublisherDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_PublisherDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Publishers
     * const redhat_Publisher = await prisma.redhat_Publisher.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_PublisherUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Publisher.
     * @param {Redhat_PublisherUpsertArgs} args - Arguments to update or create a Redhat_Publisher.
     * @example
     * // Update or create a Redhat_Publisher
     * const redhat_Publisher = await prisma.redhat_Publisher.upsert({
     *   create: {
     *     // ... data to create a Redhat_Publisher
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Publisher we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_PublisherUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_PublisherUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_PublisherClient<$Result.GetResult<Prisma.$Redhat_PublisherPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Publishers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherCountArgs} args - Arguments to filter Redhat_Publishers to count.
     * @example
     * // Count the number of Redhat_Publishers
     * const count = await prisma.redhat_Publisher.count({
     *   where: {
     *     // ... the filter for the Redhat_Publishers we want to count
     *   }
     * })
    **/
    count<T extends Redhat_PublisherCountArgs>(
      args?: Subset<T, Redhat_PublisherCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_PublisherCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_PublisherAggregateArgs>(args: Subset<T, Redhat_PublisherAggregateArgs>): Prisma.PrismaPromise<GetRedhat_PublisherAggregateType<T>>

    /**
     * Group by Redhat_Publisher.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_PublisherGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_PublisherGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_PublisherGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_PublisherGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_PublisherGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_PublisherGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Publisher model
   */
  readonly fields: Redhat_PublisherFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Publisher.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_PublisherClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat_Publisher$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Publisher$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Publisher model
   */ 
  interface Redhat_PublisherFieldRefs {
    readonly id: FieldRef<"Redhat_Publisher", 'String'>
    readonly category: FieldRef<"Redhat_Publisher", 'String'>
    readonly contact_details: FieldRef<"Redhat_Publisher", 'String'>
    readonly issuing_authority: FieldRef<"Redhat_Publisher", 'String'>
    readonly name: FieldRef<"Redhat_Publisher", 'String'>
    readonly namespace: FieldRef<"Redhat_Publisher", 'String'>
    readonly documentId: FieldRef<"Redhat_Publisher", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Publisher findUnique
   */
  export type Redhat_PublisherFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Publisher to fetch.
     */
    where: Redhat_PublisherWhereUniqueInput
  }


  /**
   * Redhat_Publisher findUniqueOrThrow
   */
  export type Redhat_PublisherFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Publisher to fetch.
     */
    where: Redhat_PublisherWhereUniqueInput
  }


  /**
   * Redhat_Publisher findFirst
   */
  export type Redhat_PublisherFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Publisher to fetch.
     */
    where?: Redhat_PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Publishers to fetch.
     */
    orderBy?: Redhat_PublisherOrderByWithRelationInput | Redhat_PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Publishers.
     */
    cursor?: Redhat_PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Publishers.
     */
    distinct?: Redhat_PublisherScalarFieldEnum | Redhat_PublisherScalarFieldEnum[]
  }


  /**
   * Redhat_Publisher findFirstOrThrow
   */
  export type Redhat_PublisherFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Publisher to fetch.
     */
    where?: Redhat_PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Publishers to fetch.
     */
    orderBy?: Redhat_PublisherOrderByWithRelationInput | Redhat_PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Publishers.
     */
    cursor?: Redhat_PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Publishers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Publishers.
     */
    distinct?: Redhat_PublisherScalarFieldEnum | Redhat_PublisherScalarFieldEnum[]
  }


  /**
   * Redhat_Publisher findMany
   */
  export type Redhat_PublisherFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Publishers to fetch.
     */
    where?: Redhat_PublisherWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Publishers to fetch.
     */
    orderBy?: Redhat_PublisherOrderByWithRelationInput | Redhat_PublisherOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Publishers.
     */
    cursor?: Redhat_PublisherWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Publishers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Publishers.
     */
    skip?: number
    distinct?: Redhat_PublisherScalarFieldEnum | Redhat_PublisherScalarFieldEnum[]
  }


  /**
   * Redhat_Publisher create
   */
  export type Redhat_PublisherCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Publisher.
     */
    data: XOR<Redhat_PublisherCreateInput, Redhat_PublisherUncheckedCreateInput>
  }


  /**
   * Redhat_Publisher createMany
   */
  export type Redhat_PublisherCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Publishers.
     */
    data: Redhat_PublisherCreateManyInput | Redhat_PublisherCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Publisher update
   */
  export type Redhat_PublisherUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Publisher.
     */
    data: XOR<Redhat_PublisherUpdateInput, Redhat_PublisherUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Publisher to update.
     */
    where: Redhat_PublisherWhereUniqueInput
  }


  /**
   * Redhat_Publisher updateMany
   */
  export type Redhat_PublisherUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Publishers.
     */
    data: XOR<Redhat_PublisherUpdateManyMutationInput, Redhat_PublisherUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Publishers to update
     */
    where?: Redhat_PublisherWhereInput
  }


  /**
   * Redhat_Publisher upsert
   */
  export type Redhat_PublisherUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Publisher to update in case it exists.
     */
    where: Redhat_PublisherWhereUniqueInput
    /**
     * In case the Redhat_Publisher found by the `where` argument doesn't exist, create a new Redhat_Publisher with this data.
     */
    create: XOR<Redhat_PublisherCreateInput, Redhat_PublisherUncheckedCreateInput>
    /**
     * In case the Redhat_Publisher was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_PublisherUpdateInput, Redhat_PublisherUncheckedUpdateInput>
  }


  /**
   * Redhat_Publisher delete
   */
  export type Redhat_PublisherDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Publisher to delete.
     */
    where: Redhat_PublisherWhereUniqueInput
  }


  /**
   * Redhat_Publisher deleteMany
   */
  export type Redhat_PublisherDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Publishers to delete
     */
    where?: Redhat_PublisherWhereInput
  }


  /**
   * Redhat_Publisher.document
   */
  export type Redhat_Publisher$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Publisher without action
   */
  export type Redhat_PublisherDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Publisher
     */
    select?: Redhat_PublisherSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_PublisherInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Document_Reference
   */

  export type AggregateRedhat_Document_Reference = {
    _count: Redhat_Document_ReferenceCountAggregateOutputType | null
    _min: Redhat_Document_ReferenceMinAggregateOutputType | null
    _max: Redhat_Document_ReferenceMaxAggregateOutputType | null
  }

  export type Redhat_Document_ReferenceMinAggregateOutputType = {
    id: string | null
    category: string | null
    summary: string | null
    url: string | null
    documentId: string | null
  }

  export type Redhat_Document_ReferenceMaxAggregateOutputType = {
    id: string | null
    category: string | null
    summary: string | null
    url: string | null
    documentId: string | null
  }

  export type Redhat_Document_ReferenceCountAggregateOutputType = {
    id: number
    category: number
    summary: number
    url: number
    documentId: number
    _all: number
  }


  export type Redhat_Document_ReferenceMinAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    documentId?: true
  }

  export type Redhat_Document_ReferenceMaxAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    documentId?: true
  }

  export type Redhat_Document_ReferenceCountAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    documentId?: true
    _all?: true
  }

  export type Redhat_Document_ReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Document_Reference to aggregate.
     */
    where?: Redhat_Document_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_References to fetch.
     */
    orderBy?: Redhat_Document_ReferenceOrderByWithRelationInput | Redhat_Document_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Document_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Document_References
    **/
    _count?: true | Redhat_Document_ReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Document_ReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Document_ReferenceMaxAggregateInputType
  }

  export type GetRedhat_Document_ReferenceAggregateType<T extends Redhat_Document_ReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Document_Reference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Document_Reference[P]>
      : GetScalarType<T[P], AggregateRedhat_Document_Reference[P]>
  }




  export type Redhat_Document_ReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Document_ReferenceWhereInput
    orderBy?: Redhat_Document_ReferenceOrderByWithAggregationInput | Redhat_Document_ReferenceOrderByWithAggregationInput[]
    by: Redhat_Document_ReferenceScalarFieldEnum[] | Redhat_Document_ReferenceScalarFieldEnum
    having?: Redhat_Document_ReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Document_ReferenceCountAggregateInputType | true
    _min?: Redhat_Document_ReferenceMinAggregateInputType
    _max?: Redhat_Document_ReferenceMaxAggregateInputType
  }

  export type Redhat_Document_ReferenceGroupByOutputType = {
    id: string
    category: string
    summary: string
    url: string
    documentId: string | null
    _count: Redhat_Document_ReferenceCountAggregateOutputType | null
    _min: Redhat_Document_ReferenceMinAggregateOutputType | null
    _max: Redhat_Document_ReferenceMaxAggregateOutputType | null
  }

  type GetRedhat_Document_ReferenceGroupByPayload<T extends Redhat_Document_ReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Document_ReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Document_ReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Document_ReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Document_ReferenceGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Document_ReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    summary?: boolean
    url?: boolean
    documentId?: boolean
    document?: boolean | Redhat_Document_Reference$documentArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Document_Reference"]>

  export type Redhat_Document_ReferenceSelectScalar = {
    id?: boolean
    category?: boolean
    summary?: boolean
    url?: boolean
    documentId?: boolean
  }

  export type Redhat_Document_ReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | Redhat_Document_Reference$documentArgs<ExtArgs>
  }


  export type $Redhat_Document_ReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Document_Reference"
    objects: {
      document: Prisma.$Redhat_DocumentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      summary: string
      url: string
      documentId: string | null
    }, ExtArgs["result"]["redhat_Document_Reference"]>
    composites: {}
  }


  type Redhat_Document_ReferenceGetPayload<S extends boolean | null | undefined | Redhat_Document_ReferenceDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Document_ReferencePayload, S>

  type Redhat_Document_ReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Document_ReferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Document_ReferenceCountAggregateInputType | true
    }

  export interface Redhat_Document_ReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Document_Reference'], meta: { name: 'Redhat_Document_Reference' } }
    /**
     * Find zero or one Redhat_Document_Reference that matches the filter.
     * @param {Redhat_Document_ReferenceFindUniqueArgs} args - Arguments to find a Redhat_Document_Reference
     * @example
     * // Get one Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Document_ReferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Document_Reference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Document_ReferenceFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Document_Reference
     * @example
     * // Get one Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Document_ReferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Document_Reference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceFindFirstArgs} args - Arguments to find a Redhat_Document_Reference
     * @example
     * // Get one Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Document_ReferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Document_Reference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceFindFirstOrThrowArgs} args - Arguments to find a Redhat_Document_Reference
     * @example
     * // Get one Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Document_ReferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Document_References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Document_References
     * const redhat_Document_References = await prisma.redhat_Document_Reference.findMany()
     * 
     * // Get first 10 Redhat_Document_References
     * const redhat_Document_References = await prisma.redhat_Document_Reference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Document_ReferenceWithIdOnly = await prisma.redhat_Document_Reference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Document_ReferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Document_Reference.
     * @param {Redhat_Document_ReferenceCreateArgs} args - Arguments to create a Redhat_Document_Reference.
     * @example
     * // Create one Redhat_Document_Reference
     * const Redhat_Document_Reference = await prisma.redhat_Document_Reference.create({
     *   data: {
     *     // ... data to create a Redhat_Document_Reference
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Document_ReferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Document_References.
     *     @param {Redhat_Document_ReferenceCreateManyArgs} args - Arguments to create many Redhat_Document_References.
     *     @example
     *     // Create many Redhat_Document_References
     *     const redhat_Document_Reference = await prisma.redhat_Document_Reference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Document_ReferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Document_Reference.
     * @param {Redhat_Document_ReferenceDeleteArgs} args - Arguments to delete one Redhat_Document_Reference.
     * @example
     * // Delete one Redhat_Document_Reference
     * const Redhat_Document_Reference = await prisma.redhat_Document_Reference.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Document_Reference
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Document_ReferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Document_Reference.
     * @param {Redhat_Document_ReferenceUpdateArgs} args - Arguments to update one Redhat_Document_Reference.
     * @example
     * // Update one Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Document_ReferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Document_References.
     * @param {Redhat_Document_ReferenceDeleteManyArgs} args - Arguments to filter Redhat_Document_References to delete.
     * @example
     * // Delete a few Redhat_Document_References
     * const { count } = await prisma.redhat_Document_Reference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Document_ReferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Document_ReferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Document_References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Document_References
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Document_ReferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Document_Reference.
     * @param {Redhat_Document_ReferenceUpsertArgs} args - Arguments to update or create a Redhat_Document_Reference.
     * @example
     * // Update or create a Redhat_Document_Reference
     * const redhat_Document_Reference = await prisma.redhat_Document_Reference.upsert({
     *   create: {
     *     // ... data to create a Redhat_Document_Reference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Document_Reference we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Document_ReferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Document_ReferenceUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Document_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Document_ReferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Document_References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceCountArgs} args - Arguments to filter Redhat_Document_References to count.
     * @example
     * // Count the number of Redhat_Document_References
     * const count = await prisma.redhat_Document_Reference.count({
     *   where: {
     *     // ... the filter for the Redhat_Document_References we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Document_ReferenceCountArgs>(
      args?: Subset<T, Redhat_Document_ReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Document_ReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Document_Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Document_ReferenceAggregateArgs>(args: Subset<T, Redhat_Document_ReferenceAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Document_ReferenceAggregateType<T>>

    /**
     * Group by Redhat_Document_Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Document_ReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Document_ReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Document_ReferenceGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Document_ReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Document_ReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Document_ReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Document_Reference model
   */
  readonly fields: Redhat_Document_ReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Document_Reference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Document_ReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    document<T extends Redhat_Document_Reference$documentArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Document_Reference$documentArgs<ExtArgs>>): Prisma__Redhat_DocumentClient<$Result.GetResult<Prisma.$Redhat_DocumentPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Document_Reference model
   */ 
  interface Redhat_Document_ReferenceFieldRefs {
    readonly id: FieldRef<"Redhat_Document_Reference", 'String'>
    readonly category: FieldRef<"Redhat_Document_Reference", 'String'>
    readonly summary: FieldRef<"Redhat_Document_Reference", 'String'>
    readonly url: FieldRef<"Redhat_Document_Reference", 'String'>
    readonly documentId: FieldRef<"Redhat_Document_Reference", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Document_Reference findUnique
   */
  export type Redhat_Document_ReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Reference to fetch.
     */
    where: Redhat_Document_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Document_Reference findUniqueOrThrow
   */
  export type Redhat_Document_ReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Reference to fetch.
     */
    where: Redhat_Document_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Document_Reference findFirst
   */
  export type Redhat_Document_ReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Reference to fetch.
     */
    where?: Redhat_Document_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_References to fetch.
     */
    orderBy?: Redhat_Document_ReferenceOrderByWithRelationInput | Redhat_Document_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Document_References.
     */
    cursor?: Redhat_Document_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Document_References.
     */
    distinct?: Redhat_Document_ReferenceScalarFieldEnum | Redhat_Document_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Reference findFirstOrThrow
   */
  export type Redhat_Document_ReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_Reference to fetch.
     */
    where?: Redhat_Document_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_References to fetch.
     */
    orderBy?: Redhat_Document_ReferenceOrderByWithRelationInput | Redhat_Document_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Document_References.
     */
    cursor?: Redhat_Document_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Document_References.
     */
    distinct?: Redhat_Document_ReferenceScalarFieldEnum | Redhat_Document_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Reference findMany
   */
  export type Redhat_Document_ReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Document_References to fetch.
     */
    where?: Redhat_Document_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Document_References to fetch.
     */
    orderBy?: Redhat_Document_ReferenceOrderByWithRelationInput | Redhat_Document_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Document_References.
     */
    cursor?: Redhat_Document_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Document_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Document_References.
     */
    skip?: number
    distinct?: Redhat_Document_ReferenceScalarFieldEnum | Redhat_Document_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Document_Reference create
   */
  export type Redhat_Document_ReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Document_Reference.
     */
    data: XOR<Redhat_Document_ReferenceCreateInput, Redhat_Document_ReferenceUncheckedCreateInput>
  }


  /**
   * Redhat_Document_Reference createMany
   */
  export type Redhat_Document_ReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Document_References.
     */
    data: Redhat_Document_ReferenceCreateManyInput | Redhat_Document_ReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Document_Reference update
   */
  export type Redhat_Document_ReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Document_Reference.
     */
    data: XOR<Redhat_Document_ReferenceUpdateInput, Redhat_Document_ReferenceUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Document_Reference to update.
     */
    where: Redhat_Document_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Document_Reference updateMany
   */
  export type Redhat_Document_ReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Document_References.
     */
    data: XOR<Redhat_Document_ReferenceUpdateManyMutationInput, Redhat_Document_ReferenceUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Document_References to update
     */
    where?: Redhat_Document_ReferenceWhereInput
  }


  /**
   * Redhat_Document_Reference upsert
   */
  export type Redhat_Document_ReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Document_Reference to update in case it exists.
     */
    where: Redhat_Document_ReferenceWhereUniqueInput
    /**
     * In case the Redhat_Document_Reference found by the `where` argument doesn't exist, create a new Redhat_Document_Reference with this data.
     */
    create: XOR<Redhat_Document_ReferenceCreateInput, Redhat_Document_ReferenceUncheckedCreateInput>
    /**
     * In case the Redhat_Document_Reference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Document_ReferenceUpdateInput, Redhat_Document_ReferenceUncheckedUpdateInput>
  }


  /**
   * Redhat_Document_Reference delete
   */
  export type Redhat_Document_ReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Document_Reference to delete.
     */
    where: Redhat_Document_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Document_Reference deleteMany
   */
  export type Redhat_Document_ReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Document_References to delete
     */
    where?: Redhat_Document_ReferenceWhereInput
  }


  /**
   * Redhat_Document_Reference.document
   */
  export type Redhat_Document_Reference$documentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document
     */
    select?: Redhat_DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_DocumentInclude<ExtArgs> | null
    where?: Redhat_DocumentWhereInput
  }


  /**
   * Redhat_Document_Reference without action
   */
  export type Redhat_Document_ReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Document_Reference
     */
    select?: Redhat_Document_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Document_ReferenceInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability
   */

  export type AggregateRedhat_Vulnerability = {
    _count: Redhat_VulnerabilityCountAggregateOutputType | null
    _min: Redhat_VulnerabilityMinAggregateOutputType | null
    _max: Redhat_VulnerabilityMaxAggregateOutputType | null
  }

  export type Redhat_VulnerabilityMinAggregateOutputType = {
    id: string | null
    cve: string | null
    discovery_date: string | null
    release_date: string | null
    title: string | null
    redhatId: string | null
  }

  export type Redhat_VulnerabilityMaxAggregateOutputType = {
    id: string | null
    cve: string | null
    discovery_date: string | null
    release_date: string | null
    title: string | null
    redhatId: string | null
  }

  export type Redhat_VulnerabilityCountAggregateOutputType = {
    id: number
    cve: number
    discovery_date: number
    release_date: number
    title: number
    redhatId: number
    _all: number
  }


  export type Redhat_VulnerabilityMinAggregateInputType = {
    id?: true
    cve?: true
    discovery_date?: true
    release_date?: true
    title?: true
    redhatId?: true
  }

  export type Redhat_VulnerabilityMaxAggregateInputType = {
    id?: true
    cve?: true
    discovery_date?: true
    release_date?: true
    title?: true
    redhatId?: true
  }

  export type Redhat_VulnerabilityCountAggregateInputType = {
    id?: true
    cve?: true
    discovery_date?: true
    release_date?: true
    title?: true
    redhatId?: true
    _all?: true
  }

  export type Redhat_VulnerabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability to aggregate.
     */
    where?: Redhat_VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerabilities to fetch.
     */
    orderBy?: Redhat_VulnerabilityOrderByWithRelationInput | Redhat_VulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerabilities
    **/
    _count?: true | Redhat_VulnerabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_VulnerabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_VulnerabilityMaxAggregateInputType
  }

  export type GetRedhat_VulnerabilityAggregateType<T extends Redhat_VulnerabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability[P]>
  }




  export type Redhat_VulnerabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_VulnerabilityWhereInput
    orderBy?: Redhat_VulnerabilityOrderByWithAggregationInput | Redhat_VulnerabilityOrderByWithAggregationInput[]
    by: Redhat_VulnerabilityScalarFieldEnum[] | Redhat_VulnerabilityScalarFieldEnum
    having?: Redhat_VulnerabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_VulnerabilityCountAggregateInputType | true
    _min?: Redhat_VulnerabilityMinAggregateInputType
    _max?: Redhat_VulnerabilityMaxAggregateInputType
  }

  export type Redhat_VulnerabilityGroupByOutputType = {
    id: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    _count: Redhat_VulnerabilityCountAggregateOutputType | null
    _min: Redhat_VulnerabilityMinAggregateOutputType | null
    _max: Redhat_VulnerabilityMaxAggregateOutputType | null
  }

  type GetRedhat_VulnerabilityGroupByPayload<T extends Redhat_VulnerabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_VulnerabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_VulnerabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_VulnerabilityGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_VulnerabilityGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_VulnerabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cve?: boolean
    discovery_date?: boolean
    release_date?: boolean
    title?: boolean
    redhatId?: boolean
    ids?: boolean | Redhat_Vulnerability$idsArgs<ExtArgs>
    notes?: boolean | Redhat_Vulnerability$notesArgs<ExtArgs>
    product_status?: boolean | Redhat_Vulnerability$product_statusArgs<ExtArgs>
    references?: boolean | Redhat_Vulnerability$referencesArgs<ExtArgs>
    remediations?: boolean | Redhat_Vulnerability$remediationsArgs<ExtArgs>
    scores?: boolean | Redhat_Vulnerability$scoresArgs<ExtArgs>
    threats?: boolean | Redhat_Vulnerability$threatsArgs<ExtArgs>
    cwe?: boolean | Redhat_Vulnerability$cweArgs<ExtArgs>
    redhat?: boolean | Redhat_Vulnerability$redhatArgs<ExtArgs>
    _count?: boolean | Redhat_VulnerabilityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability"]>

  export type Redhat_VulnerabilitySelectScalar = {
    id?: boolean
    cve?: boolean
    discovery_date?: boolean
    release_date?: boolean
    title?: boolean
    redhatId?: boolean
  }

  export type Redhat_VulnerabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ids?: boolean | Redhat_Vulnerability$idsArgs<ExtArgs>
    notes?: boolean | Redhat_Vulnerability$notesArgs<ExtArgs>
    product_status?: boolean | Redhat_Vulnerability$product_statusArgs<ExtArgs>
    references?: boolean | Redhat_Vulnerability$referencesArgs<ExtArgs>
    remediations?: boolean | Redhat_Vulnerability$remediationsArgs<ExtArgs>
    scores?: boolean | Redhat_Vulnerability$scoresArgs<ExtArgs>
    threats?: boolean | Redhat_Vulnerability$threatsArgs<ExtArgs>
    cwe?: boolean | Redhat_Vulnerability$cweArgs<ExtArgs>
    redhat?: boolean | Redhat_Vulnerability$redhatArgs<ExtArgs>
    _count?: boolean | Redhat_VulnerabilityCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Redhat_VulnerabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability"
    objects: {
      ids: Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>[]
      notes: Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>[]
      product_status: Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs> | null
      references: Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>[]
      remediations: Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>[]
      scores: Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>[]
      threats: Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>[]
      cwe: Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs> | null
      redhat: Prisma.$RedhatPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cve: string
      discovery_date: string
      release_date: string
      title: string
      redhatId: string
    }, ExtArgs["result"]["redhat_Vulnerability"]>
    composites: {}
  }


  type Redhat_VulnerabilityGetPayload<S extends boolean | null | undefined | Redhat_VulnerabilityDefaultArgs> = $Result.GetResult<Prisma.$Redhat_VulnerabilityPayload, S>

  type Redhat_VulnerabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_VulnerabilityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_VulnerabilityCountAggregateInputType | true
    }

  export interface Redhat_VulnerabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability'], meta: { name: 'Redhat_Vulnerability' } }
    /**
     * Find zero or one Redhat_Vulnerability that matches the filter.
     * @param {Redhat_VulnerabilityFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability
     * @example
     * // Get one Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_VulnerabilityFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_VulnerabilityFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability
     * @example
     * // Get one Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_VulnerabilityFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityFindFirstArgs} args - Arguments to find a Redhat_Vulnerability
     * @example
     * // Get one Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_VulnerabilityFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability
     * @example
     * // Get one Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_VulnerabilityFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerabilities
     * const redhat_Vulnerabilities = await prisma.redhat_Vulnerability.findMany()
     * 
     * // Get first 10 Redhat_Vulnerabilities
     * const redhat_Vulnerabilities = await prisma.redhat_Vulnerability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_VulnerabilityWithIdOnly = await prisma.redhat_Vulnerability.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_VulnerabilityFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability.
     * @param {Redhat_VulnerabilityCreateArgs} args - Arguments to create a Redhat_Vulnerability.
     * @example
     * // Create one Redhat_Vulnerability
     * const Redhat_Vulnerability = await prisma.redhat_Vulnerability.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability
     *   }
     * })
     * 
    **/
    create<T extends Redhat_VulnerabilityCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityCreateArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerabilities.
     *     @param {Redhat_VulnerabilityCreateManyArgs} args - Arguments to create many Redhat_Vulnerabilities.
     *     @example
     *     // Create many Redhat_Vulnerabilities
     *     const redhat_Vulnerability = await prisma.redhat_Vulnerability.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_VulnerabilityCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability.
     * @param {Redhat_VulnerabilityDeleteArgs} args - Arguments to delete one Redhat_Vulnerability.
     * @example
     * // Delete one Redhat_Vulnerability
     * const Redhat_Vulnerability = await prisma.redhat_Vulnerability.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_VulnerabilityDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability.
     * @param {Redhat_VulnerabilityUpdateArgs} args - Arguments to update one Redhat_Vulnerability.
     * @example
     * // Update one Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_VulnerabilityUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerabilities.
     * @param {Redhat_VulnerabilityDeleteManyArgs} args - Arguments to filter Redhat_Vulnerabilities to delete.
     * @example
     * // Delete a few Redhat_Vulnerabilities
     * const { count } = await prisma.redhat_Vulnerability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_VulnerabilityDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_VulnerabilityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerabilities
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_VulnerabilityUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability.
     * @param {Redhat_VulnerabilityUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability.
     * @example
     * // Update or create a Redhat_Vulnerability
     * const redhat_Vulnerability = await prisma.redhat_Vulnerability.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_VulnerabilityUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_VulnerabilityUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityCountArgs} args - Arguments to filter Redhat_Vulnerabilities to count.
     * @example
     * // Count the number of Redhat_Vulnerabilities
     * const count = await prisma.redhat_Vulnerability.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerabilities we want to count
     *   }
     * })
    **/
    count<T extends Redhat_VulnerabilityCountArgs>(
      args?: Subset<T, Redhat_VulnerabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_VulnerabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_VulnerabilityAggregateArgs>(args: Subset<T, Redhat_VulnerabilityAggregateArgs>): Prisma.PrismaPromise<GetRedhat_VulnerabilityAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_VulnerabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_VulnerabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_VulnerabilityGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_VulnerabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_VulnerabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_VulnerabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability model
   */
  readonly fields: Redhat_VulnerabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_VulnerabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    ids<T extends Redhat_Vulnerability$idsArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$idsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findMany'> | Null>;

    notes<T extends Redhat_Vulnerability$notesArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findMany'> | Null>;

    product_status<T extends Redhat_Vulnerability$product_statusArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$product_statusArgs<ExtArgs>>): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    references<T extends Redhat_Vulnerability$referencesArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findMany'> | Null>;

    remediations<T extends Redhat_Vulnerability$remediationsArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$remediationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findMany'> | Null>;

    scores<T extends Redhat_Vulnerability$scoresArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$scoresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findMany'> | Null>;

    threats<T extends Redhat_Vulnerability$threatsArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$threatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findMany'> | Null>;

    cwe<T extends Redhat_Vulnerability$cweArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$cweArgs<ExtArgs>>): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    redhat<T extends Redhat_Vulnerability$redhatArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability$redhatArgs<ExtArgs>>): Prisma__RedhatClient<$Result.GetResult<Prisma.$RedhatPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability model
   */ 
  interface Redhat_VulnerabilityFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability", 'String'>
    readonly cve: FieldRef<"Redhat_Vulnerability", 'String'>
    readonly discovery_date: FieldRef<"Redhat_Vulnerability", 'String'>
    readonly release_date: FieldRef<"Redhat_Vulnerability", 'String'>
    readonly title: FieldRef<"Redhat_Vulnerability", 'String'>
    readonly redhatId: FieldRef<"Redhat_Vulnerability", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability findUnique
   */
  export type Redhat_VulnerabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability to fetch.
     */
    where: Redhat_VulnerabilityWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability findUniqueOrThrow
   */
  export type Redhat_VulnerabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability to fetch.
     */
    where: Redhat_VulnerabilityWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability findFirst
   */
  export type Redhat_VulnerabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability to fetch.
     */
    where?: Redhat_VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerabilities to fetch.
     */
    orderBy?: Redhat_VulnerabilityOrderByWithRelationInput | Redhat_VulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerabilities.
     */
    cursor?: Redhat_VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerabilities.
     */
    distinct?: Redhat_VulnerabilityScalarFieldEnum | Redhat_VulnerabilityScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability findFirstOrThrow
   */
  export type Redhat_VulnerabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability to fetch.
     */
    where?: Redhat_VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerabilities to fetch.
     */
    orderBy?: Redhat_VulnerabilityOrderByWithRelationInput | Redhat_VulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerabilities.
     */
    cursor?: Redhat_VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerabilities.
     */
    distinct?: Redhat_VulnerabilityScalarFieldEnum | Redhat_VulnerabilityScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability findMany
   */
  export type Redhat_VulnerabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerabilities to fetch.
     */
    where?: Redhat_VulnerabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerabilities to fetch.
     */
    orderBy?: Redhat_VulnerabilityOrderByWithRelationInput | Redhat_VulnerabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerabilities.
     */
    cursor?: Redhat_VulnerabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerabilities.
     */
    skip?: number
    distinct?: Redhat_VulnerabilityScalarFieldEnum | Redhat_VulnerabilityScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability create
   */
  export type Redhat_VulnerabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability.
     */
    data: XOR<Redhat_VulnerabilityCreateInput, Redhat_VulnerabilityUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability createMany
   */
  export type Redhat_VulnerabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerabilities.
     */
    data: Redhat_VulnerabilityCreateManyInput | Redhat_VulnerabilityCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability update
   */
  export type Redhat_VulnerabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability.
     */
    data: XOR<Redhat_VulnerabilityUpdateInput, Redhat_VulnerabilityUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability to update.
     */
    where: Redhat_VulnerabilityWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability updateMany
   */
  export type Redhat_VulnerabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerabilities.
     */
    data: XOR<Redhat_VulnerabilityUpdateManyMutationInput, Redhat_VulnerabilityUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerabilities to update
     */
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability upsert
   */
  export type Redhat_VulnerabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability to update in case it exists.
     */
    where: Redhat_VulnerabilityWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability found by the `where` argument doesn't exist, create a new Redhat_Vulnerability with this data.
     */
    create: XOR<Redhat_VulnerabilityCreateInput, Redhat_VulnerabilityUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_VulnerabilityUpdateInput, Redhat_VulnerabilityUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability delete
   */
  export type Redhat_VulnerabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability to delete.
     */
    where: Redhat_VulnerabilityWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability deleteMany
   */
  export type Redhat_VulnerabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerabilities to delete
     */
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability.ids
   */
  export type Redhat_Vulnerability$idsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_IdWhereInput
    orderBy?: Redhat_Vulnerability_IdOrderByWithRelationInput | Redhat_Vulnerability_IdOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_IdWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_IdScalarFieldEnum | Redhat_Vulnerability_IdScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.notes
   */
  export type Redhat_Vulnerability$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_NoteWhereInput
    orderBy?: Redhat_Vulnerability_NoteOrderByWithRelationInput | Redhat_Vulnerability_NoteOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_NoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_NoteScalarFieldEnum | Redhat_Vulnerability_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.product_status
   */
  export type Redhat_Vulnerability$product_statusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_ProductStatusWhereInput
  }


  /**
   * Redhat_Vulnerability.references
   */
  export type Redhat_Vulnerability$referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_ReferenceWhereInput
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithRelationInput | Redhat_Vulnerability_ReferenceOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_ReferenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_ReferenceScalarFieldEnum | Redhat_Vulnerability_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.remediations
   */
  export type Redhat_Vulnerability$remediationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_RemediationWhereInput
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithRelationInput | Redhat_Vulnerability_RemediationOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_RemediationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_RemediationScalarFieldEnum | Redhat_Vulnerability_RemediationScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.scores
   */
  export type Redhat_Vulnerability$scoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_ScoreWhereInput
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithRelationInput | Redhat_Vulnerability_ScoreOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_ScoreWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_ScoreScalarFieldEnum | Redhat_Vulnerability_ScoreScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.threats
   */
  export type Redhat_Vulnerability$threatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_ThreatWhereInput
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithRelationInput | Redhat_Vulnerability_ThreatOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_ThreatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_ThreatScalarFieldEnum | Redhat_Vulnerability_ThreatScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability.cwe
   */
  export type Redhat_Vulnerability$cweArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_CweWhereInput
  }


  /**
   * Redhat_Vulnerability.redhat
   */
  export type Redhat_Vulnerability$redhatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat
     */
    select?: RedhatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: RedhatInclude<ExtArgs> | null
    where?: RedhatWhereInput
  }


  /**
   * Redhat_Vulnerability without action
   */
  export type Redhat_VulnerabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Id
   */

  export type AggregateRedhat_Vulnerability_Id = {
    _count: Redhat_Vulnerability_IdCountAggregateOutputType | null
    _min: Redhat_Vulnerability_IdMinAggregateOutputType | null
    _max: Redhat_Vulnerability_IdMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_IdMinAggregateOutputType = {
    id: string | null
    system_name: string | null
    text: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_IdMaxAggregateOutputType = {
    id: string | null
    system_name: string | null
    text: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_IdCountAggregateOutputType = {
    id: number
    system_name: number
    text: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_IdMinAggregateInputType = {
    id?: true
    system_name?: true
    text?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_IdMaxAggregateInputType = {
    id?: true
    system_name?: true
    text?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_IdCountAggregateInputType = {
    id?: true
    system_name?: true
    text?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_IdAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Id to aggregate.
     */
    where?: Redhat_Vulnerability_IdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Ids to fetch.
     */
    orderBy?: Redhat_Vulnerability_IdOrderByWithRelationInput | Redhat_Vulnerability_IdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_IdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Ids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Ids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Ids
    **/
    _count?: true | Redhat_Vulnerability_IdCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_IdMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_IdMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_IdAggregateType<T extends Redhat_Vulnerability_IdAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Id]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Id[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Id[P]>
  }




  export type Redhat_Vulnerability_IdGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_IdWhereInput
    orderBy?: Redhat_Vulnerability_IdOrderByWithAggregationInput | Redhat_Vulnerability_IdOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_IdScalarFieldEnum[] | Redhat_Vulnerability_IdScalarFieldEnum
    having?: Redhat_Vulnerability_IdScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_IdCountAggregateInputType | true
    _min?: Redhat_Vulnerability_IdMinAggregateInputType
    _max?: Redhat_Vulnerability_IdMaxAggregateInputType
  }

  export type Redhat_Vulnerability_IdGroupByOutputType = {
    id: string
    system_name: string
    text: string
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_IdCountAggregateOutputType | null
    _min: Redhat_Vulnerability_IdMinAggregateOutputType | null
    _max: Redhat_Vulnerability_IdMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_IdGroupByPayload<T extends Redhat_Vulnerability_IdGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_IdGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_IdGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_IdGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_IdGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_IdSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    system_name?: boolean
    text?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Id$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Id"]>

  export type Redhat_Vulnerability_IdSelectScalar = {
    id?: boolean
    system_name?: boolean
    text?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_IdInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Id$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_IdPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Id"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      system_name: string
      text: string
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_Id"]>
    composites: {}
  }


  type Redhat_Vulnerability_IdGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_IdDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload, S>

  type Redhat_Vulnerability_IdCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_IdFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_IdCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_IdDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Id'], meta: { name: 'Redhat_Vulnerability_Id' } }
    /**
     * Find zero or one Redhat_Vulnerability_Id that matches the filter.
     * @param {Redhat_Vulnerability_IdFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Id
     * @example
     * // Get one Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_IdFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Id that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_IdFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Id
     * @example
     * // Get one Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_IdFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Id that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Id
     * @example
     * // Get one Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_IdFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Id that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Id
     * @example
     * // Get one Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_IdFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Ids that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Ids
     * const redhat_Vulnerability_Ids = await prisma.redhat_Vulnerability_Id.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Ids
     * const redhat_Vulnerability_Ids = await prisma.redhat_Vulnerability_Id.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_IdWithIdOnly = await prisma.redhat_Vulnerability_Id.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_IdFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Id.
     * @param {Redhat_Vulnerability_IdCreateArgs} args - Arguments to create a Redhat_Vulnerability_Id.
     * @example
     * // Create one Redhat_Vulnerability_Id
     * const Redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Id
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_IdCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Ids.
     *     @param {Redhat_Vulnerability_IdCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Ids.
     *     @example
     *     // Create many Redhat_Vulnerability_Ids
     *     const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_IdCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Id.
     * @param {Redhat_Vulnerability_IdDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Id.
     * @example
     * // Delete one Redhat_Vulnerability_Id
     * const Redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Id
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_IdDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Id.
     * @param {Redhat_Vulnerability_IdUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Id.
     * @example
     * // Update one Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_IdUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Ids.
     * @param {Redhat_Vulnerability_IdDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Ids to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Ids
     * const { count } = await prisma.redhat_Vulnerability_Id.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_IdDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_IdDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Ids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Ids
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_IdUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Id.
     * @param {Redhat_Vulnerability_IdUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Id.
     * @example
     * // Update or create a Redhat_Vulnerability_Id
     * const redhat_Vulnerability_Id = await prisma.redhat_Vulnerability_Id.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Id
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Id we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_IdUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_IdUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_IdClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_IdPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Ids.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdCountArgs} args - Arguments to filter Redhat_Vulnerability_Ids to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Ids
     * const count = await prisma.redhat_Vulnerability_Id.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Ids we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_IdCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_IdCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_IdCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Id.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_IdAggregateArgs>(args: Subset<T, Redhat_Vulnerability_IdAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_IdAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Id.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_IdGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_IdGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_IdGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_IdGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_IdGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_IdGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Id model
   */
  readonly fields: Redhat_Vulnerability_IdFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Id.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_IdClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Id$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Id$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Id model
   */ 
  interface Redhat_Vulnerability_IdFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Id", 'String'>
    readonly system_name: FieldRef<"Redhat_Vulnerability_Id", 'String'>
    readonly text: FieldRef<"Redhat_Vulnerability_Id", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Id", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Id findUnique
   */
  export type Redhat_Vulnerability_IdFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Id to fetch.
     */
    where: Redhat_Vulnerability_IdWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Id findUniqueOrThrow
   */
  export type Redhat_Vulnerability_IdFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Id to fetch.
     */
    where: Redhat_Vulnerability_IdWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Id findFirst
   */
  export type Redhat_Vulnerability_IdFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Id to fetch.
     */
    where?: Redhat_Vulnerability_IdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Ids to fetch.
     */
    orderBy?: Redhat_Vulnerability_IdOrderByWithRelationInput | Redhat_Vulnerability_IdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Ids.
     */
    cursor?: Redhat_Vulnerability_IdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Ids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Ids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Ids.
     */
    distinct?: Redhat_Vulnerability_IdScalarFieldEnum | Redhat_Vulnerability_IdScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Id findFirstOrThrow
   */
  export type Redhat_Vulnerability_IdFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Id to fetch.
     */
    where?: Redhat_Vulnerability_IdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Ids to fetch.
     */
    orderBy?: Redhat_Vulnerability_IdOrderByWithRelationInput | Redhat_Vulnerability_IdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Ids.
     */
    cursor?: Redhat_Vulnerability_IdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Ids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Ids.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Ids.
     */
    distinct?: Redhat_Vulnerability_IdScalarFieldEnum | Redhat_Vulnerability_IdScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Id findMany
   */
  export type Redhat_Vulnerability_IdFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Ids to fetch.
     */
    where?: Redhat_Vulnerability_IdWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Ids to fetch.
     */
    orderBy?: Redhat_Vulnerability_IdOrderByWithRelationInput | Redhat_Vulnerability_IdOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Ids.
     */
    cursor?: Redhat_Vulnerability_IdWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Ids from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Ids.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_IdScalarFieldEnum | Redhat_Vulnerability_IdScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Id create
   */
  export type Redhat_Vulnerability_IdCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Id.
     */
    data: XOR<Redhat_Vulnerability_IdCreateInput, Redhat_Vulnerability_IdUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Id createMany
   */
  export type Redhat_Vulnerability_IdCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Ids.
     */
    data: Redhat_Vulnerability_IdCreateManyInput | Redhat_Vulnerability_IdCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Id update
   */
  export type Redhat_Vulnerability_IdUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Id.
     */
    data: XOR<Redhat_Vulnerability_IdUpdateInput, Redhat_Vulnerability_IdUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Id to update.
     */
    where: Redhat_Vulnerability_IdWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Id updateMany
   */
  export type Redhat_Vulnerability_IdUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Ids.
     */
    data: XOR<Redhat_Vulnerability_IdUpdateManyMutationInput, Redhat_Vulnerability_IdUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Ids to update
     */
    where?: Redhat_Vulnerability_IdWhereInput
  }


  /**
   * Redhat_Vulnerability_Id upsert
   */
  export type Redhat_Vulnerability_IdUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Id to update in case it exists.
     */
    where: Redhat_Vulnerability_IdWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Id found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Id with this data.
     */
    create: XOR<Redhat_Vulnerability_IdCreateInput, Redhat_Vulnerability_IdUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Id was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_IdUpdateInput, Redhat_Vulnerability_IdUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Id delete
   */
  export type Redhat_Vulnerability_IdDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Id to delete.
     */
    where: Redhat_Vulnerability_IdWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Id deleteMany
   */
  export type Redhat_Vulnerability_IdDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Ids to delete
     */
    where?: Redhat_Vulnerability_IdWhereInput
  }


  /**
   * Redhat_Vulnerability_Id.vulnerability
   */
  export type Redhat_Vulnerability_Id$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Id without action
   */
  export type Redhat_Vulnerability_IdDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Id
     */
    select?: Redhat_Vulnerability_IdSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_IdInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Note
   */

  export type AggregateRedhat_Vulnerability_Note = {
    _count: Redhat_Vulnerability_NoteCountAggregateOutputType | null
    _min: Redhat_Vulnerability_NoteMinAggregateOutputType | null
    _max: Redhat_Vulnerability_NoteMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_NoteMinAggregateOutputType = {
    id: string | null
    category: string | null
    text: string | null
    title: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_NoteMaxAggregateOutputType = {
    id: string | null
    category: string | null
    text: string | null
    title: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_NoteCountAggregateOutputType = {
    id: number
    category: number
    text: number
    title: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_NoteMinAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_NoteMaxAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_NoteCountAggregateInputType = {
    id?: true
    category?: true
    text?: true
    title?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Note to aggregate.
     */
    where?: Redhat_Vulnerability_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Notes to fetch.
     */
    orderBy?: Redhat_Vulnerability_NoteOrderByWithRelationInput | Redhat_Vulnerability_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Notes
    **/
    _count?: true | Redhat_Vulnerability_NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_NoteMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_NoteAggregateType<T extends Redhat_Vulnerability_NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Note]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Note[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Note[P]>
  }




  export type Redhat_Vulnerability_NoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_NoteWhereInput
    orderBy?: Redhat_Vulnerability_NoteOrderByWithAggregationInput | Redhat_Vulnerability_NoteOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_NoteScalarFieldEnum[] | Redhat_Vulnerability_NoteScalarFieldEnum
    having?: Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_NoteCountAggregateInputType | true
    _min?: Redhat_Vulnerability_NoteMinAggregateInputType
    _max?: Redhat_Vulnerability_NoteMaxAggregateInputType
  }

  export type Redhat_Vulnerability_NoteGroupByOutputType = {
    id: string
    category: string
    text: string
    title: string
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_NoteCountAggregateOutputType | null
    _min: Redhat_Vulnerability_NoteMinAggregateOutputType | null
    _max: Redhat_Vulnerability_NoteMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_NoteGroupByPayload<T extends Redhat_Vulnerability_NoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_NoteGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_NoteGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_NoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    text?: boolean
    title?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Note$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Note"]>

  export type Redhat_Vulnerability_NoteSelectScalar = {
    id?: boolean
    category?: boolean
    text?: boolean
    title?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_NoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Note$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_NotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Note"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      text: string
      title: string
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_Note"]>
    composites: {}
  }


  type Redhat_Vulnerability_NoteGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_NoteDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload, S>

  type Redhat_Vulnerability_NoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_NoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_NoteCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_NoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Note'], meta: { name: 'Redhat_Vulnerability_Note' } }
    /**
     * Find zero or one Redhat_Vulnerability_Note that matches the filter.
     * @param {Redhat_Vulnerability_NoteFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Note
     * @example
     * // Get one Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_NoteFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Note that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_NoteFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Note
     * @example
     * // Get one Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_NoteFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Note
     * @example
     * // Get one Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_NoteFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Note
     * @example
     * // Get one Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_NoteFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Notes
     * const redhat_Vulnerability_Notes = await prisma.redhat_Vulnerability_Note.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Notes
     * const redhat_Vulnerability_Notes = await prisma.redhat_Vulnerability_Note.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_NoteWithIdOnly = await prisma.redhat_Vulnerability_Note.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_NoteFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Note.
     * @param {Redhat_Vulnerability_NoteCreateArgs} args - Arguments to create a Redhat_Vulnerability_Note.
     * @example
     * // Create one Redhat_Vulnerability_Note
     * const Redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Note
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_NoteCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Notes.
     *     @param {Redhat_Vulnerability_NoteCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Notes.
     *     @example
     *     // Create many Redhat_Vulnerability_Notes
     *     const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_NoteCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Note.
     * @param {Redhat_Vulnerability_NoteDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Note.
     * @example
     * // Delete one Redhat_Vulnerability_Note
     * const Redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Note
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_NoteDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Note.
     * @param {Redhat_Vulnerability_NoteUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Note.
     * @example
     * // Update one Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_NoteUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Notes.
     * @param {Redhat_Vulnerability_NoteDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Notes to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Notes
     * const { count } = await prisma.redhat_Vulnerability_Note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_NoteDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_NoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Notes
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_NoteUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Note.
     * @param {Redhat_Vulnerability_NoteUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Note.
     * @example
     * // Update or create a Redhat_Vulnerability_Note
     * const redhat_Vulnerability_Note = await prisma.redhat_Vulnerability_Note.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Note we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_NoteUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_NoteUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_NoteClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_NotePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteCountArgs} args - Arguments to filter Redhat_Vulnerability_Notes to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Notes
     * const count = await prisma.redhat_Vulnerability_Note.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Notes we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_NoteCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_NoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_NoteAggregateArgs>(args: Subset<T, Redhat_Vulnerability_NoteAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_NoteAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_NoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_NoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_NoteGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_NoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_NoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_NoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Note model
   */
  readonly fields: Redhat_Vulnerability_NoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_NoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Note$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Note$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Note model
   */ 
  interface Redhat_Vulnerability_NoteFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Note", 'String'>
    readonly category: FieldRef<"Redhat_Vulnerability_Note", 'String'>
    readonly text: FieldRef<"Redhat_Vulnerability_Note", 'String'>
    readonly title: FieldRef<"Redhat_Vulnerability_Note", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Note", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Note findUnique
   */
  export type Redhat_Vulnerability_NoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Note to fetch.
     */
    where: Redhat_Vulnerability_NoteWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Note findUniqueOrThrow
   */
  export type Redhat_Vulnerability_NoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Note to fetch.
     */
    where: Redhat_Vulnerability_NoteWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Note findFirst
   */
  export type Redhat_Vulnerability_NoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Note to fetch.
     */
    where?: Redhat_Vulnerability_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Notes to fetch.
     */
    orderBy?: Redhat_Vulnerability_NoteOrderByWithRelationInput | Redhat_Vulnerability_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Notes.
     */
    cursor?: Redhat_Vulnerability_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Notes.
     */
    distinct?: Redhat_Vulnerability_NoteScalarFieldEnum | Redhat_Vulnerability_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Note findFirstOrThrow
   */
  export type Redhat_Vulnerability_NoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Note to fetch.
     */
    where?: Redhat_Vulnerability_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Notes to fetch.
     */
    orderBy?: Redhat_Vulnerability_NoteOrderByWithRelationInput | Redhat_Vulnerability_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Notes.
     */
    cursor?: Redhat_Vulnerability_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Notes.
     */
    distinct?: Redhat_Vulnerability_NoteScalarFieldEnum | Redhat_Vulnerability_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Note findMany
   */
  export type Redhat_Vulnerability_NoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Notes to fetch.
     */
    where?: Redhat_Vulnerability_NoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Notes to fetch.
     */
    orderBy?: Redhat_Vulnerability_NoteOrderByWithRelationInput | Redhat_Vulnerability_NoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Notes.
     */
    cursor?: Redhat_Vulnerability_NoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Notes.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_NoteScalarFieldEnum | Redhat_Vulnerability_NoteScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Note create
   */
  export type Redhat_Vulnerability_NoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Note.
     */
    data: XOR<Redhat_Vulnerability_NoteCreateInput, Redhat_Vulnerability_NoteUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Note createMany
   */
  export type Redhat_Vulnerability_NoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Notes.
     */
    data: Redhat_Vulnerability_NoteCreateManyInput | Redhat_Vulnerability_NoteCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Note update
   */
  export type Redhat_Vulnerability_NoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Note.
     */
    data: XOR<Redhat_Vulnerability_NoteUpdateInput, Redhat_Vulnerability_NoteUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Note to update.
     */
    where: Redhat_Vulnerability_NoteWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Note updateMany
   */
  export type Redhat_Vulnerability_NoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Notes.
     */
    data: XOR<Redhat_Vulnerability_NoteUpdateManyMutationInput, Redhat_Vulnerability_NoteUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Notes to update
     */
    where?: Redhat_Vulnerability_NoteWhereInput
  }


  /**
   * Redhat_Vulnerability_Note upsert
   */
  export type Redhat_Vulnerability_NoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Note to update in case it exists.
     */
    where: Redhat_Vulnerability_NoteWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Note found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Note with this data.
     */
    create: XOR<Redhat_Vulnerability_NoteCreateInput, Redhat_Vulnerability_NoteUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_NoteUpdateInput, Redhat_Vulnerability_NoteUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Note delete
   */
  export type Redhat_Vulnerability_NoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Note to delete.
     */
    where: Redhat_Vulnerability_NoteWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Note deleteMany
   */
  export type Redhat_Vulnerability_NoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Notes to delete
     */
    where?: Redhat_Vulnerability_NoteWhereInput
  }


  /**
   * Redhat_Vulnerability_Note.vulnerability
   */
  export type Redhat_Vulnerability_Note$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Note without action
   */
  export type Redhat_Vulnerability_NoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Note
     */
    select?: Redhat_Vulnerability_NoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_NoteInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_ProductStatus
   */

  export type AggregateRedhat_Vulnerability_ProductStatus = {
    _count: Redhat_Vulnerability_ProductStatusCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ProductStatusMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ProductStatusMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_ProductStatusMinAggregateOutputType = {
    id: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ProductStatusMaxAggregateOutputType = {
    id: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ProductStatusCountAggregateOutputType = {
    id: number
    fixed: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_ProductStatusMinAggregateInputType = {
    id?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ProductStatusMaxAggregateInputType = {
    id?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ProductStatusCountAggregateInputType = {
    id?: true
    fixed?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_ProductStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_ProductStatus to aggregate.
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_ProductStatuses to fetch.
     */
    orderBy?: Redhat_Vulnerability_ProductStatusOrderByWithRelationInput | Redhat_Vulnerability_ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_ProductStatuses
    **/
    _count?: true | Redhat_Vulnerability_ProductStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_ProductStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_ProductStatusMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_ProductStatusAggregateType<T extends Redhat_Vulnerability_ProductStatusAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_ProductStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_ProductStatus[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_ProductStatus[P]>
  }




  export type Redhat_Vulnerability_ProductStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    orderBy?: Redhat_Vulnerability_ProductStatusOrderByWithAggregationInput | Redhat_Vulnerability_ProductStatusOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_ProductStatusScalarFieldEnum[] | Redhat_Vulnerability_ProductStatusScalarFieldEnum
    having?: Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_ProductStatusCountAggregateInputType | true
    _min?: Redhat_Vulnerability_ProductStatusMinAggregateInputType
    _max?: Redhat_Vulnerability_ProductStatusMaxAggregateInputType
  }

  export type Redhat_Vulnerability_ProductStatusGroupByOutputType = {
    id: string
    fixed: string[]
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_ProductStatusCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ProductStatusMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ProductStatusMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_ProductStatusGroupByPayload<T extends Redhat_Vulnerability_ProductStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_ProductStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_ProductStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_ProductStatusGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_ProductStatusGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_ProductStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fixed?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_ProductStatus$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_ProductStatus"]>

  export type Redhat_Vulnerability_ProductStatusSelectScalar = {
    id?: boolean
    fixed?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_ProductStatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_ProductStatus$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_ProductStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_ProductStatus"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fixed: string[]
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_ProductStatus"]>
    composites: {}
  }


  type Redhat_Vulnerability_ProductStatusGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_ProductStatusDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload, S>

  type Redhat_Vulnerability_ProductStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_ProductStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_ProductStatusCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_ProductStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_ProductStatus'], meta: { name: 'Redhat_Vulnerability_ProductStatus' } }
    /**
     * Find zero or one Redhat_Vulnerability_ProductStatus that matches the filter.
     * @param {Redhat_Vulnerability_ProductStatusFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_ProductStatus
     * @example
     * // Get one Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_ProductStatusFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_ProductStatus that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_ProductStatusFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_ProductStatus
     * @example
     * // Get one Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_ProductStatusFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_ProductStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_ProductStatus
     * @example
     * // Get one Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_ProductStatusFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_ProductStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_ProductStatus
     * @example
     * // Get one Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_ProductStatusFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_ProductStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_ProductStatuses
     * const redhat_Vulnerability_ProductStatuses = await prisma.redhat_Vulnerability_ProductStatus.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_ProductStatuses
     * const redhat_Vulnerability_ProductStatuses = await prisma.redhat_Vulnerability_ProductStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_ProductStatusWithIdOnly = await prisma.redhat_Vulnerability_ProductStatus.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_ProductStatusFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_ProductStatus.
     * @param {Redhat_Vulnerability_ProductStatusCreateArgs} args - Arguments to create a Redhat_Vulnerability_ProductStatus.
     * @example
     * // Create one Redhat_Vulnerability_ProductStatus
     * const Redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_ProductStatus
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_ProductStatusCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_ProductStatuses.
     *     @param {Redhat_Vulnerability_ProductStatusCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_ProductStatuses.
     *     @example
     *     // Create many Redhat_Vulnerability_ProductStatuses
     *     const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_ProductStatusCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_ProductStatus.
     * @param {Redhat_Vulnerability_ProductStatusDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_ProductStatus.
     * @example
     * // Delete one Redhat_Vulnerability_ProductStatus
     * const Redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_ProductStatus
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_ProductStatusDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_ProductStatus.
     * @param {Redhat_Vulnerability_ProductStatusUpdateArgs} args - Arguments to update one Redhat_Vulnerability_ProductStatus.
     * @example
     * // Update one Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_ProductStatusUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_ProductStatuses.
     * @param {Redhat_Vulnerability_ProductStatusDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_ProductStatuses to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_ProductStatuses
     * const { count } = await prisma.redhat_Vulnerability_ProductStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_ProductStatusDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ProductStatusDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_ProductStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_ProductStatuses
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_ProductStatusUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_ProductStatus.
     * @param {Redhat_Vulnerability_ProductStatusUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_ProductStatus.
     * @example
     * // Update or create a Redhat_Vulnerability_ProductStatus
     * const redhat_Vulnerability_ProductStatus = await prisma.redhat_Vulnerability_ProductStatus.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_ProductStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_ProductStatus we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_ProductStatusUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ProductStatusUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ProductStatusClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ProductStatusPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_ProductStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusCountArgs} args - Arguments to filter Redhat_Vulnerability_ProductStatuses to count.
     * @example
     * // Count the number of Redhat_Vulnerability_ProductStatuses
     * const count = await prisma.redhat_Vulnerability_ProductStatus.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_ProductStatuses we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_ProductStatusCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_ProductStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_ProductStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_ProductStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_ProductStatusAggregateArgs>(args: Subset<T, Redhat_Vulnerability_ProductStatusAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_ProductStatusAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_ProductStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ProductStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_ProductStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_ProductStatusGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_ProductStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_ProductStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_ProductStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_ProductStatus model
   */
  readonly fields: Redhat_Vulnerability_ProductStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_ProductStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_ProductStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_ProductStatus$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_ProductStatus$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_ProductStatus model
   */ 
  interface Redhat_Vulnerability_ProductStatusFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_ProductStatus", 'String'>
    readonly fixed: FieldRef<"Redhat_Vulnerability_ProductStatus", 'String[]'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_ProductStatus", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_ProductStatus findUnique
   */
  export type Redhat_Vulnerability_ProductStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_ProductStatus to fetch.
     */
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus findUniqueOrThrow
   */
  export type Redhat_Vulnerability_ProductStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_ProductStatus to fetch.
     */
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus findFirst
   */
  export type Redhat_Vulnerability_ProductStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_ProductStatus to fetch.
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_ProductStatuses to fetch.
     */
    orderBy?: Redhat_Vulnerability_ProductStatusOrderByWithRelationInput | Redhat_Vulnerability_ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_ProductStatuses.
     */
    cursor?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_ProductStatuses.
     */
    distinct?: Redhat_Vulnerability_ProductStatusScalarFieldEnum | Redhat_Vulnerability_ProductStatusScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_ProductStatus findFirstOrThrow
   */
  export type Redhat_Vulnerability_ProductStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_ProductStatus to fetch.
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_ProductStatuses to fetch.
     */
    orderBy?: Redhat_Vulnerability_ProductStatusOrderByWithRelationInput | Redhat_Vulnerability_ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_ProductStatuses.
     */
    cursor?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_ProductStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_ProductStatuses.
     */
    distinct?: Redhat_Vulnerability_ProductStatusScalarFieldEnum | Redhat_Vulnerability_ProductStatusScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_ProductStatus findMany
   */
  export type Redhat_Vulnerability_ProductStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_ProductStatuses to fetch.
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_ProductStatuses to fetch.
     */
    orderBy?: Redhat_Vulnerability_ProductStatusOrderByWithRelationInput | Redhat_Vulnerability_ProductStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_ProductStatuses.
     */
    cursor?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_ProductStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_ProductStatuses.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_ProductStatusScalarFieldEnum | Redhat_Vulnerability_ProductStatusScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_ProductStatus create
   */
  export type Redhat_Vulnerability_ProductStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_ProductStatus.
     */
    data?: XOR<Redhat_Vulnerability_ProductStatusCreateInput, Redhat_Vulnerability_ProductStatusUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_ProductStatus createMany
   */
  export type Redhat_Vulnerability_ProductStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_ProductStatuses.
     */
    data: Redhat_Vulnerability_ProductStatusCreateManyInput | Redhat_Vulnerability_ProductStatusCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_ProductStatus update
   */
  export type Redhat_Vulnerability_ProductStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_ProductStatus.
     */
    data: XOR<Redhat_Vulnerability_ProductStatusUpdateInput, Redhat_Vulnerability_ProductStatusUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_ProductStatus to update.
     */
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus updateMany
   */
  export type Redhat_Vulnerability_ProductStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_ProductStatuses.
     */
    data: XOR<Redhat_Vulnerability_ProductStatusUpdateManyMutationInput, Redhat_Vulnerability_ProductStatusUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_ProductStatuses to update
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus upsert
   */
  export type Redhat_Vulnerability_ProductStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_ProductStatus to update in case it exists.
     */
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_ProductStatus found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_ProductStatus with this data.
     */
    create: XOR<Redhat_Vulnerability_ProductStatusCreateInput, Redhat_Vulnerability_ProductStatusUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_ProductStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_ProductStatusUpdateInput, Redhat_Vulnerability_ProductStatusUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_ProductStatus delete
   */
  export type Redhat_Vulnerability_ProductStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_ProductStatus to delete.
     */
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus deleteMany
   */
  export type Redhat_Vulnerability_ProductStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_ProductStatuses to delete
     */
    where?: Redhat_Vulnerability_ProductStatusWhereInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus.vulnerability
   */
  export type Redhat_Vulnerability_ProductStatus$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_ProductStatus without action
   */
  export type Redhat_Vulnerability_ProductStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_ProductStatus
     */
    select?: Redhat_Vulnerability_ProductStatusSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ProductStatusInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Reference
   */

  export type AggregateRedhat_Vulnerability_Reference = {
    _count: Redhat_Vulnerability_ReferenceCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ReferenceMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ReferenceMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_ReferenceMinAggregateOutputType = {
    id: string | null
    category: string | null
    summary: string | null
    url: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ReferenceMaxAggregateOutputType = {
    id: string | null
    category: string | null
    summary: string | null
    url: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ReferenceCountAggregateOutputType = {
    id: number
    category: number
    summary: number
    url: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_ReferenceMinAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ReferenceMaxAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ReferenceCountAggregateInputType = {
    id?: true
    category?: true
    summary?: true
    url?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_ReferenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Reference to aggregate.
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_References to fetch.
     */
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithRelationInput | Redhat_Vulnerability_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_References
    **/
    _count?: true | Redhat_Vulnerability_ReferenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_ReferenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_ReferenceMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_ReferenceAggregateType<T extends Redhat_Vulnerability_ReferenceAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Reference]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Reference[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Reference[P]>
  }




  export type Redhat_Vulnerability_ReferenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ReferenceWhereInput
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithAggregationInput | Redhat_Vulnerability_ReferenceOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_ReferenceScalarFieldEnum[] | Redhat_Vulnerability_ReferenceScalarFieldEnum
    having?: Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_ReferenceCountAggregateInputType | true
    _min?: Redhat_Vulnerability_ReferenceMinAggregateInputType
    _max?: Redhat_Vulnerability_ReferenceMaxAggregateInputType
  }

  export type Redhat_Vulnerability_ReferenceGroupByOutputType = {
    id: string
    category: string
    summary: string
    url: string
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_ReferenceCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ReferenceMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ReferenceMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_ReferenceGroupByPayload<T extends Redhat_Vulnerability_ReferenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_ReferenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_ReferenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_ReferenceGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_ReferenceGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_ReferenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    summary?: boolean
    url?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Reference$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Reference"]>

  export type Redhat_Vulnerability_ReferenceSelectScalar = {
    id?: boolean
    category?: boolean
    summary?: boolean
    url?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_ReferenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Reference$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_ReferencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Reference"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      summary: string
      url: string
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_Reference"]>
    composites: {}
  }


  type Redhat_Vulnerability_ReferenceGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_ReferenceDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload, S>

  type Redhat_Vulnerability_ReferenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_ReferenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_ReferenceCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_ReferenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Reference'], meta: { name: 'Redhat_Vulnerability_Reference' } }
    /**
     * Find zero or one Redhat_Vulnerability_Reference that matches the filter.
     * @param {Redhat_Vulnerability_ReferenceFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Reference
     * @example
     * // Get one Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_ReferenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Reference that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_ReferenceFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Reference
     * @example
     * // Get one Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_ReferenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Reference that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Reference
     * @example
     * // Get one Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_ReferenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Reference that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Reference
     * @example
     * // Get one Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_ReferenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_References
     * const redhat_Vulnerability_References = await prisma.redhat_Vulnerability_Reference.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_References
     * const redhat_Vulnerability_References = await prisma.redhat_Vulnerability_Reference.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_ReferenceWithIdOnly = await prisma.redhat_Vulnerability_Reference.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_ReferenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Reference.
     * @param {Redhat_Vulnerability_ReferenceCreateArgs} args - Arguments to create a Redhat_Vulnerability_Reference.
     * @example
     * // Create one Redhat_Vulnerability_Reference
     * const Redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Reference
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_ReferenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_References.
     *     @param {Redhat_Vulnerability_ReferenceCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_References.
     *     @example
     *     // Create many Redhat_Vulnerability_References
     *     const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_ReferenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Reference.
     * @param {Redhat_Vulnerability_ReferenceDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Reference.
     * @example
     * // Delete one Redhat_Vulnerability_Reference
     * const Redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Reference
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_ReferenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Reference.
     * @param {Redhat_Vulnerability_ReferenceUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Reference.
     * @example
     * // Update one Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_ReferenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_References.
     * @param {Redhat_Vulnerability_ReferenceDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_References to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_References
     * const { count } = await prisma.redhat_Vulnerability_Reference.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_ReferenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ReferenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_References
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_ReferenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Reference.
     * @param {Redhat_Vulnerability_ReferenceUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Reference.
     * @example
     * // Update or create a Redhat_Vulnerability_Reference
     * const redhat_Vulnerability_Reference = await prisma.redhat_Vulnerability_Reference.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Reference
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Reference we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_ReferenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ReferenceUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ReferenceClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ReferencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceCountArgs} args - Arguments to filter Redhat_Vulnerability_References to count.
     * @example
     * // Count the number of Redhat_Vulnerability_References
     * const count = await prisma.redhat_Vulnerability_Reference.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_References we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_ReferenceCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_ReferenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_ReferenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_ReferenceAggregateArgs>(args: Subset<T, Redhat_Vulnerability_ReferenceAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_ReferenceAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Reference.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ReferenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_ReferenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_ReferenceGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_ReferenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_ReferenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_ReferenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Reference model
   */
  readonly fields: Redhat_Vulnerability_ReferenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Reference.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_ReferenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Reference$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Reference$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Reference model
   */ 
  interface Redhat_Vulnerability_ReferenceFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Reference", 'String'>
    readonly category: FieldRef<"Redhat_Vulnerability_Reference", 'String'>
    readonly summary: FieldRef<"Redhat_Vulnerability_Reference", 'String'>
    readonly url: FieldRef<"Redhat_Vulnerability_Reference", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Reference", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Reference findUnique
   */
  export type Redhat_Vulnerability_ReferenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Reference to fetch.
     */
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Reference findUniqueOrThrow
   */
  export type Redhat_Vulnerability_ReferenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Reference to fetch.
     */
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Reference findFirst
   */
  export type Redhat_Vulnerability_ReferenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Reference to fetch.
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_References to fetch.
     */
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithRelationInput | Redhat_Vulnerability_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_References.
     */
    cursor?: Redhat_Vulnerability_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_References.
     */
    distinct?: Redhat_Vulnerability_ReferenceScalarFieldEnum | Redhat_Vulnerability_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Reference findFirstOrThrow
   */
  export type Redhat_Vulnerability_ReferenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Reference to fetch.
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_References to fetch.
     */
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithRelationInput | Redhat_Vulnerability_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_References.
     */
    cursor?: Redhat_Vulnerability_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_References.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_References.
     */
    distinct?: Redhat_Vulnerability_ReferenceScalarFieldEnum | Redhat_Vulnerability_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Reference findMany
   */
  export type Redhat_Vulnerability_ReferenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_References to fetch.
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_References to fetch.
     */
    orderBy?: Redhat_Vulnerability_ReferenceOrderByWithRelationInput | Redhat_Vulnerability_ReferenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_References.
     */
    cursor?: Redhat_Vulnerability_ReferenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_References from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_References.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_ReferenceScalarFieldEnum | Redhat_Vulnerability_ReferenceScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Reference create
   */
  export type Redhat_Vulnerability_ReferenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Reference.
     */
    data: XOR<Redhat_Vulnerability_ReferenceCreateInput, Redhat_Vulnerability_ReferenceUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Reference createMany
   */
  export type Redhat_Vulnerability_ReferenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_References.
     */
    data: Redhat_Vulnerability_ReferenceCreateManyInput | Redhat_Vulnerability_ReferenceCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Reference update
   */
  export type Redhat_Vulnerability_ReferenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Reference.
     */
    data: XOR<Redhat_Vulnerability_ReferenceUpdateInput, Redhat_Vulnerability_ReferenceUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Reference to update.
     */
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Reference updateMany
   */
  export type Redhat_Vulnerability_ReferenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_References.
     */
    data: XOR<Redhat_Vulnerability_ReferenceUpdateManyMutationInput, Redhat_Vulnerability_ReferenceUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_References to update
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
  }


  /**
   * Redhat_Vulnerability_Reference upsert
   */
  export type Redhat_Vulnerability_ReferenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Reference to update in case it exists.
     */
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Reference found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Reference with this data.
     */
    create: XOR<Redhat_Vulnerability_ReferenceCreateInput, Redhat_Vulnerability_ReferenceUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Reference was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_ReferenceUpdateInput, Redhat_Vulnerability_ReferenceUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Reference delete
   */
  export type Redhat_Vulnerability_ReferenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Reference to delete.
     */
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Reference deleteMany
   */
  export type Redhat_Vulnerability_ReferenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_References to delete
     */
    where?: Redhat_Vulnerability_ReferenceWhereInput
  }


  /**
   * Redhat_Vulnerability_Reference.vulnerability
   */
  export type Redhat_Vulnerability_Reference$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Reference without action
   */
  export type Redhat_Vulnerability_ReferenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Reference
     */
    select?: Redhat_Vulnerability_ReferenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ReferenceInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Remediation
   */

  export type AggregateRedhat_Vulnerability_Remediation = {
    _count: Redhat_Vulnerability_RemediationCountAggregateOutputType | null
    _min: Redhat_Vulnerability_RemediationMinAggregateOutputType | null
    _max: Redhat_Vulnerability_RemediationMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_RemediationMinAggregateOutputType = {
    id: string | null
    category: string | null
    details: string | null
    url: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_RemediationMaxAggregateOutputType = {
    id: string | null
    category: string | null
    details: string | null
    url: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_RemediationCountAggregateOutputType = {
    id: number
    category: number
    details: number
    product_ids: number
    url: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_RemediationMinAggregateInputType = {
    id?: true
    category?: true
    details?: true
    url?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_RemediationMaxAggregateInputType = {
    id?: true
    category?: true
    details?: true
    url?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_RemediationCountAggregateInputType = {
    id?: true
    category?: true
    details?: true
    product_ids?: true
    url?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_RemediationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Remediation to aggregate.
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Remediations to fetch.
     */
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithRelationInput | Redhat_Vulnerability_RemediationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_RemediationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Remediations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Remediations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Remediations
    **/
    _count?: true | Redhat_Vulnerability_RemediationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_RemediationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_RemediationMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_RemediationAggregateType<T extends Redhat_Vulnerability_RemediationAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Remediation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Remediation[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Remediation[P]>
  }




  export type Redhat_Vulnerability_RemediationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_RemediationWhereInput
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithAggregationInput | Redhat_Vulnerability_RemediationOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_RemediationScalarFieldEnum[] | Redhat_Vulnerability_RemediationScalarFieldEnum
    having?: Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_RemediationCountAggregateInputType | true
    _min?: Redhat_Vulnerability_RemediationMinAggregateInputType
    _max?: Redhat_Vulnerability_RemediationMaxAggregateInputType
  }

  export type Redhat_Vulnerability_RemediationGroupByOutputType = {
    id: string
    category: string
    details: string
    product_ids: string[]
    url: string | null
    vulnerabilityId: string
    _count: Redhat_Vulnerability_RemediationCountAggregateOutputType | null
    _min: Redhat_Vulnerability_RemediationMinAggregateOutputType | null
    _max: Redhat_Vulnerability_RemediationMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_RemediationGroupByPayload<T extends Redhat_Vulnerability_RemediationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_RemediationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_RemediationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_RemediationGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_RemediationGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_RemediationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    details?: boolean
    product_ids?: boolean
    url?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Remediation$vulnerabilityArgs<ExtArgs>
    restart_required?: boolean | Redhat_Vulnerability_Remediation$restart_requiredArgs<ExtArgs>
    _count?: boolean | Redhat_Vulnerability_RemediationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Remediation"]>

  export type Redhat_Vulnerability_RemediationSelectScalar = {
    id?: boolean
    category?: boolean
    details?: boolean
    product_ids?: boolean
    url?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_RemediationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Remediation$vulnerabilityArgs<ExtArgs>
    restart_required?: boolean | Redhat_Vulnerability_Remediation$restart_requiredArgs<ExtArgs>
    _count?: boolean | Redhat_Vulnerability_RemediationCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_RemediationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Remediation"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
      restart_required: Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      details: string
      product_ids: string[]
      url: string | null
      vulnerabilityId: string
    }, ExtArgs["result"]["redhat_Vulnerability_Remediation"]>
    composites: {}
  }


  type Redhat_Vulnerability_RemediationGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_RemediationDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload, S>

  type Redhat_Vulnerability_RemediationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_RemediationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_RemediationCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_RemediationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Remediation'], meta: { name: 'Redhat_Vulnerability_Remediation' } }
    /**
     * Find zero or one Redhat_Vulnerability_Remediation that matches the filter.
     * @param {Redhat_Vulnerability_RemediationFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Remediation
     * @example
     * // Get one Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_RemediationFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Remediation that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_RemediationFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Remediation
     * @example
     * // Get one Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_RemediationFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Remediation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Remediation
     * @example
     * // Get one Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_RemediationFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Remediation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Remediation
     * @example
     * // Get one Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_RemediationFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Remediations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Remediations
     * const redhat_Vulnerability_Remediations = await prisma.redhat_Vulnerability_Remediation.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Remediations
     * const redhat_Vulnerability_Remediations = await prisma.redhat_Vulnerability_Remediation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_RemediationWithIdOnly = await prisma.redhat_Vulnerability_Remediation.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_RemediationFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Remediation.
     * @param {Redhat_Vulnerability_RemediationCreateArgs} args - Arguments to create a Redhat_Vulnerability_Remediation.
     * @example
     * // Create one Redhat_Vulnerability_Remediation
     * const Redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Remediation
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_RemediationCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Remediations.
     *     @param {Redhat_Vulnerability_RemediationCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Remediations.
     *     @example
     *     // Create many Redhat_Vulnerability_Remediations
     *     const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_RemediationCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Remediation.
     * @param {Redhat_Vulnerability_RemediationDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Remediation.
     * @example
     * // Delete one Redhat_Vulnerability_Remediation
     * const Redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Remediation
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_RemediationDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Remediation.
     * @param {Redhat_Vulnerability_RemediationUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Remediation.
     * @example
     * // Update one Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_RemediationUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Remediations.
     * @param {Redhat_Vulnerability_RemediationDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Remediations to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Remediations
     * const { count } = await prisma.redhat_Vulnerability_Remediation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_RemediationDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RemediationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Remediations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Remediations
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_RemediationUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Remediation.
     * @param {Redhat_Vulnerability_RemediationUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Remediation.
     * @example
     * // Update or create a Redhat_Vulnerability_Remediation
     * const redhat_Vulnerability_Remediation = await prisma.redhat_Vulnerability_Remediation.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Remediation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Remediation we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_RemediationUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RemediationUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Remediations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationCountArgs} args - Arguments to filter Redhat_Vulnerability_Remediations to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Remediations
     * const count = await prisma.redhat_Vulnerability_Remediation.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Remediations we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_RemediationCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_RemediationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_RemediationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Remediation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_RemediationAggregateArgs>(args: Subset<T, Redhat_Vulnerability_RemediationAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_RemediationAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Remediation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RemediationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_RemediationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_RemediationGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_RemediationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_RemediationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_RemediationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Remediation model
   */
  readonly fields: Redhat_Vulnerability_RemediationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Remediation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_RemediationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Remediation$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Remediation$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    restart_required<T extends Redhat_Vulnerability_Remediation$restart_requiredArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Remediation$restart_requiredArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Remediation model
   */ 
  interface Redhat_Vulnerability_RemediationFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Remediation", 'String'>
    readonly category: FieldRef<"Redhat_Vulnerability_Remediation", 'String'>
    readonly details: FieldRef<"Redhat_Vulnerability_Remediation", 'String'>
    readonly product_ids: FieldRef<"Redhat_Vulnerability_Remediation", 'String[]'>
    readonly url: FieldRef<"Redhat_Vulnerability_Remediation", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Remediation", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Remediation findUnique
   */
  export type Redhat_Vulnerability_RemediationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Remediation to fetch.
     */
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Remediation findUniqueOrThrow
   */
  export type Redhat_Vulnerability_RemediationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Remediation to fetch.
     */
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Remediation findFirst
   */
  export type Redhat_Vulnerability_RemediationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Remediation to fetch.
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Remediations to fetch.
     */
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithRelationInput | Redhat_Vulnerability_RemediationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Remediations.
     */
    cursor?: Redhat_Vulnerability_RemediationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Remediations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Remediations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Remediations.
     */
    distinct?: Redhat_Vulnerability_RemediationScalarFieldEnum | Redhat_Vulnerability_RemediationScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Remediation findFirstOrThrow
   */
  export type Redhat_Vulnerability_RemediationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Remediation to fetch.
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Remediations to fetch.
     */
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithRelationInput | Redhat_Vulnerability_RemediationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Remediations.
     */
    cursor?: Redhat_Vulnerability_RemediationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Remediations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Remediations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Remediations.
     */
    distinct?: Redhat_Vulnerability_RemediationScalarFieldEnum | Redhat_Vulnerability_RemediationScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Remediation findMany
   */
  export type Redhat_Vulnerability_RemediationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Remediations to fetch.
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Remediations to fetch.
     */
    orderBy?: Redhat_Vulnerability_RemediationOrderByWithRelationInput | Redhat_Vulnerability_RemediationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Remediations.
     */
    cursor?: Redhat_Vulnerability_RemediationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Remediations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Remediations.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_RemediationScalarFieldEnum | Redhat_Vulnerability_RemediationScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Remediation create
   */
  export type Redhat_Vulnerability_RemediationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Remediation.
     */
    data: XOR<Redhat_Vulnerability_RemediationCreateInput, Redhat_Vulnerability_RemediationUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Remediation createMany
   */
  export type Redhat_Vulnerability_RemediationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Remediations.
     */
    data: Redhat_Vulnerability_RemediationCreateManyInput | Redhat_Vulnerability_RemediationCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Remediation update
   */
  export type Redhat_Vulnerability_RemediationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Remediation.
     */
    data: XOR<Redhat_Vulnerability_RemediationUpdateInput, Redhat_Vulnerability_RemediationUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Remediation to update.
     */
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Remediation updateMany
   */
  export type Redhat_Vulnerability_RemediationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Remediations.
     */
    data: XOR<Redhat_Vulnerability_RemediationUpdateManyMutationInput, Redhat_Vulnerability_RemediationUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Remediations to update
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
  }


  /**
   * Redhat_Vulnerability_Remediation upsert
   */
  export type Redhat_Vulnerability_RemediationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Remediation to update in case it exists.
     */
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Remediation found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Remediation with this data.
     */
    create: XOR<Redhat_Vulnerability_RemediationCreateInput, Redhat_Vulnerability_RemediationUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Remediation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_RemediationUpdateInput, Redhat_Vulnerability_RemediationUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Remediation delete
   */
  export type Redhat_Vulnerability_RemediationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Remediation to delete.
     */
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Remediation deleteMany
   */
  export type Redhat_Vulnerability_RemediationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Remediations to delete
     */
    where?: Redhat_Vulnerability_RemediationWhereInput
  }


  /**
   * Redhat_Vulnerability_Remediation.vulnerability
   */
  export type Redhat_Vulnerability_Remediation$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Remediation.restart_required
   */
  export type Redhat_Vulnerability_Remediation$restart_requiredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput | Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput[]
    cursor?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Redhat_Vulnerability_RestartRequiredScalarFieldEnum | Redhat_Vulnerability_RestartRequiredScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Remediation without action
   */
  export type Redhat_Vulnerability_RemediationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_RestartRequired
   */

  export type AggregateRedhat_Vulnerability_RestartRequired = {
    _count: Redhat_Vulnerability_RestartRequiredCountAggregateOutputType | null
    _min: Redhat_Vulnerability_RestartRequiredMinAggregateOutputType | null
    _max: Redhat_Vulnerability_RestartRequiredMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_RestartRequiredMinAggregateOutputType = {
    id: string | null
    category: string | null
    remediationId: string | null
  }

  export type Redhat_Vulnerability_RestartRequiredMaxAggregateOutputType = {
    id: string | null
    category: string | null
    remediationId: string | null
  }

  export type Redhat_Vulnerability_RestartRequiredCountAggregateOutputType = {
    id: number
    category: number
    remediationId: number
    _all: number
  }


  export type Redhat_Vulnerability_RestartRequiredMinAggregateInputType = {
    id?: true
    category?: true
    remediationId?: true
  }

  export type Redhat_Vulnerability_RestartRequiredMaxAggregateInputType = {
    id?: true
    category?: true
    remediationId?: true
  }

  export type Redhat_Vulnerability_RestartRequiredCountAggregateInputType = {
    id?: true
    category?: true
    remediationId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_RestartRequiredAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_RestartRequired to aggregate.
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_RestartRequireds to fetch.
     */
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput | Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_RestartRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_RestartRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_RestartRequireds
    **/
    _count?: true | Redhat_Vulnerability_RestartRequiredCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_RestartRequiredMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_RestartRequiredMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_RestartRequiredAggregateType<T extends Redhat_Vulnerability_RestartRequiredAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_RestartRequired]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_RestartRequired[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_RestartRequired[P]>
  }




  export type Redhat_Vulnerability_RestartRequiredGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithAggregationInput | Redhat_Vulnerability_RestartRequiredOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_RestartRequiredScalarFieldEnum[] | Redhat_Vulnerability_RestartRequiredScalarFieldEnum
    having?: Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_RestartRequiredCountAggregateInputType | true
    _min?: Redhat_Vulnerability_RestartRequiredMinAggregateInputType
    _max?: Redhat_Vulnerability_RestartRequiredMaxAggregateInputType
  }

  export type Redhat_Vulnerability_RestartRequiredGroupByOutputType = {
    id: string
    category: string
    remediationId: string
    _count: Redhat_Vulnerability_RestartRequiredCountAggregateOutputType | null
    _min: Redhat_Vulnerability_RestartRequiredMinAggregateOutputType | null
    _max: Redhat_Vulnerability_RestartRequiredMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_RestartRequiredGroupByPayload<T extends Redhat_Vulnerability_RestartRequiredGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_RestartRequiredGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_RestartRequiredGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_RestartRequiredGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_RestartRequiredGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_RestartRequiredSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    remediationId?: boolean
    remediation?: boolean | Redhat_Vulnerability_RestartRequired$remediationArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_RestartRequired"]>

  export type Redhat_Vulnerability_RestartRequiredSelectScalar = {
    id?: boolean
    category?: boolean
    remediationId?: boolean
  }

  export type Redhat_Vulnerability_RestartRequiredInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    remediation?: boolean | Redhat_Vulnerability_RestartRequired$remediationArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_RestartRequiredPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_RestartRequired"
    objects: {
      remediation: Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      remediationId: string
    }, ExtArgs["result"]["redhat_Vulnerability_RestartRequired"]>
    composites: {}
  }


  type Redhat_Vulnerability_RestartRequiredGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_RestartRequiredDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload, S>

  type Redhat_Vulnerability_RestartRequiredCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_RestartRequiredFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_RestartRequiredCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_RestartRequiredDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_RestartRequired'], meta: { name: 'Redhat_Vulnerability_RestartRequired' } }
    /**
     * Find zero or one Redhat_Vulnerability_RestartRequired that matches the filter.
     * @param {Redhat_Vulnerability_RestartRequiredFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_RestartRequired
     * @example
     * // Get one Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_RestartRequiredFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_RestartRequired that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_RestartRequiredFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_RestartRequired
     * @example
     * // Get one Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_RestartRequiredFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_RestartRequired that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_RestartRequired
     * @example
     * // Get one Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_RestartRequiredFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_RestartRequired that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_RestartRequired
     * @example
     * // Get one Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_RestartRequiredFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_RestartRequireds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_RestartRequireds
     * const redhat_Vulnerability_RestartRequireds = await prisma.redhat_Vulnerability_RestartRequired.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_RestartRequireds
     * const redhat_Vulnerability_RestartRequireds = await prisma.redhat_Vulnerability_RestartRequired.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_RestartRequiredWithIdOnly = await prisma.redhat_Vulnerability_RestartRequired.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_RestartRequiredFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_RestartRequired.
     * @param {Redhat_Vulnerability_RestartRequiredCreateArgs} args - Arguments to create a Redhat_Vulnerability_RestartRequired.
     * @example
     * // Create one Redhat_Vulnerability_RestartRequired
     * const Redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_RestartRequired
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_RestartRequiredCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_RestartRequireds.
     *     @param {Redhat_Vulnerability_RestartRequiredCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_RestartRequireds.
     *     @example
     *     // Create many Redhat_Vulnerability_RestartRequireds
     *     const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_RestartRequiredCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_RestartRequired.
     * @param {Redhat_Vulnerability_RestartRequiredDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_RestartRequired.
     * @example
     * // Delete one Redhat_Vulnerability_RestartRequired
     * const Redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_RestartRequired
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_RestartRequiredDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_RestartRequired.
     * @param {Redhat_Vulnerability_RestartRequiredUpdateArgs} args - Arguments to update one Redhat_Vulnerability_RestartRequired.
     * @example
     * // Update one Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_RestartRequiredUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_RestartRequireds.
     * @param {Redhat_Vulnerability_RestartRequiredDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_RestartRequireds to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_RestartRequireds
     * const { count } = await prisma.redhat_Vulnerability_RestartRequired.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_RestartRequiredDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_RestartRequiredDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_RestartRequireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_RestartRequireds
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_RestartRequiredUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_RestartRequired.
     * @param {Redhat_Vulnerability_RestartRequiredUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_RestartRequired.
     * @example
     * // Update or create a Redhat_Vulnerability_RestartRequired
     * const redhat_Vulnerability_RestartRequired = await prisma.redhat_Vulnerability_RestartRequired.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_RestartRequired
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_RestartRequired we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_RestartRequiredUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_RestartRequiredUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_RestartRequiredClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RestartRequiredPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_RestartRequireds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredCountArgs} args - Arguments to filter Redhat_Vulnerability_RestartRequireds to count.
     * @example
     * // Count the number of Redhat_Vulnerability_RestartRequireds
     * const count = await prisma.redhat_Vulnerability_RestartRequired.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_RestartRequireds we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_RestartRequiredCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_RestartRequiredCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_RestartRequiredCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_RestartRequired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_RestartRequiredAggregateArgs>(args: Subset<T, Redhat_Vulnerability_RestartRequiredAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_RestartRequiredAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_RestartRequired.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_RestartRequiredGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_RestartRequiredGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_RestartRequiredGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_RestartRequiredGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_RestartRequiredGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_RestartRequiredGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_RestartRequired model
   */
  readonly fields: Redhat_Vulnerability_RestartRequiredFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_RestartRequired.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_RestartRequiredClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    remediation<T extends Redhat_Vulnerability_RestartRequired$remediationArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_RestartRequired$remediationArgs<ExtArgs>>): Prisma__Redhat_Vulnerability_RemediationClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_RemediationPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_RestartRequired model
   */ 
  interface Redhat_Vulnerability_RestartRequiredFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_RestartRequired", 'String'>
    readonly category: FieldRef<"Redhat_Vulnerability_RestartRequired", 'String'>
    readonly remediationId: FieldRef<"Redhat_Vulnerability_RestartRequired", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_RestartRequired findUnique
   */
  export type Redhat_Vulnerability_RestartRequiredFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_RestartRequired to fetch.
     */
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired findUniqueOrThrow
   */
  export type Redhat_Vulnerability_RestartRequiredFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_RestartRequired to fetch.
     */
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired findFirst
   */
  export type Redhat_Vulnerability_RestartRequiredFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_RestartRequired to fetch.
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_RestartRequireds to fetch.
     */
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput | Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_RestartRequireds.
     */
    cursor?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_RestartRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_RestartRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_RestartRequireds.
     */
    distinct?: Redhat_Vulnerability_RestartRequiredScalarFieldEnum | Redhat_Vulnerability_RestartRequiredScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_RestartRequired findFirstOrThrow
   */
  export type Redhat_Vulnerability_RestartRequiredFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_RestartRequired to fetch.
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_RestartRequireds to fetch.
     */
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput | Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_RestartRequireds.
     */
    cursor?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_RestartRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_RestartRequireds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_RestartRequireds.
     */
    distinct?: Redhat_Vulnerability_RestartRequiredScalarFieldEnum | Redhat_Vulnerability_RestartRequiredScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_RestartRequired findMany
   */
  export type Redhat_Vulnerability_RestartRequiredFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_RestartRequireds to fetch.
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_RestartRequireds to fetch.
     */
    orderBy?: Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput | Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_RestartRequireds.
     */
    cursor?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_RestartRequireds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_RestartRequireds.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_RestartRequiredScalarFieldEnum | Redhat_Vulnerability_RestartRequiredScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_RestartRequired create
   */
  export type Redhat_Vulnerability_RestartRequiredCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_RestartRequired.
     */
    data: XOR<Redhat_Vulnerability_RestartRequiredCreateInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_RestartRequired createMany
   */
  export type Redhat_Vulnerability_RestartRequiredCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_RestartRequireds.
     */
    data: Redhat_Vulnerability_RestartRequiredCreateManyInput | Redhat_Vulnerability_RestartRequiredCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_RestartRequired update
   */
  export type Redhat_Vulnerability_RestartRequiredUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_RestartRequired.
     */
    data: XOR<Redhat_Vulnerability_RestartRequiredUpdateInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_RestartRequired to update.
     */
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired updateMany
   */
  export type Redhat_Vulnerability_RestartRequiredUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_RestartRequireds.
     */
    data: XOR<Redhat_Vulnerability_RestartRequiredUpdateManyMutationInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_RestartRequireds to update
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired upsert
   */
  export type Redhat_Vulnerability_RestartRequiredUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_RestartRequired to update in case it exists.
     */
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_RestartRequired found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_RestartRequired with this data.
     */
    create: XOR<Redhat_Vulnerability_RestartRequiredCreateInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_RestartRequired was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_RestartRequiredUpdateInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_RestartRequired delete
   */
  export type Redhat_Vulnerability_RestartRequiredDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_RestartRequired to delete.
     */
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired deleteMany
   */
  export type Redhat_Vulnerability_RestartRequiredDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_RestartRequireds to delete
     */
    where?: Redhat_Vulnerability_RestartRequiredWhereInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired.remediation
   */
  export type Redhat_Vulnerability_RestartRequired$remediationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Remediation
     */
    select?: Redhat_Vulnerability_RemediationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RemediationInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_RemediationWhereInput
  }


  /**
   * Redhat_Vulnerability_RestartRequired without action
   */
  export type Redhat_Vulnerability_RestartRequiredDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_RestartRequired
     */
    select?: Redhat_Vulnerability_RestartRequiredSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_RestartRequiredInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Score
   */

  export type AggregateRedhat_Vulnerability_Score = {
    _count: Redhat_Vulnerability_ScoreCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ScoreMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ScoreMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_ScoreMinAggregateOutputType = {
    id: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ScoreMaxAggregateOutputType = {
    id: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ScoreCountAggregateOutputType = {
    id: number
    products: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_ScoreMinAggregateInputType = {
    id?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ScoreMaxAggregateInputType = {
    id?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ScoreCountAggregateInputType = {
    id?: true
    products?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_ScoreAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Score to aggregate.
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Scores to fetch.
     */
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithRelationInput | Redhat_Vulnerability_ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Scores
    **/
    _count?: true | Redhat_Vulnerability_ScoreCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_ScoreMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_ScoreMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_ScoreAggregateType<T extends Redhat_Vulnerability_ScoreAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Score]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Score[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Score[P]>
  }




  export type Redhat_Vulnerability_ScoreGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ScoreWhereInput
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithAggregationInput | Redhat_Vulnerability_ScoreOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_ScoreScalarFieldEnum[] | Redhat_Vulnerability_ScoreScalarFieldEnum
    having?: Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_ScoreCountAggregateInputType | true
    _min?: Redhat_Vulnerability_ScoreMinAggregateInputType
    _max?: Redhat_Vulnerability_ScoreMaxAggregateInputType
  }

  export type Redhat_Vulnerability_ScoreGroupByOutputType = {
    id: string
    products: string[]
    vulnerabilityId: string
    _count: Redhat_Vulnerability_ScoreCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ScoreMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ScoreMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_ScoreGroupByPayload<T extends Redhat_Vulnerability_ScoreGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_ScoreGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_ScoreGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_ScoreGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_ScoreGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_ScoreSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    products?: boolean
    vulnerabilityId?: boolean
    cvss_v3?: boolean | Redhat_Vulnerability_Score$cvss_v3Args<ExtArgs>
    vulnerability?: boolean | Redhat_Vulnerability_Score$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Score"]>

  export type Redhat_Vulnerability_ScoreSelectScalar = {
    id?: boolean
    products?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_ScoreInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvss_v3?: boolean | Redhat_Vulnerability_Score$cvss_v3Args<ExtArgs>
    vulnerability?: boolean | Redhat_Vulnerability_Score$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_ScorePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Score"
    objects: {
      cvss_v3: Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs> | null
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      products: string[]
      vulnerabilityId: string
    }, ExtArgs["result"]["redhat_Vulnerability_Score"]>
    composites: {}
  }


  type Redhat_Vulnerability_ScoreGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_ScoreDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload, S>

  type Redhat_Vulnerability_ScoreCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_ScoreFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_ScoreCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_ScoreDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Score'], meta: { name: 'Redhat_Vulnerability_Score' } }
    /**
     * Find zero or one Redhat_Vulnerability_Score that matches the filter.
     * @param {Redhat_Vulnerability_ScoreFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Score
     * @example
     * // Get one Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_ScoreFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Score that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_ScoreFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Score
     * @example
     * // Get one Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_ScoreFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Score that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Score
     * @example
     * // Get one Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_ScoreFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Score that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Score
     * @example
     * // Get one Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_ScoreFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Scores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Scores
     * const redhat_Vulnerability_Scores = await prisma.redhat_Vulnerability_Score.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Scores
     * const redhat_Vulnerability_Scores = await prisma.redhat_Vulnerability_Score.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_ScoreWithIdOnly = await prisma.redhat_Vulnerability_Score.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_ScoreFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Score.
     * @param {Redhat_Vulnerability_ScoreCreateArgs} args - Arguments to create a Redhat_Vulnerability_Score.
     * @example
     * // Create one Redhat_Vulnerability_Score
     * const Redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Score
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_ScoreCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Scores.
     *     @param {Redhat_Vulnerability_ScoreCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Scores.
     *     @example
     *     // Create many Redhat_Vulnerability_Scores
     *     const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_ScoreCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Score.
     * @param {Redhat_Vulnerability_ScoreDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Score.
     * @example
     * // Delete one Redhat_Vulnerability_Score
     * const Redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Score
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_ScoreDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Score.
     * @param {Redhat_Vulnerability_ScoreUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Score.
     * @example
     * // Update one Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_ScoreUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Scores.
     * @param {Redhat_Vulnerability_ScoreDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Scores to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Scores
     * const { count } = await prisma.redhat_Vulnerability_Score.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_ScoreDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ScoreDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Scores
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_ScoreUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Score.
     * @param {Redhat_Vulnerability_ScoreUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Score.
     * @example
     * // Update or create a Redhat_Vulnerability_Score
     * const redhat_Vulnerability_Score = await prisma.redhat_Vulnerability_Score.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Score
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Score we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_ScoreUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ScoreUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Scores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreCountArgs} args - Arguments to filter Redhat_Vulnerability_Scores to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Scores
     * const count = await prisma.redhat_Vulnerability_Score.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Scores we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_ScoreCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_ScoreCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_ScoreCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_ScoreAggregateArgs>(args: Subset<T, Redhat_Vulnerability_ScoreAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_ScoreAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Score.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ScoreGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_ScoreGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_ScoreGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_ScoreGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_ScoreGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_ScoreGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Score model
   */
  readonly fields: Redhat_Vulnerability_ScoreFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Score.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_ScoreClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    cvss_v3<T extends Redhat_Vulnerability_Score$cvss_v3Args<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Score$cvss_v3Args<ExtArgs>>): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    vulnerability<T extends Redhat_Vulnerability_Score$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Score$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Score model
   */ 
  interface Redhat_Vulnerability_ScoreFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Score", 'String'>
    readonly products: FieldRef<"Redhat_Vulnerability_Score", 'String[]'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Score", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Score findUnique
   */
  export type Redhat_Vulnerability_ScoreFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Score to fetch.
     */
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Score findUniqueOrThrow
   */
  export type Redhat_Vulnerability_ScoreFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Score to fetch.
     */
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Score findFirst
   */
  export type Redhat_Vulnerability_ScoreFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Score to fetch.
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Scores to fetch.
     */
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithRelationInput | Redhat_Vulnerability_ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Scores.
     */
    cursor?: Redhat_Vulnerability_ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Scores.
     */
    distinct?: Redhat_Vulnerability_ScoreScalarFieldEnum | Redhat_Vulnerability_ScoreScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Score findFirstOrThrow
   */
  export type Redhat_Vulnerability_ScoreFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Score to fetch.
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Scores to fetch.
     */
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithRelationInput | Redhat_Vulnerability_ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Scores.
     */
    cursor?: Redhat_Vulnerability_ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Scores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Scores.
     */
    distinct?: Redhat_Vulnerability_ScoreScalarFieldEnum | Redhat_Vulnerability_ScoreScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Score findMany
   */
  export type Redhat_Vulnerability_ScoreFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Scores to fetch.
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Scores to fetch.
     */
    orderBy?: Redhat_Vulnerability_ScoreOrderByWithRelationInput | Redhat_Vulnerability_ScoreOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Scores.
     */
    cursor?: Redhat_Vulnerability_ScoreWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Scores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Scores.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_ScoreScalarFieldEnum | Redhat_Vulnerability_ScoreScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Score create
   */
  export type Redhat_Vulnerability_ScoreCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Score.
     */
    data: XOR<Redhat_Vulnerability_ScoreCreateInput, Redhat_Vulnerability_ScoreUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Score createMany
   */
  export type Redhat_Vulnerability_ScoreCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Scores.
     */
    data: Redhat_Vulnerability_ScoreCreateManyInput | Redhat_Vulnerability_ScoreCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Score update
   */
  export type Redhat_Vulnerability_ScoreUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Score.
     */
    data: XOR<Redhat_Vulnerability_ScoreUpdateInput, Redhat_Vulnerability_ScoreUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Score to update.
     */
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Score updateMany
   */
  export type Redhat_Vulnerability_ScoreUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Scores.
     */
    data: XOR<Redhat_Vulnerability_ScoreUpdateManyMutationInput, Redhat_Vulnerability_ScoreUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Scores to update
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
  }


  /**
   * Redhat_Vulnerability_Score upsert
   */
  export type Redhat_Vulnerability_ScoreUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Score to update in case it exists.
     */
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Score found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Score with this data.
     */
    create: XOR<Redhat_Vulnerability_ScoreCreateInput, Redhat_Vulnerability_ScoreUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Score was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_ScoreUpdateInput, Redhat_Vulnerability_ScoreUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Score delete
   */
  export type Redhat_Vulnerability_ScoreDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Score to delete.
     */
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Score deleteMany
   */
  export type Redhat_Vulnerability_ScoreDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Scores to delete
     */
    where?: Redhat_Vulnerability_ScoreWhereInput
  }


  /**
   * Redhat_Vulnerability_Score.cvss_v3
   */
  export type Redhat_Vulnerability_Score$cvss_v3Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    where?: Redhat_Vulnerability_CvssV3WhereInput
  }


  /**
   * Redhat_Vulnerability_Score.vulnerability
   */
  export type Redhat_Vulnerability_Score$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Score without action
   */
  export type Redhat_Vulnerability_ScoreDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_CvssV3
   */

  export type AggregateRedhat_Vulnerability_CvssV3 = {
    _count: Redhat_Vulnerability_CvssV3CountAggregateOutputType | null
    _avg: Redhat_Vulnerability_CvssV3AvgAggregateOutputType | null
    _sum: Redhat_Vulnerability_CvssV3SumAggregateOutputType | null
    _min: Redhat_Vulnerability_CvssV3MinAggregateOutputType | null
    _max: Redhat_Vulnerability_CvssV3MaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_CvssV3AvgAggregateOutputType = {
    baseScore: number | null
  }

  export type Redhat_Vulnerability_CvssV3SumAggregateOutputType = {
    baseScore: number | null
  }

  export type Redhat_Vulnerability_CvssV3MinAggregateOutputType = {
    id: string | null
    attackComplexity: string | null
    attackVector: string | null
    availabilityImpact: string | null
    baseScore: number | null
    baseSeverity: string | null
    confidentialityImpact: string | null
    integrityImpact: string | null
    privilegesRequired: string | null
    scope: string | null
    userInteraction: string | null
    vectorString: string | null
    version: string | null
    scoreId: string | null
  }

  export type Redhat_Vulnerability_CvssV3MaxAggregateOutputType = {
    id: string | null
    attackComplexity: string | null
    attackVector: string | null
    availabilityImpact: string | null
    baseScore: number | null
    baseSeverity: string | null
    confidentialityImpact: string | null
    integrityImpact: string | null
    privilegesRequired: string | null
    scope: string | null
    userInteraction: string | null
    vectorString: string | null
    version: string | null
    scoreId: string | null
  }

  export type Redhat_Vulnerability_CvssV3CountAggregateOutputType = {
    id: number
    attackComplexity: number
    attackVector: number
    availabilityImpact: number
    baseScore: number
    baseSeverity: number
    confidentialityImpact: number
    integrityImpact: number
    privilegesRequired: number
    scope: number
    userInteraction: number
    vectorString: number
    version: number
    scoreId: number
    _all: number
  }


  export type Redhat_Vulnerability_CvssV3AvgAggregateInputType = {
    baseScore?: true
  }

  export type Redhat_Vulnerability_CvssV3SumAggregateInputType = {
    baseScore?: true
  }

  export type Redhat_Vulnerability_CvssV3MinAggregateInputType = {
    id?: true
    attackComplexity?: true
    attackVector?: true
    availabilityImpact?: true
    baseScore?: true
    baseSeverity?: true
    confidentialityImpact?: true
    integrityImpact?: true
    privilegesRequired?: true
    scope?: true
    userInteraction?: true
    vectorString?: true
    version?: true
    scoreId?: true
  }

  export type Redhat_Vulnerability_CvssV3MaxAggregateInputType = {
    id?: true
    attackComplexity?: true
    attackVector?: true
    availabilityImpact?: true
    baseScore?: true
    baseSeverity?: true
    confidentialityImpact?: true
    integrityImpact?: true
    privilegesRequired?: true
    scope?: true
    userInteraction?: true
    vectorString?: true
    version?: true
    scoreId?: true
  }

  export type Redhat_Vulnerability_CvssV3CountAggregateInputType = {
    id?: true
    attackComplexity?: true
    attackVector?: true
    availabilityImpact?: true
    baseScore?: true
    baseSeverity?: true
    confidentialityImpact?: true
    integrityImpact?: true
    privilegesRequired?: true
    scope?: true
    userInteraction?: true
    vectorString?: true
    version?: true
    scoreId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_CvssV3AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_CvssV3 to aggregate.
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_CvssV3s to fetch.
     */
    orderBy?: Redhat_Vulnerability_CvssV3OrderByWithRelationInput | Redhat_Vulnerability_CvssV3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_CvssV3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_CvssV3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_CvssV3s
    **/
    _count?: true | Redhat_Vulnerability_CvssV3CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Redhat_Vulnerability_CvssV3AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Redhat_Vulnerability_CvssV3SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_CvssV3MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_CvssV3MaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_CvssV3AggregateType<T extends Redhat_Vulnerability_CvssV3AggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_CvssV3]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_CvssV3[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_CvssV3[P]>
  }




  export type Redhat_Vulnerability_CvssV3GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_CvssV3WhereInput
    orderBy?: Redhat_Vulnerability_CvssV3OrderByWithAggregationInput | Redhat_Vulnerability_CvssV3OrderByWithAggregationInput[]
    by: Redhat_Vulnerability_CvssV3ScalarFieldEnum[] | Redhat_Vulnerability_CvssV3ScalarFieldEnum
    having?: Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_CvssV3CountAggregateInputType | true
    _avg?: Redhat_Vulnerability_CvssV3AvgAggregateInputType
    _sum?: Redhat_Vulnerability_CvssV3SumAggregateInputType
    _min?: Redhat_Vulnerability_CvssV3MinAggregateInputType
    _max?: Redhat_Vulnerability_CvssV3MaxAggregateInputType
  }

  export type Redhat_Vulnerability_CvssV3GroupByOutputType = {
    id: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
    scoreId: string
    _count: Redhat_Vulnerability_CvssV3CountAggregateOutputType | null
    _avg: Redhat_Vulnerability_CvssV3AvgAggregateOutputType | null
    _sum: Redhat_Vulnerability_CvssV3SumAggregateOutputType | null
    _min: Redhat_Vulnerability_CvssV3MinAggregateOutputType | null
    _max: Redhat_Vulnerability_CvssV3MaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_CvssV3GroupByPayload<T extends Redhat_Vulnerability_CvssV3GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_CvssV3GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_CvssV3GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_CvssV3GroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_CvssV3GroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_CvssV3Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    attackComplexity?: boolean
    attackVector?: boolean
    availabilityImpact?: boolean
    baseScore?: boolean
    baseSeverity?: boolean
    confidentialityImpact?: boolean
    integrityImpact?: boolean
    privilegesRequired?: boolean
    scope?: boolean
    userInteraction?: boolean
    vectorString?: boolean
    version?: boolean
    scoreId?: boolean
    score?: boolean | Redhat_Vulnerability_CvssV3$scoreArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_CvssV3"]>

  export type Redhat_Vulnerability_CvssV3SelectScalar = {
    id?: boolean
    attackComplexity?: boolean
    attackVector?: boolean
    availabilityImpact?: boolean
    baseScore?: boolean
    baseSeverity?: boolean
    confidentialityImpact?: boolean
    integrityImpact?: boolean
    privilegesRequired?: boolean
    scope?: boolean
    userInteraction?: boolean
    vectorString?: boolean
    version?: boolean
    scoreId?: boolean
  }

  export type Redhat_Vulnerability_CvssV3Include<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    score?: boolean | Redhat_Vulnerability_CvssV3$scoreArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_CvssV3Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_CvssV3"
    objects: {
      score: Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      attackComplexity: string
      attackVector: string
      availabilityImpact: string
      baseScore: number
      baseSeverity: string
      confidentialityImpact: string
      integrityImpact: string
      privilegesRequired: string
      scope: string
      userInteraction: string
      vectorString: string
      version: string
      scoreId: string
    }, ExtArgs["result"]["redhat_Vulnerability_CvssV3"]>
    composites: {}
  }


  type Redhat_Vulnerability_CvssV3GetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_CvssV3DefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload, S>

  type Redhat_Vulnerability_CvssV3CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_CvssV3FindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_CvssV3CountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_CvssV3Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_CvssV3'], meta: { name: 'Redhat_Vulnerability_CvssV3' } }
    /**
     * Find zero or one Redhat_Vulnerability_CvssV3 that matches the filter.
     * @param {Redhat_Vulnerability_CvssV3FindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_CvssV3
     * @example
     * // Get one Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_CvssV3FindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3FindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_CvssV3 that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_CvssV3FindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_CvssV3
     * @example
     * // Get one Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_CvssV3FindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3FindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_CvssV3 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3FindFirstArgs} args - Arguments to find a Redhat_Vulnerability_CvssV3
     * @example
     * // Get one Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_CvssV3FindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3FindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_CvssV3 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3FindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_CvssV3
     * @example
     * // Get one Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_CvssV3FindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3FindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_CvssV3s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_CvssV3s
     * const redhat_Vulnerability_CvssV3s = await prisma.redhat_Vulnerability_CvssV3.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_CvssV3s
     * const redhat_Vulnerability_CvssV3s = await prisma.redhat_Vulnerability_CvssV3.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_CvssV3WithIdOnly = await prisma.redhat_Vulnerability_CvssV3.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_CvssV3FindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3FindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_CvssV3.
     * @param {Redhat_Vulnerability_CvssV3CreateArgs} args - Arguments to create a Redhat_Vulnerability_CvssV3.
     * @example
     * // Create one Redhat_Vulnerability_CvssV3
     * const Redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_CvssV3
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_CvssV3CreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3CreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_CvssV3s.
     *     @param {Redhat_Vulnerability_CvssV3CreateManyArgs} args - Arguments to create many Redhat_Vulnerability_CvssV3s.
     *     @example
     *     // Create many Redhat_Vulnerability_CvssV3s
     *     const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_CvssV3CreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3CreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_CvssV3.
     * @param {Redhat_Vulnerability_CvssV3DeleteArgs} args - Arguments to delete one Redhat_Vulnerability_CvssV3.
     * @example
     * // Delete one Redhat_Vulnerability_CvssV3
     * const Redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_CvssV3
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_CvssV3DeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3DeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_CvssV3.
     * @param {Redhat_Vulnerability_CvssV3UpdateArgs} args - Arguments to update one Redhat_Vulnerability_CvssV3.
     * @example
     * // Update one Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_CvssV3UpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3UpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_CvssV3s.
     * @param {Redhat_Vulnerability_CvssV3DeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_CvssV3s to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_CvssV3s
     * const { count } = await prisma.redhat_Vulnerability_CvssV3.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_CvssV3DeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CvssV3DeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_CvssV3s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_CvssV3s
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_CvssV3UpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3UpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_CvssV3.
     * @param {Redhat_Vulnerability_CvssV3UpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_CvssV3.
     * @example
     * // Update or create a Redhat_Vulnerability_CvssV3
     * const redhat_Vulnerability_CvssV3 = await prisma.redhat_Vulnerability_CvssV3.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_CvssV3
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_CvssV3 we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_CvssV3UpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CvssV3UpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CvssV3Client<$Result.GetResult<Prisma.$Redhat_Vulnerability_CvssV3Payload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_CvssV3s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3CountArgs} args - Arguments to filter Redhat_Vulnerability_CvssV3s to count.
     * @example
     * // Count the number of Redhat_Vulnerability_CvssV3s
     * const count = await prisma.redhat_Vulnerability_CvssV3.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_CvssV3s we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_CvssV3CountArgs>(
      args?: Subset<T, Redhat_Vulnerability_CvssV3CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_CvssV3CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_CvssV3.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_CvssV3AggregateArgs>(args: Subset<T, Redhat_Vulnerability_CvssV3AggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_CvssV3AggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_CvssV3.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CvssV3GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_CvssV3GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_CvssV3GroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_CvssV3GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_CvssV3GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_CvssV3GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_CvssV3 model
   */
  readonly fields: Redhat_Vulnerability_CvssV3FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_CvssV3.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_CvssV3Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    score<T extends Redhat_Vulnerability_CvssV3$scoreArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_CvssV3$scoreArgs<ExtArgs>>): Prisma__Redhat_Vulnerability_ScoreClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ScorePayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_CvssV3 model
   */ 
  interface Redhat_Vulnerability_CvssV3FieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly attackComplexity: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly attackVector: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly availabilityImpact: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly baseScore: FieldRef<"Redhat_Vulnerability_CvssV3", 'Int'>
    readonly baseSeverity: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly confidentialityImpact: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly integrityImpact: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly privilegesRequired: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly scope: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly userInteraction: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly vectorString: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly version: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
    readonly scoreId: FieldRef<"Redhat_Vulnerability_CvssV3", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_CvssV3 findUnique
   */
  export type Redhat_Vulnerability_CvssV3FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_CvssV3 to fetch.
     */
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 findUniqueOrThrow
   */
  export type Redhat_Vulnerability_CvssV3FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_CvssV3 to fetch.
     */
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 findFirst
   */
  export type Redhat_Vulnerability_CvssV3FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_CvssV3 to fetch.
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_CvssV3s to fetch.
     */
    orderBy?: Redhat_Vulnerability_CvssV3OrderByWithRelationInput | Redhat_Vulnerability_CvssV3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_CvssV3s.
     */
    cursor?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_CvssV3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_CvssV3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_CvssV3s.
     */
    distinct?: Redhat_Vulnerability_CvssV3ScalarFieldEnum | Redhat_Vulnerability_CvssV3ScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_CvssV3 findFirstOrThrow
   */
  export type Redhat_Vulnerability_CvssV3FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_CvssV3 to fetch.
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_CvssV3s to fetch.
     */
    orderBy?: Redhat_Vulnerability_CvssV3OrderByWithRelationInput | Redhat_Vulnerability_CvssV3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_CvssV3s.
     */
    cursor?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_CvssV3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_CvssV3s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_CvssV3s.
     */
    distinct?: Redhat_Vulnerability_CvssV3ScalarFieldEnum | Redhat_Vulnerability_CvssV3ScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_CvssV3 findMany
   */
  export type Redhat_Vulnerability_CvssV3FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_CvssV3s to fetch.
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_CvssV3s to fetch.
     */
    orderBy?: Redhat_Vulnerability_CvssV3OrderByWithRelationInput | Redhat_Vulnerability_CvssV3OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_CvssV3s.
     */
    cursor?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_CvssV3s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_CvssV3s.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_CvssV3ScalarFieldEnum | Redhat_Vulnerability_CvssV3ScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_CvssV3 create
   */
  export type Redhat_Vulnerability_CvssV3CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_CvssV3.
     */
    data: XOR<Redhat_Vulnerability_CvssV3CreateInput, Redhat_Vulnerability_CvssV3UncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_CvssV3 createMany
   */
  export type Redhat_Vulnerability_CvssV3CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_CvssV3s.
     */
    data: Redhat_Vulnerability_CvssV3CreateManyInput | Redhat_Vulnerability_CvssV3CreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_CvssV3 update
   */
  export type Redhat_Vulnerability_CvssV3UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_CvssV3.
     */
    data: XOR<Redhat_Vulnerability_CvssV3UpdateInput, Redhat_Vulnerability_CvssV3UncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_CvssV3 to update.
     */
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 updateMany
   */
  export type Redhat_Vulnerability_CvssV3UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_CvssV3s.
     */
    data: XOR<Redhat_Vulnerability_CvssV3UpdateManyMutationInput, Redhat_Vulnerability_CvssV3UncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_CvssV3s to update
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 upsert
   */
  export type Redhat_Vulnerability_CvssV3UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_CvssV3 to update in case it exists.
     */
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_CvssV3 found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_CvssV3 with this data.
     */
    create: XOR<Redhat_Vulnerability_CvssV3CreateInput, Redhat_Vulnerability_CvssV3UncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_CvssV3 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_CvssV3UpdateInput, Redhat_Vulnerability_CvssV3UncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_CvssV3 delete
   */
  export type Redhat_Vulnerability_CvssV3DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_CvssV3 to delete.
     */
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 deleteMany
   */
  export type Redhat_Vulnerability_CvssV3DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_CvssV3s to delete
     */
    where?: Redhat_Vulnerability_CvssV3WhereInput
  }


  /**
   * Redhat_Vulnerability_CvssV3.score
   */
  export type Redhat_Vulnerability_CvssV3$scoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Score
     */
    select?: Redhat_Vulnerability_ScoreSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ScoreInclude<ExtArgs> | null
    where?: Redhat_Vulnerability_ScoreWhereInput
  }


  /**
   * Redhat_Vulnerability_CvssV3 without action
   */
  export type Redhat_Vulnerability_CvssV3DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_CvssV3
     */
    select?: Redhat_Vulnerability_CvssV3Select<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CvssV3Include<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Threat
   */

  export type AggregateRedhat_Vulnerability_Threat = {
    _count: Redhat_Vulnerability_ThreatCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ThreatMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ThreatMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_ThreatMinAggregateOutputType = {
    id: string | null
    category: string | null
    details: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ThreatMaxAggregateOutputType = {
    id: string | null
    category: string | null
    details: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_ThreatCountAggregateOutputType = {
    id: number
    category: number
    details: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_ThreatMinAggregateInputType = {
    id?: true
    category?: true
    details?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ThreatMaxAggregateInputType = {
    id?: true
    category?: true
    details?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_ThreatCountAggregateInputType = {
    id?: true
    category?: true
    details?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_ThreatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Threat to aggregate.
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Threats to fetch.
     */
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithRelationInput | Redhat_Vulnerability_ThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_ThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Threats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Threats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Threats
    **/
    _count?: true | Redhat_Vulnerability_ThreatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_ThreatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_ThreatMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_ThreatAggregateType<T extends Redhat_Vulnerability_ThreatAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Threat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Threat[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Threat[P]>
  }




  export type Redhat_Vulnerability_ThreatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_ThreatWhereInput
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithAggregationInput | Redhat_Vulnerability_ThreatOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_ThreatScalarFieldEnum[] | Redhat_Vulnerability_ThreatScalarFieldEnum
    having?: Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_ThreatCountAggregateInputType | true
    _min?: Redhat_Vulnerability_ThreatMinAggregateInputType
    _max?: Redhat_Vulnerability_ThreatMaxAggregateInputType
  }

  export type Redhat_Vulnerability_ThreatGroupByOutputType = {
    id: string
    category: string
    details: string
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_ThreatCountAggregateOutputType | null
    _min: Redhat_Vulnerability_ThreatMinAggregateOutputType | null
    _max: Redhat_Vulnerability_ThreatMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_ThreatGroupByPayload<T extends Redhat_Vulnerability_ThreatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_ThreatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_ThreatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_ThreatGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_ThreatGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_ThreatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    details?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Threat$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Threat"]>

  export type Redhat_Vulnerability_ThreatSelectScalar = {
    id?: boolean
    category?: boolean
    details?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_ThreatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Threat$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_ThreatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Threat"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      details: string
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_Threat"]>
    composites: {}
  }


  type Redhat_Vulnerability_ThreatGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_ThreatDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload, S>

  type Redhat_Vulnerability_ThreatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_ThreatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_ThreatCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_ThreatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Threat'], meta: { name: 'Redhat_Vulnerability_Threat' } }
    /**
     * Find zero or one Redhat_Vulnerability_Threat that matches the filter.
     * @param {Redhat_Vulnerability_ThreatFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Threat
     * @example
     * // Get one Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_ThreatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Threat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_ThreatFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Threat
     * @example
     * // Get one Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_ThreatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Threat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Threat
     * @example
     * // Get one Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_ThreatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Threat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Threat
     * @example
     * // Get one Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_ThreatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Threats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Threats
     * const redhat_Vulnerability_Threats = await prisma.redhat_Vulnerability_Threat.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Threats
     * const redhat_Vulnerability_Threats = await prisma.redhat_Vulnerability_Threat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_ThreatWithIdOnly = await prisma.redhat_Vulnerability_Threat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_ThreatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Threat.
     * @param {Redhat_Vulnerability_ThreatCreateArgs} args - Arguments to create a Redhat_Vulnerability_Threat.
     * @example
     * // Create one Redhat_Vulnerability_Threat
     * const Redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Threat
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_ThreatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Threats.
     *     @param {Redhat_Vulnerability_ThreatCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Threats.
     *     @example
     *     // Create many Redhat_Vulnerability_Threats
     *     const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_ThreatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Threat.
     * @param {Redhat_Vulnerability_ThreatDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Threat.
     * @example
     * // Delete one Redhat_Vulnerability_Threat
     * const Redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Threat
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_ThreatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Threat.
     * @param {Redhat_Vulnerability_ThreatUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Threat.
     * @example
     * // Update one Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_ThreatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Threats.
     * @param {Redhat_Vulnerability_ThreatDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Threats to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Threats
     * const { count } = await prisma.redhat_Vulnerability_Threat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_ThreatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_ThreatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Threats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Threats
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_ThreatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Threat.
     * @param {Redhat_Vulnerability_ThreatUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Threat.
     * @example
     * // Update or create a Redhat_Vulnerability_Threat
     * const redhat_Vulnerability_Threat = await prisma.redhat_Vulnerability_Threat.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Threat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Threat we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_ThreatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_ThreatUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_ThreatClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_ThreatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Threats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatCountArgs} args - Arguments to filter Redhat_Vulnerability_Threats to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Threats
     * const count = await prisma.redhat_Vulnerability_Threat.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Threats we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_ThreatCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_ThreatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_ThreatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Threat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_ThreatAggregateArgs>(args: Subset<T, Redhat_Vulnerability_ThreatAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_ThreatAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Threat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_ThreatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_ThreatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_ThreatGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_ThreatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_ThreatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_ThreatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Threat model
   */
  readonly fields: Redhat_Vulnerability_ThreatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Threat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_ThreatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Threat$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Threat$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Threat model
   */ 
  interface Redhat_Vulnerability_ThreatFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Threat", 'String'>
    readonly category: FieldRef<"Redhat_Vulnerability_Threat", 'String'>
    readonly details: FieldRef<"Redhat_Vulnerability_Threat", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Threat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Threat findUnique
   */
  export type Redhat_Vulnerability_ThreatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Threat to fetch.
     */
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Threat findUniqueOrThrow
   */
  export type Redhat_Vulnerability_ThreatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Threat to fetch.
     */
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Threat findFirst
   */
  export type Redhat_Vulnerability_ThreatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Threat to fetch.
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Threats to fetch.
     */
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithRelationInput | Redhat_Vulnerability_ThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Threats.
     */
    cursor?: Redhat_Vulnerability_ThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Threats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Threats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Threats.
     */
    distinct?: Redhat_Vulnerability_ThreatScalarFieldEnum | Redhat_Vulnerability_ThreatScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Threat findFirstOrThrow
   */
  export type Redhat_Vulnerability_ThreatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Threat to fetch.
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Threats to fetch.
     */
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithRelationInput | Redhat_Vulnerability_ThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Threats.
     */
    cursor?: Redhat_Vulnerability_ThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Threats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Threats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Threats.
     */
    distinct?: Redhat_Vulnerability_ThreatScalarFieldEnum | Redhat_Vulnerability_ThreatScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Threat findMany
   */
  export type Redhat_Vulnerability_ThreatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Threats to fetch.
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Threats to fetch.
     */
    orderBy?: Redhat_Vulnerability_ThreatOrderByWithRelationInput | Redhat_Vulnerability_ThreatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Threats.
     */
    cursor?: Redhat_Vulnerability_ThreatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Threats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Threats.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_ThreatScalarFieldEnum | Redhat_Vulnerability_ThreatScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Threat create
   */
  export type Redhat_Vulnerability_ThreatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Threat.
     */
    data: XOR<Redhat_Vulnerability_ThreatCreateInput, Redhat_Vulnerability_ThreatUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Threat createMany
   */
  export type Redhat_Vulnerability_ThreatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Threats.
     */
    data: Redhat_Vulnerability_ThreatCreateManyInput | Redhat_Vulnerability_ThreatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Threat update
   */
  export type Redhat_Vulnerability_ThreatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Threat.
     */
    data: XOR<Redhat_Vulnerability_ThreatUpdateInput, Redhat_Vulnerability_ThreatUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Threat to update.
     */
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Threat updateMany
   */
  export type Redhat_Vulnerability_ThreatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Threats.
     */
    data: XOR<Redhat_Vulnerability_ThreatUpdateManyMutationInput, Redhat_Vulnerability_ThreatUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Threats to update
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
  }


  /**
   * Redhat_Vulnerability_Threat upsert
   */
  export type Redhat_Vulnerability_ThreatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Threat to update in case it exists.
     */
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Threat found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Threat with this data.
     */
    create: XOR<Redhat_Vulnerability_ThreatCreateInput, Redhat_Vulnerability_ThreatUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Threat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_ThreatUpdateInput, Redhat_Vulnerability_ThreatUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Threat delete
   */
  export type Redhat_Vulnerability_ThreatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Threat to delete.
     */
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Threat deleteMany
   */
  export type Redhat_Vulnerability_ThreatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Threats to delete
     */
    where?: Redhat_Vulnerability_ThreatWhereInput
  }


  /**
   * Redhat_Vulnerability_Threat.vulnerability
   */
  export type Redhat_Vulnerability_Threat$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Threat without action
   */
  export type Redhat_Vulnerability_ThreatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Threat
     */
    select?: Redhat_Vulnerability_ThreatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_ThreatInclude<ExtArgs> | null
  }



  /**
   * Model Redhat_Vulnerability_Cwe
   */

  export type AggregateRedhat_Vulnerability_Cwe = {
    _count: Redhat_Vulnerability_CweCountAggregateOutputType | null
    _min: Redhat_Vulnerability_CweMinAggregateOutputType | null
    _max: Redhat_Vulnerability_CweMaxAggregateOutputType | null
  }

  export type Redhat_Vulnerability_CweMinAggregateOutputType = {
    id: string | null
    cweId: string | null
    name: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_CweMaxAggregateOutputType = {
    id: string | null
    cweId: string | null
    name: string | null
    vulnerabilityId: string | null
  }

  export type Redhat_Vulnerability_CweCountAggregateOutputType = {
    id: number
    cweId: number
    name: number
    vulnerabilityId: number
    _all: number
  }


  export type Redhat_Vulnerability_CweMinAggregateInputType = {
    id?: true
    cweId?: true
    name?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_CweMaxAggregateInputType = {
    id?: true
    cweId?: true
    name?: true
    vulnerabilityId?: true
  }

  export type Redhat_Vulnerability_CweCountAggregateInputType = {
    id?: true
    cweId?: true
    name?: true
    vulnerabilityId?: true
    _all?: true
  }

  export type Redhat_Vulnerability_CweAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Cwe to aggregate.
     */
    where?: Redhat_Vulnerability_CweWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Cwes to fetch.
     */
    orderBy?: Redhat_Vulnerability_CweOrderByWithRelationInput | Redhat_Vulnerability_CweOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Redhat_Vulnerability_CweWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Cwes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Cwes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Redhat_Vulnerability_Cwes
    **/
    _count?: true | Redhat_Vulnerability_CweCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Redhat_Vulnerability_CweMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Redhat_Vulnerability_CweMaxAggregateInputType
  }

  export type GetRedhat_Vulnerability_CweAggregateType<T extends Redhat_Vulnerability_CweAggregateArgs> = {
        [P in keyof T & keyof AggregateRedhat_Vulnerability_Cwe]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRedhat_Vulnerability_Cwe[P]>
      : GetScalarType<T[P], AggregateRedhat_Vulnerability_Cwe[P]>
  }




  export type Redhat_Vulnerability_CweGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Redhat_Vulnerability_CweWhereInput
    orderBy?: Redhat_Vulnerability_CweOrderByWithAggregationInput | Redhat_Vulnerability_CweOrderByWithAggregationInput[]
    by: Redhat_Vulnerability_CweScalarFieldEnum[] | Redhat_Vulnerability_CweScalarFieldEnum
    having?: Redhat_Vulnerability_CweScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Redhat_Vulnerability_CweCountAggregateInputType | true
    _min?: Redhat_Vulnerability_CweMinAggregateInputType
    _max?: Redhat_Vulnerability_CweMaxAggregateInputType
  }

  export type Redhat_Vulnerability_CweGroupByOutputType = {
    id: string
    cweId: string
    name: string
    vulnerabilityId: string | null
    _count: Redhat_Vulnerability_CweCountAggregateOutputType | null
    _min: Redhat_Vulnerability_CweMinAggregateOutputType | null
    _max: Redhat_Vulnerability_CweMaxAggregateOutputType | null
  }

  type GetRedhat_Vulnerability_CweGroupByPayload<T extends Redhat_Vulnerability_CweGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Redhat_Vulnerability_CweGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Redhat_Vulnerability_CweGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Redhat_Vulnerability_CweGroupByOutputType[P]>
            : GetScalarType<T[P], Redhat_Vulnerability_CweGroupByOutputType[P]>
        }
      >
    >


  export type Redhat_Vulnerability_CweSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cweId?: boolean
    name?: boolean
    vulnerabilityId?: boolean
    vulnerability?: boolean | Redhat_Vulnerability_Cwe$vulnerabilityArgs<ExtArgs>
  }, ExtArgs["result"]["redhat_Vulnerability_Cwe"]>

  export type Redhat_Vulnerability_CweSelectScalar = {
    id?: boolean
    cweId?: boolean
    name?: boolean
    vulnerabilityId?: boolean
  }

  export type Redhat_Vulnerability_CweInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vulnerability?: boolean | Redhat_Vulnerability_Cwe$vulnerabilityArgs<ExtArgs>
  }


  export type $Redhat_Vulnerability_CwePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Redhat_Vulnerability_Cwe"
    objects: {
      vulnerability: Prisma.$Redhat_VulnerabilityPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cweId: string
      name: string
      vulnerabilityId: string | null
    }, ExtArgs["result"]["redhat_Vulnerability_Cwe"]>
    composites: {}
  }


  type Redhat_Vulnerability_CweGetPayload<S extends boolean | null | undefined | Redhat_Vulnerability_CweDefaultArgs> = $Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload, S>

  type Redhat_Vulnerability_CweCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Redhat_Vulnerability_CweFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Redhat_Vulnerability_CweCountAggregateInputType | true
    }

  export interface Redhat_Vulnerability_CweDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Redhat_Vulnerability_Cwe'], meta: { name: 'Redhat_Vulnerability_Cwe' } }
    /**
     * Find zero or one Redhat_Vulnerability_Cwe that matches the filter.
     * @param {Redhat_Vulnerability_CweFindUniqueArgs} args - Arguments to find a Redhat_Vulnerability_Cwe
     * @example
     * // Get one Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Redhat_Vulnerability_CweFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweFindUniqueArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Redhat_Vulnerability_Cwe that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Redhat_Vulnerability_CweFindUniqueOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Cwe
     * @example
     * // Get one Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Redhat_Vulnerability_CweFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Cwe that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweFindFirstArgs} args - Arguments to find a Redhat_Vulnerability_Cwe
     * @example
     * // Get one Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Redhat_Vulnerability_CweFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweFindFirstArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Redhat_Vulnerability_Cwe that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweFindFirstOrThrowArgs} args - Arguments to find a Redhat_Vulnerability_Cwe
     * @example
     * // Get one Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Redhat_Vulnerability_CweFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Redhat_Vulnerability_Cwes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Redhat_Vulnerability_Cwes
     * const redhat_Vulnerability_Cwes = await prisma.redhat_Vulnerability_Cwe.findMany()
     * 
     * // Get first 10 Redhat_Vulnerability_Cwes
     * const redhat_Vulnerability_Cwes = await prisma.redhat_Vulnerability_Cwe.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const redhat_Vulnerability_CweWithIdOnly = await prisma.redhat_Vulnerability_Cwe.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Redhat_Vulnerability_CweFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Redhat_Vulnerability_Cwe.
     * @param {Redhat_Vulnerability_CweCreateArgs} args - Arguments to create a Redhat_Vulnerability_Cwe.
     * @example
     * // Create one Redhat_Vulnerability_Cwe
     * const Redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.create({
     *   data: {
     *     // ... data to create a Redhat_Vulnerability_Cwe
     *   }
     * })
     * 
    **/
    create<T extends Redhat_Vulnerability_CweCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweCreateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Redhat_Vulnerability_Cwes.
     *     @param {Redhat_Vulnerability_CweCreateManyArgs} args - Arguments to create many Redhat_Vulnerability_Cwes.
     *     @example
     *     // Create many Redhat_Vulnerability_Cwes
     *     const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Redhat_Vulnerability_CweCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Redhat_Vulnerability_Cwe.
     * @param {Redhat_Vulnerability_CweDeleteArgs} args - Arguments to delete one Redhat_Vulnerability_Cwe.
     * @example
     * // Delete one Redhat_Vulnerability_Cwe
     * const Redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.delete({
     *   where: {
     *     // ... filter to delete one Redhat_Vulnerability_Cwe
     *   }
     * })
     * 
    **/
    delete<T extends Redhat_Vulnerability_CweDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweDeleteArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Redhat_Vulnerability_Cwe.
     * @param {Redhat_Vulnerability_CweUpdateArgs} args - Arguments to update one Redhat_Vulnerability_Cwe.
     * @example
     * // Update one Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Redhat_Vulnerability_CweUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweUpdateArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Redhat_Vulnerability_Cwes.
     * @param {Redhat_Vulnerability_CweDeleteManyArgs} args - Arguments to filter Redhat_Vulnerability_Cwes to delete.
     * @example
     * // Delete a few Redhat_Vulnerability_Cwes
     * const { count } = await prisma.redhat_Vulnerability_Cwe.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Redhat_Vulnerability_CweDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Redhat_Vulnerability_CweDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Redhat_Vulnerability_Cwes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Redhat_Vulnerability_Cwes
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Redhat_Vulnerability_CweUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Redhat_Vulnerability_Cwe.
     * @param {Redhat_Vulnerability_CweUpsertArgs} args - Arguments to update or create a Redhat_Vulnerability_Cwe.
     * @example
     * // Update or create a Redhat_Vulnerability_Cwe
     * const redhat_Vulnerability_Cwe = await prisma.redhat_Vulnerability_Cwe.upsert({
     *   create: {
     *     // ... data to create a Redhat_Vulnerability_Cwe
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Cwe we want to update
     *   }
     * })
    **/
    upsert<T extends Redhat_Vulnerability_CweUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Redhat_Vulnerability_CweUpsertArgs<ExtArgs>>
    ): Prisma__Redhat_Vulnerability_CweClient<$Result.GetResult<Prisma.$Redhat_Vulnerability_CwePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Redhat_Vulnerability_Cwes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweCountArgs} args - Arguments to filter Redhat_Vulnerability_Cwes to count.
     * @example
     * // Count the number of Redhat_Vulnerability_Cwes
     * const count = await prisma.redhat_Vulnerability_Cwe.count({
     *   where: {
     *     // ... the filter for the Redhat_Vulnerability_Cwes we want to count
     *   }
     * })
    **/
    count<T extends Redhat_Vulnerability_CweCountArgs>(
      args?: Subset<T, Redhat_Vulnerability_CweCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Redhat_Vulnerability_CweCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Redhat_Vulnerability_Cwe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Redhat_Vulnerability_CweAggregateArgs>(args: Subset<T, Redhat_Vulnerability_CweAggregateArgs>): Prisma.PrismaPromise<GetRedhat_Vulnerability_CweAggregateType<T>>

    /**
     * Group by Redhat_Vulnerability_Cwe.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Redhat_Vulnerability_CweGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Redhat_Vulnerability_CweGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Redhat_Vulnerability_CweGroupByArgs['orderBy'] }
        : { orderBy?: Redhat_Vulnerability_CweGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Redhat_Vulnerability_CweGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRedhat_Vulnerability_CweGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Redhat_Vulnerability_Cwe model
   */
  readonly fields: Redhat_Vulnerability_CweFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Redhat_Vulnerability_Cwe.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Redhat_Vulnerability_CweClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    vulnerability<T extends Redhat_Vulnerability_Cwe$vulnerabilityArgs<ExtArgs> = {}>(args?: Subset<T, Redhat_Vulnerability_Cwe$vulnerabilityArgs<ExtArgs>>): Prisma__Redhat_VulnerabilityClient<$Result.GetResult<Prisma.$Redhat_VulnerabilityPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Redhat_Vulnerability_Cwe model
   */ 
  interface Redhat_Vulnerability_CweFieldRefs {
    readonly id: FieldRef<"Redhat_Vulnerability_Cwe", 'String'>
    readonly cweId: FieldRef<"Redhat_Vulnerability_Cwe", 'String'>
    readonly name: FieldRef<"Redhat_Vulnerability_Cwe", 'String'>
    readonly vulnerabilityId: FieldRef<"Redhat_Vulnerability_Cwe", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Redhat_Vulnerability_Cwe findUnique
   */
  export type Redhat_Vulnerability_CweFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Cwe to fetch.
     */
    where: Redhat_Vulnerability_CweWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Cwe findUniqueOrThrow
   */
  export type Redhat_Vulnerability_CweFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Cwe to fetch.
     */
    where: Redhat_Vulnerability_CweWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Cwe findFirst
   */
  export type Redhat_Vulnerability_CweFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Cwe to fetch.
     */
    where?: Redhat_Vulnerability_CweWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Cwes to fetch.
     */
    orderBy?: Redhat_Vulnerability_CweOrderByWithRelationInput | Redhat_Vulnerability_CweOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Cwes.
     */
    cursor?: Redhat_Vulnerability_CweWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Cwes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Cwes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Cwes.
     */
    distinct?: Redhat_Vulnerability_CweScalarFieldEnum | Redhat_Vulnerability_CweScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Cwe findFirstOrThrow
   */
  export type Redhat_Vulnerability_CweFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Cwe to fetch.
     */
    where?: Redhat_Vulnerability_CweWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Cwes to fetch.
     */
    orderBy?: Redhat_Vulnerability_CweOrderByWithRelationInput | Redhat_Vulnerability_CweOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Redhat_Vulnerability_Cwes.
     */
    cursor?: Redhat_Vulnerability_CweWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Cwes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Cwes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Redhat_Vulnerability_Cwes.
     */
    distinct?: Redhat_Vulnerability_CweScalarFieldEnum | Redhat_Vulnerability_CweScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Cwe findMany
   */
  export type Redhat_Vulnerability_CweFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter, which Redhat_Vulnerability_Cwes to fetch.
     */
    where?: Redhat_Vulnerability_CweWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Redhat_Vulnerability_Cwes to fetch.
     */
    orderBy?: Redhat_Vulnerability_CweOrderByWithRelationInput | Redhat_Vulnerability_CweOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Redhat_Vulnerability_Cwes.
     */
    cursor?: Redhat_Vulnerability_CweWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Redhat_Vulnerability_Cwes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Redhat_Vulnerability_Cwes.
     */
    skip?: number
    distinct?: Redhat_Vulnerability_CweScalarFieldEnum | Redhat_Vulnerability_CweScalarFieldEnum[]
  }


  /**
   * Redhat_Vulnerability_Cwe create
   */
  export type Redhat_Vulnerability_CweCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * The data needed to create a Redhat_Vulnerability_Cwe.
     */
    data: XOR<Redhat_Vulnerability_CweCreateInput, Redhat_Vulnerability_CweUncheckedCreateInput>
  }


  /**
   * Redhat_Vulnerability_Cwe createMany
   */
  export type Redhat_Vulnerability_CweCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Redhat_Vulnerability_Cwes.
     */
    data: Redhat_Vulnerability_CweCreateManyInput | Redhat_Vulnerability_CweCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Redhat_Vulnerability_Cwe update
   */
  export type Redhat_Vulnerability_CweUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * The data needed to update a Redhat_Vulnerability_Cwe.
     */
    data: XOR<Redhat_Vulnerability_CweUpdateInput, Redhat_Vulnerability_CweUncheckedUpdateInput>
    /**
     * Choose, which Redhat_Vulnerability_Cwe to update.
     */
    where: Redhat_Vulnerability_CweWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Cwe updateMany
   */
  export type Redhat_Vulnerability_CweUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Redhat_Vulnerability_Cwes.
     */
    data: XOR<Redhat_Vulnerability_CweUpdateManyMutationInput, Redhat_Vulnerability_CweUncheckedUpdateManyInput>
    /**
     * Filter which Redhat_Vulnerability_Cwes to update
     */
    where?: Redhat_Vulnerability_CweWhereInput
  }


  /**
   * Redhat_Vulnerability_Cwe upsert
   */
  export type Redhat_Vulnerability_CweUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * The filter to search for the Redhat_Vulnerability_Cwe to update in case it exists.
     */
    where: Redhat_Vulnerability_CweWhereUniqueInput
    /**
     * In case the Redhat_Vulnerability_Cwe found by the `where` argument doesn't exist, create a new Redhat_Vulnerability_Cwe with this data.
     */
    create: XOR<Redhat_Vulnerability_CweCreateInput, Redhat_Vulnerability_CweUncheckedCreateInput>
    /**
     * In case the Redhat_Vulnerability_Cwe was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Redhat_Vulnerability_CweUpdateInput, Redhat_Vulnerability_CweUncheckedUpdateInput>
  }


  /**
   * Redhat_Vulnerability_Cwe delete
   */
  export type Redhat_Vulnerability_CweDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
    /**
     * Filter which Redhat_Vulnerability_Cwe to delete.
     */
    where: Redhat_Vulnerability_CweWhereUniqueInput
  }


  /**
   * Redhat_Vulnerability_Cwe deleteMany
   */
  export type Redhat_Vulnerability_CweDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Redhat_Vulnerability_Cwes to delete
     */
    where?: Redhat_Vulnerability_CweWhereInput
  }


  /**
   * Redhat_Vulnerability_Cwe.vulnerability
   */
  export type Redhat_Vulnerability_Cwe$vulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability
     */
    select?: Redhat_VulnerabilitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_VulnerabilityInclude<ExtArgs> | null
    where?: Redhat_VulnerabilityWhereInput
  }


  /**
   * Redhat_Vulnerability_Cwe without action
   */
  export type Redhat_Vulnerability_CweDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Redhat_Vulnerability_Cwe
     */
    select?: Redhat_Vulnerability_CweSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Redhat_Vulnerability_CweInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const VmwareScalarFieldEnum: {
    cve: 'cve',
    synopsis: 'synopsis',
    severity: 'severity',
    date: 'date',
    link: 'link',
    detail: 'detail'
  };

  export type VmwareScalarFieldEnum = (typeof VmwareScalarFieldEnum)[keyof typeof VmwareScalarFieldEnum]


  export const CiscoScalarFieldEnum: {
    id: 'id',
    link: 'link',
    title: 'title',
    impact: 'impact',
    version: 'version',
    last_updated: 'last_updated',
    clean_cves: 'clean_cves'
  };

  export type CiscoScalarFieldEnum = (typeof CiscoScalarFieldEnum)[keyof typeof CiscoScalarFieldEnum]


  export const OracleScalarFieldEnum: {
    id: 'id',
    affected_product: 'affected_product',
    affected_product_link: 'affected_product_link',
    patch_document: 'patch_document',
    patch_document_link: 'patch_document_link'
  };

  export type OracleScalarFieldEnum = (typeof OracleScalarFieldEnum)[keyof typeof OracleScalarFieldEnum]


  export const MicrosoftScalarFieldEnum: {
    cve: 'cve',
    release_date: 'release_date',
    revision_date: 'revision_date',
    cve_link: 'cve_link',
    cve_title: 'cve_title',
    impact: 'impact',
    severity: 'severity',
    tag: 'tag'
  };

  export type MicrosoftScalarFieldEnum = (typeof MicrosoftScalarFieldEnum)[keyof typeof MicrosoftScalarFieldEnum]


  export const HackernewsScalarFieldEnum: {
    title: 'title',
    link: 'link',
    img: 'img',
    date: 'date',
    description: 'description',
    detail: 'detail'
  };

  export type HackernewsScalarFieldEnum = (typeof HackernewsScalarFieldEnum)[keyof typeof HackernewsScalarFieldEnum]


  export const RedhatScalarFieldEnum: {
    id: 'id',
    RHSA: 'RHSA',
    severity: 'severity',
    released_on: 'released_on',
    CVEs: 'CVEs',
    bugzillas: 'bugzillas',
    released_packages: 'released_packages',
    resource_url: 'resource_url'
  };

  export type RedhatScalarFieldEnum = (typeof RedhatScalarFieldEnum)[keyof typeof RedhatScalarFieldEnum]


  export const Redhat_DocumentScalarFieldEnum: {
    id: 'id',
    category: 'category',
    csaf_version: 'csaf_version',
    lang: 'lang',
    title: 'title',
    redhatId: 'redhatId',
    aggregateSeverityId: 'aggregateSeverityId',
    distributionId: 'distributionId',
    publisherId: 'publisherId'
  };

  export type Redhat_DocumentScalarFieldEnum = (typeof Redhat_DocumentScalarFieldEnum)[keyof typeof Redhat_DocumentScalarFieldEnum]


  export const Redhat_TrackingScalarFieldEnum: {
    id: 'id',
    current_release_date: 'current_release_date',
    ID: 'ID',
    documentId: 'documentId'
  };

  export type Redhat_TrackingScalarFieldEnum = (typeof Redhat_TrackingScalarFieldEnum)[keyof typeof Redhat_TrackingScalarFieldEnum]


  export const Redhat_AggregateSeverityScalarFieldEnum: {
    id: 'id',
    namespace: 'namespace',
    text: 'text',
    documentId: 'documentId'
  };

  export type Redhat_AggregateSeverityScalarFieldEnum = (typeof Redhat_AggregateSeverityScalarFieldEnum)[keyof typeof Redhat_AggregateSeverityScalarFieldEnum]


  export const Redhat_DistributionScalarFieldEnum: {
    id: 'id',
    text: 'text',
    documentId: 'documentId',
    tlpId: 'tlpId'
  };

  export type Redhat_DistributionScalarFieldEnum = (typeof Redhat_DistributionScalarFieldEnum)[keyof typeof Redhat_DistributionScalarFieldEnum]


  export const Redhat_TlpScalarFieldEnum: {
    id: 'id',
    label: 'label',
    url: 'url',
    distributionId: 'distributionId'
  };

  export type Redhat_TlpScalarFieldEnum = (typeof Redhat_TlpScalarFieldEnum)[keyof typeof Redhat_TlpScalarFieldEnum]


  export const Redhat_Document_NoteScalarFieldEnum: {
    id: 'id',
    category: 'category',
    text: 'text',
    title: 'title',
    documentId: 'documentId'
  };

  export type Redhat_Document_NoteScalarFieldEnum = (typeof Redhat_Document_NoteScalarFieldEnum)[keyof typeof Redhat_Document_NoteScalarFieldEnum]


  export const Redhat_PublisherScalarFieldEnum: {
    id: 'id',
    category: 'category',
    contact_details: 'contact_details',
    issuing_authority: 'issuing_authority',
    name: 'name',
    namespace: 'namespace',
    documentId: 'documentId'
  };

  export type Redhat_PublisherScalarFieldEnum = (typeof Redhat_PublisherScalarFieldEnum)[keyof typeof Redhat_PublisherScalarFieldEnum]


  export const Redhat_Document_ReferenceScalarFieldEnum: {
    id: 'id',
    category: 'category',
    summary: 'summary',
    url: 'url',
    documentId: 'documentId'
  };

  export type Redhat_Document_ReferenceScalarFieldEnum = (typeof Redhat_Document_ReferenceScalarFieldEnum)[keyof typeof Redhat_Document_ReferenceScalarFieldEnum]


  export const Redhat_VulnerabilityScalarFieldEnum: {
    id: 'id',
    cve: 'cve',
    discovery_date: 'discovery_date',
    release_date: 'release_date',
    title: 'title',
    redhatId: 'redhatId'
  };

  export type Redhat_VulnerabilityScalarFieldEnum = (typeof Redhat_VulnerabilityScalarFieldEnum)[keyof typeof Redhat_VulnerabilityScalarFieldEnum]


  export const Redhat_Vulnerability_IdScalarFieldEnum: {
    id: 'id',
    system_name: 'system_name',
    text: 'text',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_IdScalarFieldEnum = (typeof Redhat_Vulnerability_IdScalarFieldEnum)[keyof typeof Redhat_Vulnerability_IdScalarFieldEnum]


  export const Redhat_Vulnerability_NoteScalarFieldEnum: {
    id: 'id',
    category: 'category',
    text: 'text',
    title: 'title',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_NoteScalarFieldEnum = (typeof Redhat_Vulnerability_NoteScalarFieldEnum)[keyof typeof Redhat_Vulnerability_NoteScalarFieldEnum]


  export const Redhat_Vulnerability_ProductStatusScalarFieldEnum: {
    id: 'id',
    fixed: 'fixed',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_ProductStatusScalarFieldEnum = (typeof Redhat_Vulnerability_ProductStatusScalarFieldEnum)[keyof typeof Redhat_Vulnerability_ProductStatusScalarFieldEnum]


  export const Redhat_Vulnerability_ReferenceScalarFieldEnum: {
    id: 'id',
    category: 'category',
    summary: 'summary',
    url: 'url',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_ReferenceScalarFieldEnum = (typeof Redhat_Vulnerability_ReferenceScalarFieldEnum)[keyof typeof Redhat_Vulnerability_ReferenceScalarFieldEnum]


  export const Redhat_Vulnerability_RemediationScalarFieldEnum: {
    id: 'id',
    category: 'category',
    details: 'details',
    product_ids: 'product_ids',
    url: 'url',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_RemediationScalarFieldEnum = (typeof Redhat_Vulnerability_RemediationScalarFieldEnum)[keyof typeof Redhat_Vulnerability_RemediationScalarFieldEnum]


  export const Redhat_Vulnerability_RestartRequiredScalarFieldEnum: {
    id: 'id',
    category: 'category',
    remediationId: 'remediationId'
  };

  export type Redhat_Vulnerability_RestartRequiredScalarFieldEnum = (typeof Redhat_Vulnerability_RestartRequiredScalarFieldEnum)[keyof typeof Redhat_Vulnerability_RestartRequiredScalarFieldEnum]


  export const Redhat_Vulnerability_ScoreScalarFieldEnum: {
    id: 'id',
    products: 'products',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_ScoreScalarFieldEnum = (typeof Redhat_Vulnerability_ScoreScalarFieldEnum)[keyof typeof Redhat_Vulnerability_ScoreScalarFieldEnum]


  export const Redhat_Vulnerability_CvssV3ScalarFieldEnum: {
    id: 'id',
    attackComplexity: 'attackComplexity',
    attackVector: 'attackVector',
    availabilityImpact: 'availabilityImpact',
    baseScore: 'baseScore',
    baseSeverity: 'baseSeverity',
    confidentialityImpact: 'confidentialityImpact',
    integrityImpact: 'integrityImpact',
    privilegesRequired: 'privilegesRequired',
    scope: 'scope',
    userInteraction: 'userInteraction',
    vectorString: 'vectorString',
    version: 'version',
    scoreId: 'scoreId'
  };

  export type Redhat_Vulnerability_CvssV3ScalarFieldEnum = (typeof Redhat_Vulnerability_CvssV3ScalarFieldEnum)[keyof typeof Redhat_Vulnerability_CvssV3ScalarFieldEnum]


  export const Redhat_Vulnerability_ThreatScalarFieldEnum: {
    id: 'id',
    category: 'category',
    details: 'details',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_ThreatScalarFieldEnum = (typeof Redhat_Vulnerability_ThreatScalarFieldEnum)[keyof typeof Redhat_Vulnerability_ThreatScalarFieldEnum]


  export const Redhat_Vulnerability_CweScalarFieldEnum: {
    id: 'id',
    cweId: 'cweId',
    name: 'name',
    vulnerabilityId: 'vulnerabilityId'
  };

  export type Redhat_Vulnerability_CweScalarFieldEnum = (typeof Redhat_Vulnerability_CweScalarFieldEnum)[keyof typeof Redhat_Vulnerability_CweScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type vmwareWhereInput = {
    AND?: vmwareWhereInput | vmwareWhereInput[]
    OR?: vmwareWhereInput[]
    NOT?: vmwareWhereInput | vmwareWhereInput[]
    cve?: StringFilter<"vmware"> | string
    synopsis?: StringFilter<"vmware"> | string
    severity?: StringFilter<"vmware"> | string
    date?: StringFilter<"vmware"> | string
    link?: StringFilter<"vmware"> | string
    detail?: StringFilter<"vmware"> | string
  }

  export type vmwareOrderByWithRelationInput = {
    cve?: SortOrder
    synopsis?: SortOrder
    severity?: SortOrder
    date?: SortOrder
    link?: SortOrder
    detail?: SortOrder
  }

  export type vmwareWhereUniqueInput = Prisma.AtLeast<{
    cve?: string
    AND?: vmwareWhereInput | vmwareWhereInput[]
    OR?: vmwareWhereInput[]
    NOT?: vmwareWhereInput | vmwareWhereInput[]
    synopsis?: StringFilter<"vmware"> | string
    severity?: StringFilter<"vmware"> | string
    date?: StringFilter<"vmware"> | string
    link?: StringFilter<"vmware"> | string
    detail?: StringFilter<"vmware"> | string
  }, "cve">

  export type vmwareOrderByWithAggregationInput = {
    cve?: SortOrder
    synopsis?: SortOrder
    severity?: SortOrder
    date?: SortOrder
    link?: SortOrder
    detail?: SortOrder
    _count?: vmwareCountOrderByAggregateInput
    _max?: vmwareMaxOrderByAggregateInput
    _min?: vmwareMinOrderByAggregateInput
  }

  export type vmwareScalarWhereWithAggregatesInput = {
    AND?: vmwareScalarWhereWithAggregatesInput | vmwareScalarWhereWithAggregatesInput[]
    OR?: vmwareScalarWhereWithAggregatesInput[]
    NOT?: vmwareScalarWhereWithAggregatesInput | vmwareScalarWhereWithAggregatesInput[]
    cve?: StringWithAggregatesFilter<"vmware"> | string
    synopsis?: StringWithAggregatesFilter<"vmware"> | string
    severity?: StringWithAggregatesFilter<"vmware"> | string
    date?: StringWithAggregatesFilter<"vmware"> | string
    link?: StringWithAggregatesFilter<"vmware"> | string
    detail?: StringWithAggregatesFilter<"vmware"> | string
  }

  export type ciscoWhereInput = {
    AND?: ciscoWhereInput | ciscoWhereInput[]
    OR?: ciscoWhereInput[]
    NOT?: ciscoWhereInput | ciscoWhereInput[]
    id?: StringFilter<"cisco"> | string
    link?: StringFilter<"cisco"> | string
    title?: StringFilter<"cisco"> | string
    impact?: StringFilter<"cisco"> | string
    version?: StringFilter<"cisco"> | string
    last_updated?: StringFilter<"cisco"> | string
    clean_cves?: StringNullableListFilter<"cisco">
  }

  export type ciscoOrderByWithRelationInput = {
    id?: SortOrder
    link?: SortOrder
    title?: SortOrder
    impact?: SortOrder
    version?: SortOrder
    last_updated?: SortOrder
    clean_cves?: SortOrder
  }

  export type ciscoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ciscoWhereInput | ciscoWhereInput[]
    OR?: ciscoWhereInput[]
    NOT?: ciscoWhereInput | ciscoWhereInput[]
    link?: StringFilter<"cisco"> | string
    title?: StringFilter<"cisco"> | string
    impact?: StringFilter<"cisco"> | string
    version?: StringFilter<"cisco"> | string
    last_updated?: StringFilter<"cisco"> | string
    clean_cves?: StringNullableListFilter<"cisco">
  }, "id">

  export type ciscoOrderByWithAggregationInput = {
    id?: SortOrder
    link?: SortOrder
    title?: SortOrder
    impact?: SortOrder
    version?: SortOrder
    last_updated?: SortOrder
    clean_cves?: SortOrder
    _count?: ciscoCountOrderByAggregateInput
    _max?: ciscoMaxOrderByAggregateInput
    _min?: ciscoMinOrderByAggregateInput
  }

  export type ciscoScalarWhereWithAggregatesInput = {
    AND?: ciscoScalarWhereWithAggregatesInput | ciscoScalarWhereWithAggregatesInput[]
    OR?: ciscoScalarWhereWithAggregatesInput[]
    NOT?: ciscoScalarWhereWithAggregatesInput | ciscoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cisco"> | string
    link?: StringWithAggregatesFilter<"cisco"> | string
    title?: StringWithAggregatesFilter<"cisco"> | string
    impact?: StringWithAggregatesFilter<"cisco"> | string
    version?: StringWithAggregatesFilter<"cisco"> | string
    last_updated?: StringWithAggregatesFilter<"cisco"> | string
    clean_cves?: StringNullableListFilter<"cisco">
  }

  export type oracleWhereInput = {
    AND?: oracleWhereInput | oracleWhereInput[]
    OR?: oracleWhereInput[]
    NOT?: oracleWhereInput | oracleWhereInput[]
    id?: IntFilter<"oracle"> | number
    affected_product?: StringFilter<"oracle"> | string
    affected_product_link?: StringFilter<"oracle"> | string
    patch_document?: StringFilter<"oracle"> | string
    patch_document_link?: StringFilter<"oracle"> | string
  }

  export type oracleOrderByWithRelationInput = {
    id?: SortOrder
    affected_product?: SortOrder
    affected_product_link?: SortOrder
    patch_document?: SortOrder
    patch_document_link?: SortOrder
  }

  export type oracleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: oracleWhereInput | oracleWhereInput[]
    OR?: oracleWhereInput[]
    NOT?: oracleWhereInput | oracleWhereInput[]
    affected_product?: StringFilter<"oracle"> | string
    affected_product_link?: StringFilter<"oracle"> | string
    patch_document?: StringFilter<"oracle"> | string
    patch_document_link?: StringFilter<"oracle"> | string
  }, "id">

  export type oracleOrderByWithAggregationInput = {
    id?: SortOrder
    affected_product?: SortOrder
    affected_product_link?: SortOrder
    patch_document?: SortOrder
    patch_document_link?: SortOrder
    _count?: oracleCountOrderByAggregateInput
    _avg?: oracleAvgOrderByAggregateInput
    _max?: oracleMaxOrderByAggregateInput
    _min?: oracleMinOrderByAggregateInput
    _sum?: oracleSumOrderByAggregateInput
  }

  export type oracleScalarWhereWithAggregatesInput = {
    AND?: oracleScalarWhereWithAggregatesInput | oracleScalarWhereWithAggregatesInput[]
    OR?: oracleScalarWhereWithAggregatesInput[]
    NOT?: oracleScalarWhereWithAggregatesInput | oracleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"oracle"> | number
    affected_product?: StringWithAggregatesFilter<"oracle"> | string
    affected_product_link?: StringWithAggregatesFilter<"oracle"> | string
    patch_document?: StringWithAggregatesFilter<"oracle"> | string
    patch_document_link?: StringWithAggregatesFilter<"oracle"> | string
  }

  export type microsoftWhereInput = {
    AND?: microsoftWhereInput | microsoftWhereInput[]
    OR?: microsoftWhereInput[]
    NOT?: microsoftWhereInput | microsoftWhereInput[]
    cve?: StringFilter<"microsoft"> | string
    release_date?: StringFilter<"microsoft"> | string
    revision_date?: StringFilter<"microsoft"> | string
    cve_link?: StringFilter<"microsoft"> | string
    cve_title?: StringFilter<"microsoft"> | string
    impact?: StringFilter<"microsoft"> | string
    severity?: StringFilter<"microsoft"> | string
    tag?: StringFilter<"microsoft"> | string
  }

  export type microsoftOrderByWithRelationInput = {
    cve?: SortOrder
    release_date?: SortOrder
    revision_date?: SortOrder
    cve_link?: SortOrder
    cve_title?: SortOrder
    impact?: SortOrder
    severity?: SortOrder
    tag?: SortOrder
  }

  export type microsoftWhereUniqueInput = Prisma.AtLeast<{
    cve?: string
    AND?: microsoftWhereInput | microsoftWhereInput[]
    OR?: microsoftWhereInput[]
    NOT?: microsoftWhereInput | microsoftWhereInput[]
    release_date?: StringFilter<"microsoft"> | string
    revision_date?: StringFilter<"microsoft"> | string
    cve_link?: StringFilter<"microsoft"> | string
    cve_title?: StringFilter<"microsoft"> | string
    impact?: StringFilter<"microsoft"> | string
    severity?: StringFilter<"microsoft"> | string
    tag?: StringFilter<"microsoft"> | string
  }, "cve">

  export type microsoftOrderByWithAggregationInput = {
    cve?: SortOrder
    release_date?: SortOrder
    revision_date?: SortOrder
    cve_link?: SortOrder
    cve_title?: SortOrder
    impact?: SortOrder
    severity?: SortOrder
    tag?: SortOrder
    _count?: microsoftCountOrderByAggregateInput
    _max?: microsoftMaxOrderByAggregateInput
    _min?: microsoftMinOrderByAggregateInput
  }

  export type microsoftScalarWhereWithAggregatesInput = {
    AND?: microsoftScalarWhereWithAggregatesInput | microsoftScalarWhereWithAggregatesInput[]
    OR?: microsoftScalarWhereWithAggregatesInput[]
    NOT?: microsoftScalarWhereWithAggregatesInput | microsoftScalarWhereWithAggregatesInput[]
    cve?: StringWithAggregatesFilter<"microsoft"> | string
    release_date?: StringWithAggregatesFilter<"microsoft"> | string
    revision_date?: StringWithAggregatesFilter<"microsoft"> | string
    cve_link?: StringWithAggregatesFilter<"microsoft"> | string
    cve_title?: StringWithAggregatesFilter<"microsoft"> | string
    impact?: StringWithAggregatesFilter<"microsoft"> | string
    severity?: StringWithAggregatesFilter<"microsoft"> | string
    tag?: StringWithAggregatesFilter<"microsoft"> | string
  }

  export type hackernewsWhereInput = {
    AND?: hackernewsWhereInput | hackernewsWhereInput[]
    OR?: hackernewsWhereInput[]
    NOT?: hackernewsWhereInput | hackernewsWhereInput[]
    title?: StringFilter<"hackernews"> | string
    link?: StringFilter<"hackernews"> | string
    img?: StringFilter<"hackernews"> | string
    date?: StringFilter<"hackernews"> | string
    description?: StringFilter<"hackernews"> | string
    detail?: StringFilter<"hackernews"> | string
  }

  export type hackernewsOrderByWithRelationInput = {
    title?: SortOrder
    link?: SortOrder
    img?: SortOrder
    date?: SortOrder
    description?: SortOrder
    detail?: SortOrder
  }

  export type hackernewsWhereUniqueInput = Prisma.AtLeast<{
    title?: string
    AND?: hackernewsWhereInput | hackernewsWhereInput[]
    OR?: hackernewsWhereInput[]
    NOT?: hackernewsWhereInput | hackernewsWhereInput[]
    link?: StringFilter<"hackernews"> | string
    img?: StringFilter<"hackernews"> | string
    date?: StringFilter<"hackernews"> | string
    description?: StringFilter<"hackernews"> | string
    detail?: StringFilter<"hackernews"> | string
  }, "title">

  export type hackernewsOrderByWithAggregationInput = {
    title?: SortOrder
    link?: SortOrder
    img?: SortOrder
    date?: SortOrder
    description?: SortOrder
    detail?: SortOrder
    _count?: hackernewsCountOrderByAggregateInput
    _max?: hackernewsMaxOrderByAggregateInput
    _min?: hackernewsMinOrderByAggregateInput
  }

  export type hackernewsScalarWhereWithAggregatesInput = {
    AND?: hackernewsScalarWhereWithAggregatesInput | hackernewsScalarWhereWithAggregatesInput[]
    OR?: hackernewsScalarWhereWithAggregatesInput[]
    NOT?: hackernewsScalarWhereWithAggregatesInput | hackernewsScalarWhereWithAggregatesInput[]
    title?: StringWithAggregatesFilter<"hackernews"> | string
    link?: StringWithAggregatesFilter<"hackernews"> | string
    img?: StringWithAggregatesFilter<"hackernews"> | string
    date?: StringWithAggregatesFilter<"hackernews"> | string
    description?: StringWithAggregatesFilter<"hackernews"> | string
    detail?: StringWithAggregatesFilter<"hackernews"> | string
  }

  export type RedhatWhereInput = {
    AND?: RedhatWhereInput | RedhatWhereInput[]
    OR?: RedhatWhereInput[]
    NOT?: RedhatWhereInput | RedhatWhereInput[]
    id?: StringFilter<"Redhat"> | string
    RHSA?: StringFilter<"Redhat"> | string
    severity?: StringFilter<"Redhat"> | string
    released_on?: StringFilter<"Redhat"> | string
    CVEs?: StringNullableListFilter<"Redhat">
    bugzillas?: StringNullableListFilter<"Redhat">
    released_packages?: StringNullableListFilter<"Redhat">
    resource_url?: StringFilter<"Redhat"> | string
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
    vulnerabilities?: Redhat_VulnerabilityListRelationFilter
  }

  export type RedhatOrderByWithRelationInput = {
    id?: SortOrder
    RHSA?: SortOrder
    severity?: SortOrder
    released_on?: SortOrder
    CVEs?: SortOrder
    bugzillas?: SortOrder
    released_packages?: SortOrder
    resource_url?: SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
    vulnerabilities?: Redhat_VulnerabilityOrderByRelationAggregateInput
  }

  export type RedhatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RedhatWhereInput | RedhatWhereInput[]
    OR?: RedhatWhereInput[]
    NOT?: RedhatWhereInput | RedhatWhereInput[]
    RHSA?: StringFilter<"Redhat"> | string
    severity?: StringFilter<"Redhat"> | string
    released_on?: StringFilter<"Redhat"> | string
    CVEs?: StringNullableListFilter<"Redhat">
    bugzillas?: StringNullableListFilter<"Redhat">
    released_packages?: StringNullableListFilter<"Redhat">
    resource_url?: StringFilter<"Redhat"> | string
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
    vulnerabilities?: Redhat_VulnerabilityListRelationFilter
  }, "id" | "id">

  export type RedhatOrderByWithAggregationInput = {
    id?: SortOrder
    RHSA?: SortOrder
    severity?: SortOrder
    released_on?: SortOrder
    CVEs?: SortOrder
    bugzillas?: SortOrder
    released_packages?: SortOrder
    resource_url?: SortOrder
    _count?: RedhatCountOrderByAggregateInput
    _max?: RedhatMaxOrderByAggregateInput
    _min?: RedhatMinOrderByAggregateInput
  }

  export type RedhatScalarWhereWithAggregatesInput = {
    AND?: RedhatScalarWhereWithAggregatesInput | RedhatScalarWhereWithAggregatesInput[]
    OR?: RedhatScalarWhereWithAggregatesInput[]
    NOT?: RedhatScalarWhereWithAggregatesInput | RedhatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat"> | string
    RHSA?: StringWithAggregatesFilter<"Redhat"> | string
    severity?: StringWithAggregatesFilter<"Redhat"> | string
    released_on?: StringWithAggregatesFilter<"Redhat"> | string
    CVEs?: StringNullableListFilter<"Redhat">
    bugzillas?: StringNullableListFilter<"Redhat">
    released_packages?: StringNullableListFilter<"Redhat">
    resource_url?: StringWithAggregatesFilter<"Redhat"> | string
  }

  export type Redhat_DocumentWhereInput = {
    AND?: Redhat_DocumentWhereInput | Redhat_DocumentWhereInput[]
    OR?: Redhat_DocumentWhereInput[]
    NOT?: Redhat_DocumentWhereInput | Redhat_DocumentWhereInput[]
    id?: StringFilter<"Redhat_Document"> | string
    category?: StringFilter<"Redhat_Document"> | string
    csaf_version?: StringFilter<"Redhat_Document"> | string
    lang?: StringFilter<"Redhat_Document"> | string
    title?: StringFilter<"Redhat_Document"> | string
    redhatId?: StringNullableFilter<"Redhat_Document"> | string | null
    aggregateSeverityId?: StringNullableFilter<"Redhat_Document"> | string | null
    distributionId?: StringNullableFilter<"Redhat_Document"> | string | null
    publisherId?: StringNullableFilter<"Redhat_Document"> | string | null
    aggregate_severity?: XOR<Redhat_AggregateSeverityNullableRelationFilter, Redhat_AggregateSeverityWhereInput> | null
    distribution?: XOR<Redhat_DistributionNullableRelationFilter, Redhat_DistributionWhereInput> | null
    publisher?: XOR<Redhat_PublisherNullableRelationFilter, Redhat_PublisherWhereInput> | null
    notes?: Redhat_Document_NoteListRelationFilter
    references?: Redhat_Document_ReferenceListRelationFilter
    redhat?: XOR<RedhatNullableRelationFilter, RedhatWhereInput> | null
    tracking?: Redhat_TrackingListRelationFilter
  }

  export type Redhat_DocumentOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    csaf_version?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    redhatId?: SortOrderInput | SortOrder
    aggregateSeverityId?: SortOrderInput | SortOrder
    distributionId?: SortOrderInput | SortOrder
    publisherId?: SortOrderInput | SortOrder
    aggregate_severity?: Redhat_AggregateSeverityOrderByWithRelationInput
    distribution?: Redhat_DistributionOrderByWithRelationInput
    publisher?: Redhat_PublisherOrderByWithRelationInput
    notes?: Redhat_Document_NoteOrderByRelationAggregateInput
    references?: Redhat_Document_ReferenceOrderByRelationAggregateInput
    redhat?: RedhatOrderByWithRelationInput
    tracking?: Redhat_TrackingOrderByRelationAggregateInput
  }

  export type Redhat_DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    redhatId?: string
    AND?: Redhat_DocumentWhereInput | Redhat_DocumentWhereInput[]
    OR?: Redhat_DocumentWhereInput[]
    NOT?: Redhat_DocumentWhereInput | Redhat_DocumentWhereInput[]
    category?: StringFilter<"Redhat_Document"> | string
    csaf_version?: StringFilter<"Redhat_Document"> | string
    lang?: StringFilter<"Redhat_Document"> | string
    title?: StringFilter<"Redhat_Document"> | string
    aggregateSeverityId?: StringNullableFilter<"Redhat_Document"> | string | null
    distributionId?: StringNullableFilter<"Redhat_Document"> | string | null
    publisherId?: StringNullableFilter<"Redhat_Document"> | string | null
    aggregate_severity?: XOR<Redhat_AggregateSeverityNullableRelationFilter, Redhat_AggregateSeverityWhereInput> | null
    distribution?: XOR<Redhat_DistributionNullableRelationFilter, Redhat_DistributionWhereInput> | null
    publisher?: XOR<Redhat_PublisherNullableRelationFilter, Redhat_PublisherWhereInput> | null
    notes?: Redhat_Document_NoteListRelationFilter
    references?: Redhat_Document_ReferenceListRelationFilter
    redhat?: XOR<RedhatNullableRelationFilter, RedhatWhereInput> | null
    tracking?: Redhat_TrackingListRelationFilter
  }, "id" | "id" | "redhatId">

  export type Redhat_DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    csaf_version?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    redhatId?: SortOrderInput | SortOrder
    aggregateSeverityId?: SortOrderInput | SortOrder
    distributionId?: SortOrderInput | SortOrder
    publisherId?: SortOrderInput | SortOrder
    _count?: Redhat_DocumentCountOrderByAggregateInput
    _max?: Redhat_DocumentMaxOrderByAggregateInput
    _min?: Redhat_DocumentMinOrderByAggregateInput
  }

  export type Redhat_DocumentScalarWhereWithAggregatesInput = {
    AND?: Redhat_DocumentScalarWhereWithAggregatesInput | Redhat_DocumentScalarWhereWithAggregatesInput[]
    OR?: Redhat_DocumentScalarWhereWithAggregatesInput[]
    NOT?: Redhat_DocumentScalarWhereWithAggregatesInput | Redhat_DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Document"> | string
    category?: StringWithAggregatesFilter<"Redhat_Document"> | string
    csaf_version?: StringWithAggregatesFilter<"Redhat_Document"> | string
    lang?: StringWithAggregatesFilter<"Redhat_Document"> | string
    title?: StringWithAggregatesFilter<"Redhat_Document"> | string
    redhatId?: StringNullableWithAggregatesFilter<"Redhat_Document"> | string | null
    aggregateSeverityId?: StringNullableWithAggregatesFilter<"Redhat_Document"> | string | null
    distributionId?: StringNullableWithAggregatesFilter<"Redhat_Document"> | string | null
    publisherId?: StringNullableWithAggregatesFilter<"Redhat_Document"> | string | null
  }

  export type Redhat_TrackingWhereInput = {
    AND?: Redhat_TrackingWhereInput | Redhat_TrackingWhereInput[]
    OR?: Redhat_TrackingWhereInput[]
    NOT?: Redhat_TrackingWhereInput | Redhat_TrackingWhereInput[]
    id?: StringFilter<"Redhat_Tracking"> | string
    current_release_date?: StringFilter<"Redhat_Tracking"> | string
    ID?: StringFilter<"Redhat_Tracking"> | string
    documentId?: StringNullableFilter<"Redhat_Tracking"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_TrackingOrderByWithRelationInput = {
    id?: SortOrder
    current_release_date?: SortOrder
    ID?: SortOrder
    documentId?: SortOrderInput | SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_TrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: Redhat_TrackingWhereInput | Redhat_TrackingWhereInput[]
    OR?: Redhat_TrackingWhereInput[]
    NOT?: Redhat_TrackingWhereInput | Redhat_TrackingWhereInput[]
    current_release_date?: StringFilter<"Redhat_Tracking"> | string
    ID?: StringFilter<"Redhat_Tracking"> | string
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id" | "documentId">

  export type Redhat_TrackingOrderByWithAggregationInput = {
    id?: SortOrder
    current_release_date?: SortOrder
    ID?: SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: Redhat_TrackingCountOrderByAggregateInput
    _max?: Redhat_TrackingMaxOrderByAggregateInput
    _min?: Redhat_TrackingMinOrderByAggregateInput
  }

  export type Redhat_TrackingScalarWhereWithAggregatesInput = {
    AND?: Redhat_TrackingScalarWhereWithAggregatesInput | Redhat_TrackingScalarWhereWithAggregatesInput[]
    OR?: Redhat_TrackingScalarWhereWithAggregatesInput[]
    NOT?: Redhat_TrackingScalarWhereWithAggregatesInput | Redhat_TrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Tracking"> | string
    current_release_date?: StringWithAggregatesFilter<"Redhat_Tracking"> | string
    ID?: StringWithAggregatesFilter<"Redhat_Tracking"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_Tracking"> | string | null
  }

  export type Redhat_AggregateSeverityWhereInput = {
    AND?: Redhat_AggregateSeverityWhereInput | Redhat_AggregateSeverityWhereInput[]
    OR?: Redhat_AggregateSeverityWhereInput[]
    NOT?: Redhat_AggregateSeverityWhereInput | Redhat_AggregateSeverityWhereInput[]
    id?: StringFilter<"Redhat_AggregateSeverity"> | string
    namespace?: StringFilter<"Redhat_AggregateSeverity"> | string
    text?: StringFilter<"Redhat_AggregateSeverity"> | string
    documentId?: StringNullableFilter<"Redhat_AggregateSeverity"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_AggregateSeverityOrderByWithRelationInput = {
    id?: SortOrder
    namespace?: SortOrder
    text?: SortOrder
    documentId?: SortOrderInput | SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_AggregateSeverityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: Redhat_AggregateSeverityWhereInput | Redhat_AggregateSeverityWhereInput[]
    OR?: Redhat_AggregateSeverityWhereInput[]
    NOT?: Redhat_AggregateSeverityWhereInput | Redhat_AggregateSeverityWhereInput[]
    namespace?: StringFilter<"Redhat_AggregateSeverity"> | string
    text?: StringFilter<"Redhat_AggregateSeverity"> | string
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id" | "documentId">

  export type Redhat_AggregateSeverityOrderByWithAggregationInput = {
    id?: SortOrder
    namespace?: SortOrder
    text?: SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: Redhat_AggregateSeverityCountOrderByAggregateInput
    _max?: Redhat_AggregateSeverityMaxOrderByAggregateInput
    _min?: Redhat_AggregateSeverityMinOrderByAggregateInput
  }

  export type Redhat_AggregateSeverityScalarWhereWithAggregatesInput = {
    AND?: Redhat_AggregateSeverityScalarWhereWithAggregatesInput | Redhat_AggregateSeverityScalarWhereWithAggregatesInput[]
    OR?: Redhat_AggregateSeverityScalarWhereWithAggregatesInput[]
    NOT?: Redhat_AggregateSeverityScalarWhereWithAggregatesInput | Redhat_AggregateSeverityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_AggregateSeverity"> | string
    namespace?: StringWithAggregatesFilter<"Redhat_AggregateSeverity"> | string
    text?: StringWithAggregatesFilter<"Redhat_AggregateSeverity"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_AggregateSeverity"> | string | null
  }

  export type Redhat_DistributionWhereInput = {
    AND?: Redhat_DistributionWhereInput | Redhat_DistributionWhereInput[]
    OR?: Redhat_DistributionWhereInput[]
    NOT?: Redhat_DistributionWhereInput | Redhat_DistributionWhereInput[]
    id?: StringFilter<"Redhat_Distribution"> | string
    text?: StringFilter<"Redhat_Distribution"> | string
    documentId?: StringNullableFilter<"Redhat_Distribution"> | string | null
    tlpId?: StringNullableFilter<"Redhat_Distribution"> | string | null
    tlp?: XOR<Redhat_TlpNullableRelationFilter, Redhat_TlpWhereInput> | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_DistributionOrderByWithRelationInput = {
    id?: SortOrder
    text?: SortOrder
    documentId?: SortOrderInput | SortOrder
    tlpId?: SortOrderInput | SortOrder
    tlp?: Redhat_TlpOrderByWithRelationInput
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_DistributionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    tlpId?: string
    AND?: Redhat_DistributionWhereInput | Redhat_DistributionWhereInput[]
    OR?: Redhat_DistributionWhereInput[]
    NOT?: Redhat_DistributionWhereInput | Redhat_DistributionWhereInput[]
    text?: StringFilter<"Redhat_Distribution"> | string
    tlp?: XOR<Redhat_TlpNullableRelationFilter, Redhat_TlpWhereInput> | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id" | "documentId" | "tlpId">

  export type Redhat_DistributionOrderByWithAggregationInput = {
    id?: SortOrder
    text?: SortOrder
    documentId?: SortOrderInput | SortOrder
    tlpId?: SortOrderInput | SortOrder
    _count?: Redhat_DistributionCountOrderByAggregateInput
    _max?: Redhat_DistributionMaxOrderByAggregateInput
    _min?: Redhat_DistributionMinOrderByAggregateInput
  }

  export type Redhat_DistributionScalarWhereWithAggregatesInput = {
    AND?: Redhat_DistributionScalarWhereWithAggregatesInput | Redhat_DistributionScalarWhereWithAggregatesInput[]
    OR?: Redhat_DistributionScalarWhereWithAggregatesInput[]
    NOT?: Redhat_DistributionScalarWhereWithAggregatesInput | Redhat_DistributionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Distribution"> | string
    text?: StringWithAggregatesFilter<"Redhat_Distribution"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_Distribution"> | string | null
    tlpId?: StringNullableWithAggregatesFilter<"Redhat_Distribution"> | string | null
  }

  export type Redhat_TlpWhereInput = {
    AND?: Redhat_TlpWhereInput | Redhat_TlpWhereInput[]
    OR?: Redhat_TlpWhereInput[]
    NOT?: Redhat_TlpWhereInput | Redhat_TlpWhereInput[]
    id?: StringFilter<"Redhat_Tlp"> | string
    label?: StringFilter<"Redhat_Tlp"> | string
    url?: StringFilter<"Redhat_Tlp"> | string
    distributionId?: StringNullableFilter<"Redhat_Tlp"> | string | null
    distribution?: XOR<Redhat_DistributionNullableRelationFilter, Redhat_DistributionWhereInput> | null
  }

  export type Redhat_TlpOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    url?: SortOrder
    distributionId?: SortOrderInput | SortOrder
    distribution?: Redhat_DistributionOrderByWithRelationInput
  }

  export type Redhat_TlpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    distributionId?: string
    AND?: Redhat_TlpWhereInput | Redhat_TlpWhereInput[]
    OR?: Redhat_TlpWhereInput[]
    NOT?: Redhat_TlpWhereInput | Redhat_TlpWhereInput[]
    label?: StringFilter<"Redhat_Tlp"> | string
    url?: StringFilter<"Redhat_Tlp"> | string
    distribution?: XOR<Redhat_DistributionNullableRelationFilter, Redhat_DistributionWhereInput> | null
  }, "id" | "id" | "distributionId">

  export type Redhat_TlpOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    url?: SortOrder
    distributionId?: SortOrderInput | SortOrder
    _count?: Redhat_TlpCountOrderByAggregateInput
    _max?: Redhat_TlpMaxOrderByAggregateInput
    _min?: Redhat_TlpMinOrderByAggregateInput
  }

  export type Redhat_TlpScalarWhereWithAggregatesInput = {
    AND?: Redhat_TlpScalarWhereWithAggregatesInput | Redhat_TlpScalarWhereWithAggregatesInput[]
    OR?: Redhat_TlpScalarWhereWithAggregatesInput[]
    NOT?: Redhat_TlpScalarWhereWithAggregatesInput | Redhat_TlpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Tlp"> | string
    label?: StringWithAggregatesFilter<"Redhat_Tlp"> | string
    url?: StringWithAggregatesFilter<"Redhat_Tlp"> | string
    distributionId?: StringNullableWithAggregatesFilter<"Redhat_Tlp"> | string | null
  }

  export type Redhat_Document_NoteWhereInput = {
    AND?: Redhat_Document_NoteWhereInput | Redhat_Document_NoteWhereInput[]
    OR?: Redhat_Document_NoteWhereInput[]
    NOT?: Redhat_Document_NoteWhereInput | Redhat_Document_NoteWhereInput[]
    id?: StringFilter<"Redhat_Document_Note"> | string
    category?: StringFilter<"Redhat_Document_Note"> | string
    text?: StringFilter<"Redhat_Document_Note"> | string
    title?: StringFilter<"Redhat_Document_Note"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Note"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_Document_NoteOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    documentId?: SortOrderInput | SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_Document_NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Document_NoteWhereInput | Redhat_Document_NoteWhereInput[]
    OR?: Redhat_Document_NoteWhereInput[]
    NOT?: Redhat_Document_NoteWhereInput | Redhat_Document_NoteWhereInput[]
    category?: StringFilter<"Redhat_Document_Note"> | string
    text?: StringFilter<"Redhat_Document_Note"> | string
    title?: StringFilter<"Redhat_Document_Note"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Note"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id">

  export type Redhat_Document_NoteOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: Redhat_Document_NoteCountOrderByAggregateInput
    _max?: Redhat_Document_NoteMaxOrderByAggregateInput
    _min?: Redhat_Document_NoteMinOrderByAggregateInput
  }

  export type Redhat_Document_NoteScalarWhereWithAggregatesInput = {
    AND?: Redhat_Document_NoteScalarWhereWithAggregatesInput | Redhat_Document_NoteScalarWhereWithAggregatesInput[]
    OR?: Redhat_Document_NoteScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Document_NoteScalarWhereWithAggregatesInput | Redhat_Document_NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Document_Note"> | string
    category?: StringWithAggregatesFilter<"Redhat_Document_Note"> | string
    text?: StringWithAggregatesFilter<"Redhat_Document_Note"> | string
    title?: StringWithAggregatesFilter<"Redhat_Document_Note"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_Document_Note"> | string | null
  }

  export type Redhat_PublisherWhereInput = {
    AND?: Redhat_PublisherWhereInput | Redhat_PublisherWhereInput[]
    OR?: Redhat_PublisherWhereInput[]
    NOT?: Redhat_PublisherWhereInput | Redhat_PublisherWhereInput[]
    id?: StringFilter<"Redhat_Publisher"> | string
    category?: StringFilter<"Redhat_Publisher"> | string
    contact_details?: StringFilter<"Redhat_Publisher"> | string
    issuing_authority?: StringFilter<"Redhat_Publisher"> | string
    name?: StringFilter<"Redhat_Publisher"> | string
    namespace?: StringFilter<"Redhat_Publisher"> | string
    documentId?: StringNullableFilter<"Redhat_Publisher"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_PublisherOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    contact_details?: SortOrder
    issuing_authority?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    documentId?: SortOrderInput | SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_PublisherWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId?: string
    AND?: Redhat_PublisherWhereInput | Redhat_PublisherWhereInput[]
    OR?: Redhat_PublisherWhereInput[]
    NOT?: Redhat_PublisherWhereInput | Redhat_PublisherWhereInput[]
    category?: StringFilter<"Redhat_Publisher"> | string
    contact_details?: StringFilter<"Redhat_Publisher"> | string
    issuing_authority?: StringFilter<"Redhat_Publisher"> | string
    name?: StringFilter<"Redhat_Publisher"> | string
    namespace?: StringFilter<"Redhat_Publisher"> | string
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id" | "documentId">

  export type Redhat_PublisherOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    contact_details?: SortOrder
    issuing_authority?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: Redhat_PublisherCountOrderByAggregateInput
    _max?: Redhat_PublisherMaxOrderByAggregateInput
    _min?: Redhat_PublisherMinOrderByAggregateInput
  }

  export type Redhat_PublisherScalarWhereWithAggregatesInput = {
    AND?: Redhat_PublisherScalarWhereWithAggregatesInput | Redhat_PublisherScalarWhereWithAggregatesInput[]
    OR?: Redhat_PublisherScalarWhereWithAggregatesInput[]
    NOT?: Redhat_PublisherScalarWhereWithAggregatesInput | Redhat_PublisherScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    category?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    contact_details?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    issuing_authority?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    name?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    namespace?: StringWithAggregatesFilter<"Redhat_Publisher"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_Publisher"> | string | null
  }

  export type Redhat_Document_ReferenceWhereInput = {
    AND?: Redhat_Document_ReferenceWhereInput | Redhat_Document_ReferenceWhereInput[]
    OR?: Redhat_Document_ReferenceWhereInput[]
    NOT?: Redhat_Document_ReferenceWhereInput | Redhat_Document_ReferenceWhereInput[]
    id?: StringFilter<"Redhat_Document_Reference"> | string
    category?: StringFilter<"Redhat_Document_Reference"> | string
    summary?: StringFilter<"Redhat_Document_Reference"> | string
    url?: StringFilter<"Redhat_Document_Reference"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Reference"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }

  export type Redhat_Document_ReferenceOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    documentId?: SortOrderInput | SortOrder
    document?: Redhat_DocumentOrderByWithRelationInput
  }

  export type Redhat_Document_ReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Document_ReferenceWhereInput | Redhat_Document_ReferenceWhereInput[]
    OR?: Redhat_Document_ReferenceWhereInput[]
    NOT?: Redhat_Document_ReferenceWhereInput | Redhat_Document_ReferenceWhereInput[]
    category?: StringFilter<"Redhat_Document_Reference"> | string
    summary?: StringFilter<"Redhat_Document_Reference"> | string
    url?: StringFilter<"Redhat_Document_Reference"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Reference"> | string | null
    document?: XOR<Redhat_DocumentNullableRelationFilter, Redhat_DocumentWhereInput> | null
  }, "id" | "id">

  export type Redhat_Document_ReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    documentId?: SortOrderInput | SortOrder
    _count?: Redhat_Document_ReferenceCountOrderByAggregateInput
    _max?: Redhat_Document_ReferenceMaxOrderByAggregateInput
    _min?: Redhat_Document_ReferenceMinOrderByAggregateInput
  }

  export type Redhat_Document_ReferenceScalarWhereWithAggregatesInput = {
    AND?: Redhat_Document_ReferenceScalarWhereWithAggregatesInput | Redhat_Document_ReferenceScalarWhereWithAggregatesInput[]
    OR?: Redhat_Document_ReferenceScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Document_ReferenceScalarWhereWithAggregatesInput | Redhat_Document_ReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Document_Reference"> | string
    category?: StringWithAggregatesFilter<"Redhat_Document_Reference"> | string
    summary?: StringWithAggregatesFilter<"Redhat_Document_Reference"> | string
    url?: StringWithAggregatesFilter<"Redhat_Document_Reference"> | string
    documentId?: StringNullableWithAggregatesFilter<"Redhat_Document_Reference"> | string | null
  }

  export type Redhat_VulnerabilityWhereInput = {
    AND?: Redhat_VulnerabilityWhereInput | Redhat_VulnerabilityWhereInput[]
    OR?: Redhat_VulnerabilityWhereInput[]
    NOT?: Redhat_VulnerabilityWhereInput | Redhat_VulnerabilityWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability"> | string
    cve?: StringFilter<"Redhat_Vulnerability"> | string
    discovery_date?: StringFilter<"Redhat_Vulnerability"> | string
    release_date?: StringFilter<"Redhat_Vulnerability"> | string
    title?: StringFilter<"Redhat_Vulnerability"> | string
    redhatId?: StringFilter<"Redhat_Vulnerability"> | string
    ids?: Redhat_Vulnerability_IdListRelationFilter
    notes?: Redhat_Vulnerability_NoteListRelationFilter
    product_status?: XOR<Redhat_Vulnerability_ProductStatusNullableRelationFilter, Redhat_Vulnerability_ProductStatusWhereInput> | null
    references?: Redhat_Vulnerability_ReferenceListRelationFilter
    remediations?: Redhat_Vulnerability_RemediationListRelationFilter
    scores?: Redhat_Vulnerability_ScoreListRelationFilter
    threats?: Redhat_Vulnerability_ThreatListRelationFilter
    cwe?: XOR<Redhat_Vulnerability_CweNullableRelationFilter, Redhat_Vulnerability_CweWhereInput> | null
    redhat?: XOR<RedhatNullableRelationFilter, RedhatWhereInput> | null
  }

  export type Redhat_VulnerabilityOrderByWithRelationInput = {
    id?: SortOrder
    cve?: SortOrder
    discovery_date?: SortOrder
    release_date?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
    ids?: Redhat_Vulnerability_IdOrderByRelationAggregateInput
    notes?: Redhat_Vulnerability_NoteOrderByRelationAggregateInput
    product_status?: Redhat_Vulnerability_ProductStatusOrderByWithRelationInput
    references?: Redhat_Vulnerability_ReferenceOrderByRelationAggregateInput
    remediations?: Redhat_Vulnerability_RemediationOrderByRelationAggregateInput
    scores?: Redhat_Vulnerability_ScoreOrderByRelationAggregateInput
    threats?: Redhat_Vulnerability_ThreatOrderByRelationAggregateInput
    cwe?: Redhat_Vulnerability_CweOrderByWithRelationInput
    redhat?: RedhatOrderByWithRelationInput
  }

  export type Redhat_VulnerabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_VulnerabilityWhereInput | Redhat_VulnerabilityWhereInput[]
    OR?: Redhat_VulnerabilityWhereInput[]
    NOT?: Redhat_VulnerabilityWhereInput | Redhat_VulnerabilityWhereInput[]
    cve?: StringFilter<"Redhat_Vulnerability"> | string
    discovery_date?: StringFilter<"Redhat_Vulnerability"> | string
    release_date?: StringFilter<"Redhat_Vulnerability"> | string
    title?: StringFilter<"Redhat_Vulnerability"> | string
    redhatId?: StringFilter<"Redhat_Vulnerability"> | string
    ids?: Redhat_Vulnerability_IdListRelationFilter
    notes?: Redhat_Vulnerability_NoteListRelationFilter
    product_status?: XOR<Redhat_Vulnerability_ProductStatusNullableRelationFilter, Redhat_Vulnerability_ProductStatusWhereInput> | null
    references?: Redhat_Vulnerability_ReferenceListRelationFilter
    remediations?: Redhat_Vulnerability_RemediationListRelationFilter
    scores?: Redhat_Vulnerability_ScoreListRelationFilter
    threats?: Redhat_Vulnerability_ThreatListRelationFilter
    cwe?: XOR<Redhat_Vulnerability_CweNullableRelationFilter, Redhat_Vulnerability_CweWhereInput> | null
    redhat?: XOR<RedhatNullableRelationFilter, RedhatWhereInput> | null
  }, "id" | "id">

  export type Redhat_VulnerabilityOrderByWithAggregationInput = {
    id?: SortOrder
    cve?: SortOrder
    discovery_date?: SortOrder
    release_date?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
    _count?: Redhat_VulnerabilityCountOrderByAggregateInput
    _max?: Redhat_VulnerabilityMaxOrderByAggregateInput
    _min?: Redhat_VulnerabilityMinOrderByAggregateInput
  }

  export type Redhat_VulnerabilityScalarWhereWithAggregatesInput = {
    AND?: Redhat_VulnerabilityScalarWhereWithAggregatesInput | Redhat_VulnerabilityScalarWhereWithAggregatesInput[]
    OR?: Redhat_VulnerabilityScalarWhereWithAggregatesInput[]
    NOT?: Redhat_VulnerabilityScalarWhereWithAggregatesInput | Redhat_VulnerabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
    cve?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
    discovery_date?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
    release_date?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
    title?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
    redhatId?: StringWithAggregatesFilter<"Redhat_Vulnerability"> | string
  }

  export type Redhat_Vulnerability_IdWhereInput = {
    AND?: Redhat_Vulnerability_IdWhereInput | Redhat_Vulnerability_IdWhereInput[]
    OR?: Redhat_Vulnerability_IdWhereInput[]
    NOT?: Redhat_Vulnerability_IdWhereInput | Redhat_Vulnerability_IdWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Id"> | string
    system_name?: StringFilter<"Redhat_Vulnerability_Id"> | string
    text?: StringFilter<"Redhat_Vulnerability_Id"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Id"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_IdOrderByWithRelationInput = {
    id?: SortOrder
    system_name?: SortOrder
    text?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_IdWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_IdWhereInput | Redhat_Vulnerability_IdWhereInput[]
    OR?: Redhat_Vulnerability_IdWhereInput[]
    NOT?: Redhat_Vulnerability_IdWhereInput | Redhat_Vulnerability_IdWhereInput[]
    system_name?: StringFilter<"Redhat_Vulnerability_Id"> | string
    text?: StringFilter<"Redhat_Vulnerability_Id"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Id"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_IdOrderByWithAggregationInput = {
    id?: SortOrder
    system_name?: SortOrder
    text?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_IdCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_IdMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_IdMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_IdScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_IdScalarWhereWithAggregatesInput | Redhat_Vulnerability_IdScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_IdScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_IdScalarWhereWithAggregatesInput | Redhat_Vulnerability_IdScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Id"> | string
    system_name?: StringWithAggregatesFilter<"Redhat_Vulnerability_Id"> | string
    text?: StringWithAggregatesFilter<"Redhat_Vulnerability_Id"> | string
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Id"> | string | null
  }

  export type Redhat_Vulnerability_NoteWhereInput = {
    AND?: Redhat_Vulnerability_NoteWhereInput | Redhat_Vulnerability_NoteWhereInput[]
    OR?: Redhat_Vulnerability_NoteWhereInput[]
    NOT?: Redhat_Vulnerability_NoteWhereInput | Redhat_Vulnerability_NoteWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Note"> | string
    category?: StringFilter<"Redhat_Vulnerability_Note"> | string
    text?: StringFilter<"Redhat_Vulnerability_Note"> | string
    title?: StringFilter<"Redhat_Vulnerability_Note"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Note"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_NoteOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_NoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_NoteWhereInput | Redhat_Vulnerability_NoteWhereInput[]
    OR?: Redhat_Vulnerability_NoteWhereInput[]
    NOT?: Redhat_Vulnerability_NoteWhereInput | Redhat_Vulnerability_NoteWhereInput[]
    category?: StringFilter<"Redhat_Vulnerability_Note"> | string
    text?: StringFilter<"Redhat_Vulnerability_Note"> | string
    title?: StringFilter<"Redhat_Vulnerability_Note"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Note"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_NoteOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_NoteCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_NoteMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_NoteMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput | Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput | Redhat_Vulnerability_NoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Note"> | string
    category?: StringWithAggregatesFilter<"Redhat_Vulnerability_Note"> | string
    text?: StringWithAggregatesFilter<"Redhat_Vulnerability_Note"> | string
    title?: StringWithAggregatesFilter<"Redhat_Vulnerability_Note"> | string
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Note"> | string | null
  }

  export type Redhat_Vulnerability_ProductStatusWhereInput = {
    AND?: Redhat_Vulnerability_ProductStatusWhereInput | Redhat_Vulnerability_ProductStatusWhereInput[]
    OR?: Redhat_Vulnerability_ProductStatusWhereInput[]
    NOT?: Redhat_Vulnerability_ProductStatusWhereInput | Redhat_Vulnerability_ProductStatusWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_ProductStatus"> | string
    fixed?: StringNullableListFilter<"Redhat_Vulnerability_ProductStatus">
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_ProductStatus"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_ProductStatusOrderByWithRelationInput = {
    id?: SortOrder
    fixed?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_ProductStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vulnerabilityId?: string
    AND?: Redhat_Vulnerability_ProductStatusWhereInput | Redhat_Vulnerability_ProductStatusWhereInput[]
    OR?: Redhat_Vulnerability_ProductStatusWhereInput[]
    NOT?: Redhat_Vulnerability_ProductStatusWhereInput | Redhat_Vulnerability_ProductStatusWhereInput[]
    fixed?: StringNullableListFilter<"Redhat_Vulnerability_ProductStatus">
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id" | "vulnerabilityId">

  export type Redhat_Vulnerability_ProductStatusOrderByWithAggregationInput = {
    id?: SortOrder
    fixed?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_ProductStatusCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_ProductStatusMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_ProductStatusMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput | Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput | Redhat_Vulnerability_ProductStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_ProductStatus"> | string
    fixed?: StringNullableListFilter<"Redhat_Vulnerability_ProductStatus">
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_ProductStatus"> | string | null
  }

  export type Redhat_Vulnerability_ReferenceWhereInput = {
    AND?: Redhat_Vulnerability_ReferenceWhereInput | Redhat_Vulnerability_ReferenceWhereInput[]
    OR?: Redhat_Vulnerability_ReferenceWhereInput[]
    NOT?: Redhat_Vulnerability_ReferenceWhereInput | Redhat_Vulnerability_ReferenceWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    category?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    summary?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    url?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Reference"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_ReferenceOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_ReferenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_ReferenceWhereInput | Redhat_Vulnerability_ReferenceWhereInput[]
    OR?: Redhat_Vulnerability_ReferenceWhereInput[]
    NOT?: Redhat_Vulnerability_ReferenceWhereInput | Redhat_Vulnerability_ReferenceWhereInput[]
    category?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    summary?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    url?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Reference"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_ReferenceOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_ReferenceCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_ReferenceMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_ReferenceMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput | Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput | Redhat_Vulnerability_ReferenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Reference"> | string
    category?: StringWithAggregatesFilter<"Redhat_Vulnerability_Reference"> | string
    summary?: StringWithAggregatesFilter<"Redhat_Vulnerability_Reference"> | string
    url?: StringWithAggregatesFilter<"Redhat_Vulnerability_Reference"> | string
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Reference"> | string | null
  }

  export type Redhat_Vulnerability_RemediationWhereInput = {
    AND?: Redhat_Vulnerability_RemediationWhereInput | Redhat_Vulnerability_RemediationWhereInput[]
    OR?: Redhat_Vulnerability_RemediationWhereInput[]
    NOT?: Redhat_Vulnerability_RemediationWhereInput | Redhat_Vulnerability_RemediationWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    category?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    details?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    product_ids?: StringNullableListFilter<"Redhat_Vulnerability_Remediation">
    url?: StringNullableFilter<"Redhat_Vulnerability_Remediation"> | string | null
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
    restart_required?: Redhat_Vulnerability_RestartRequiredListRelationFilter
  }

  export type Redhat_Vulnerability_RemediationOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    product_ids?: SortOrder
    url?: SortOrderInput | SortOrder
    vulnerabilityId?: SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
    restart_required?: Redhat_Vulnerability_RestartRequiredOrderByRelationAggregateInput
  }

  export type Redhat_Vulnerability_RemediationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_RemediationWhereInput | Redhat_Vulnerability_RemediationWhereInput[]
    OR?: Redhat_Vulnerability_RemediationWhereInput[]
    NOT?: Redhat_Vulnerability_RemediationWhereInput | Redhat_Vulnerability_RemediationWhereInput[]
    category?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    details?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    product_ids?: StringNullableListFilter<"Redhat_Vulnerability_Remediation">
    url?: StringNullableFilter<"Redhat_Vulnerability_Remediation"> | string | null
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
    restart_required?: Redhat_Vulnerability_RestartRequiredListRelationFilter
  }, "id" | "id">

  export type Redhat_Vulnerability_RemediationOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    product_ids?: SortOrder
    url?: SortOrderInput | SortOrder
    vulnerabilityId?: SortOrder
    _count?: Redhat_Vulnerability_RemediationCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_RemediationMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_RemediationMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput | Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput | Redhat_Vulnerability_RemediationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Remediation"> | string
    category?: StringWithAggregatesFilter<"Redhat_Vulnerability_Remediation"> | string
    details?: StringWithAggregatesFilter<"Redhat_Vulnerability_Remediation"> | string
    product_ids?: StringNullableListFilter<"Redhat_Vulnerability_Remediation">
    url?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Remediation"> | string | null
    vulnerabilityId?: StringWithAggregatesFilter<"Redhat_Vulnerability_Remediation"> | string
  }

  export type Redhat_Vulnerability_RestartRequiredWhereInput = {
    AND?: Redhat_Vulnerability_RestartRequiredWhereInput | Redhat_Vulnerability_RestartRequiredWhereInput[]
    OR?: Redhat_Vulnerability_RestartRequiredWhereInput[]
    NOT?: Redhat_Vulnerability_RestartRequiredWhereInput | Redhat_Vulnerability_RestartRequiredWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    category?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediationId?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediation?: XOR<Redhat_Vulnerability_RemediationNullableRelationFilter, Redhat_Vulnerability_RemediationWhereInput> | null
  }

  export type Redhat_Vulnerability_RestartRequiredOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    remediationId?: SortOrder
    remediation?: Redhat_Vulnerability_RemediationOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_RestartRequiredWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_RestartRequiredWhereInput | Redhat_Vulnerability_RestartRequiredWhereInput[]
    OR?: Redhat_Vulnerability_RestartRequiredWhereInput[]
    NOT?: Redhat_Vulnerability_RestartRequiredWhereInput | Redhat_Vulnerability_RestartRequiredWhereInput[]
    category?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediationId?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediation?: XOR<Redhat_Vulnerability_RemediationNullableRelationFilter, Redhat_Vulnerability_RemediationWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_RestartRequiredOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    remediationId?: SortOrder
    _count?: Redhat_Vulnerability_RestartRequiredCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_RestartRequiredMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_RestartRequiredMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput | Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput | Redhat_Vulnerability_RestartRequiredScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_RestartRequired"> | string
    category?: StringWithAggregatesFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediationId?: StringWithAggregatesFilter<"Redhat_Vulnerability_RestartRequired"> | string
  }

  export type Redhat_Vulnerability_ScoreWhereInput = {
    AND?: Redhat_Vulnerability_ScoreWhereInput | Redhat_Vulnerability_ScoreWhereInput[]
    OR?: Redhat_Vulnerability_ScoreWhereInput[]
    NOT?: Redhat_Vulnerability_ScoreWhereInput | Redhat_Vulnerability_ScoreWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Score"> | string
    products?: StringNullableListFilter<"Redhat_Vulnerability_Score">
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Score"> | string
    cvss_v3?: XOR<Redhat_Vulnerability_CvssV3NullableRelationFilter, Redhat_Vulnerability_CvssV3WhereInput> | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_ScoreOrderByWithRelationInput = {
    id?: SortOrder
    products?: SortOrder
    vulnerabilityId?: SortOrder
    cvss_v3?: Redhat_Vulnerability_CvssV3OrderByWithRelationInput
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_ScoreWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_ScoreWhereInput | Redhat_Vulnerability_ScoreWhereInput[]
    OR?: Redhat_Vulnerability_ScoreWhereInput[]
    NOT?: Redhat_Vulnerability_ScoreWhereInput | Redhat_Vulnerability_ScoreWhereInput[]
    products?: StringNullableListFilter<"Redhat_Vulnerability_Score">
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Score"> | string
    cvss_v3?: XOR<Redhat_Vulnerability_CvssV3NullableRelationFilter, Redhat_Vulnerability_CvssV3WhereInput> | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_ScoreOrderByWithAggregationInput = {
    id?: SortOrder
    products?: SortOrder
    vulnerabilityId?: SortOrder
    _count?: Redhat_Vulnerability_ScoreCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_ScoreMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_ScoreMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput | Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput | Redhat_Vulnerability_ScoreScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Score"> | string
    products?: StringNullableListFilter<"Redhat_Vulnerability_Score">
    vulnerabilityId?: StringWithAggregatesFilter<"Redhat_Vulnerability_Score"> | string
  }

  export type Redhat_Vulnerability_CvssV3WhereInput = {
    AND?: Redhat_Vulnerability_CvssV3WhereInput | Redhat_Vulnerability_CvssV3WhereInput[]
    OR?: Redhat_Vulnerability_CvssV3WhereInput[]
    NOT?: Redhat_Vulnerability_CvssV3WhereInput | Redhat_Vulnerability_CvssV3WhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    attackComplexity?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    attackVector?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    availabilityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    baseScore?: IntFilter<"Redhat_Vulnerability_CvssV3"> | number
    baseSeverity?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    confidentialityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    integrityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    privilegesRequired?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    scope?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    userInteraction?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    vectorString?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    version?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    scoreId?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    score?: XOR<Redhat_Vulnerability_ScoreNullableRelationFilter, Redhat_Vulnerability_ScoreWhereInput> | null
  }

  export type Redhat_Vulnerability_CvssV3OrderByWithRelationInput = {
    id?: SortOrder
    attackComplexity?: SortOrder
    attackVector?: SortOrder
    availabilityImpact?: SortOrder
    baseScore?: SortOrder
    baseSeverity?: SortOrder
    confidentialityImpact?: SortOrder
    integrityImpact?: SortOrder
    privilegesRequired?: SortOrder
    scope?: SortOrder
    userInteraction?: SortOrder
    vectorString?: SortOrder
    version?: SortOrder
    scoreId?: SortOrder
    score?: Redhat_Vulnerability_ScoreOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_CvssV3WhereUniqueInput = Prisma.AtLeast<{
    id?: string
    scoreId?: string
    AND?: Redhat_Vulnerability_CvssV3WhereInput | Redhat_Vulnerability_CvssV3WhereInput[]
    OR?: Redhat_Vulnerability_CvssV3WhereInput[]
    NOT?: Redhat_Vulnerability_CvssV3WhereInput | Redhat_Vulnerability_CvssV3WhereInput[]
    attackComplexity?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    attackVector?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    availabilityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    baseScore?: IntFilter<"Redhat_Vulnerability_CvssV3"> | number
    baseSeverity?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    confidentialityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    integrityImpact?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    privilegesRequired?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    scope?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    userInteraction?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    vectorString?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    version?: StringFilter<"Redhat_Vulnerability_CvssV3"> | string
    score?: XOR<Redhat_Vulnerability_ScoreNullableRelationFilter, Redhat_Vulnerability_ScoreWhereInput> | null
  }, "id" | "id" | "scoreId">

  export type Redhat_Vulnerability_CvssV3OrderByWithAggregationInput = {
    id?: SortOrder
    attackComplexity?: SortOrder
    attackVector?: SortOrder
    availabilityImpact?: SortOrder
    baseScore?: SortOrder
    baseSeverity?: SortOrder
    confidentialityImpact?: SortOrder
    integrityImpact?: SortOrder
    privilegesRequired?: SortOrder
    scope?: SortOrder
    userInteraction?: SortOrder
    vectorString?: SortOrder
    version?: SortOrder
    scoreId?: SortOrder
    _count?: Redhat_Vulnerability_CvssV3CountOrderByAggregateInput
    _avg?: Redhat_Vulnerability_CvssV3AvgOrderByAggregateInput
    _max?: Redhat_Vulnerability_CvssV3MaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_CvssV3MinOrderByAggregateInput
    _sum?: Redhat_Vulnerability_CvssV3SumOrderByAggregateInput
  }

  export type Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput | Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput | Redhat_Vulnerability_CvssV3ScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    attackComplexity?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    attackVector?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    availabilityImpact?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    baseScore?: IntWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | number
    baseSeverity?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    confidentialityImpact?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    integrityImpact?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    privilegesRequired?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    scope?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    userInteraction?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    vectorString?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    version?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
    scoreId?: StringWithAggregatesFilter<"Redhat_Vulnerability_CvssV3"> | string
  }

  export type Redhat_Vulnerability_ThreatWhereInput = {
    AND?: Redhat_Vulnerability_ThreatWhereInput | Redhat_Vulnerability_ThreatWhereInput[]
    OR?: Redhat_Vulnerability_ThreatWhereInput[]
    NOT?: Redhat_Vulnerability_ThreatWhereInput | Redhat_Vulnerability_ThreatWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    category?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    details?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Threat"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_ThreatOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_ThreatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Redhat_Vulnerability_ThreatWhereInput | Redhat_Vulnerability_ThreatWhereInput[]
    OR?: Redhat_Vulnerability_ThreatWhereInput[]
    NOT?: Redhat_Vulnerability_ThreatWhereInput | Redhat_Vulnerability_ThreatWhereInput[]
    category?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    details?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Threat"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id">

  export type Redhat_Vulnerability_ThreatOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_ThreatCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_ThreatMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_ThreatMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput | Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput | Redhat_Vulnerability_ThreatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Threat"> | string
    category?: StringWithAggregatesFilter<"Redhat_Vulnerability_Threat"> | string
    details?: StringWithAggregatesFilter<"Redhat_Vulnerability_Threat"> | string
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Threat"> | string | null
  }

  export type Redhat_Vulnerability_CweWhereInput = {
    AND?: Redhat_Vulnerability_CweWhereInput | Redhat_Vulnerability_CweWhereInput[]
    OR?: Redhat_Vulnerability_CweWhereInput[]
    NOT?: Redhat_Vulnerability_CweWhereInput | Redhat_Vulnerability_CweWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Cwe"> | string
    cweId?: StringFilter<"Redhat_Vulnerability_Cwe"> | string
    name?: StringFilter<"Redhat_Vulnerability_Cwe"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Cwe"> | string | null
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }

  export type Redhat_Vulnerability_CweOrderByWithRelationInput = {
    id?: SortOrder
    cweId?: SortOrder
    name?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    vulnerability?: Redhat_VulnerabilityOrderByWithRelationInput
  }

  export type Redhat_Vulnerability_CweWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    vulnerabilityId?: string
    AND?: Redhat_Vulnerability_CweWhereInput | Redhat_Vulnerability_CweWhereInput[]
    OR?: Redhat_Vulnerability_CweWhereInput[]
    NOT?: Redhat_Vulnerability_CweWhereInput | Redhat_Vulnerability_CweWhereInput[]
    cweId?: StringFilter<"Redhat_Vulnerability_Cwe"> | string
    name?: StringFilter<"Redhat_Vulnerability_Cwe"> | string
    vulnerability?: XOR<Redhat_VulnerabilityNullableRelationFilter, Redhat_VulnerabilityWhereInput> | null
  }, "id" | "id" | "vulnerabilityId">

  export type Redhat_Vulnerability_CweOrderByWithAggregationInput = {
    id?: SortOrder
    cweId?: SortOrder
    name?: SortOrder
    vulnerabilityId?: SortOrderInput | SortOrder
    _count?: Redhat_Vulnerability_CweCountOrderByAggregateInput
    _max?: Redhat_Vulnerability_CweMaxOrderByAggregateInput
    _min?: Redhat_Vulnerability_CweMinOrderByAggregateInput
  }

  export type Redhat_Vulnerability_CweScalarWhereWithAggregatesInput = {
    AND?: Redhat_Vulnerability_CweScalarWhereWithAggregatesInput | Redhat_Vulnerability_CweScalarWhereWithAggregatesInput[]
    OR?: Redhat_Vulnerability_CweScalarWhereWithAggregatesInput[]
    NOT?: Redhat_Vulnerability_CweScalarWhereWithAggregatesInput | Redhat_Vulnerability_CweScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Redhat_Vulnerability_Cwe"> | string
    cweId?: StringWithAggregatesFilter<"Redhat_Vulnerability_Cwe"> | string
    name?: StringWithAggregatesFilter<"Redhat_Vulnerability_Cwe"> | string
    vulnerabilityId?: StringNullableWithAggregatesFilter<"Redhat_Vulnerability_Cwe"> | string | null
  }

  export type vmwareCreateInput = {
    cve: string
    synopsis: string
    severity: string
    date: string
    link: string
    detail: string
  }

  export type vmwareUncheckedCreateInput = {
    cve: string
    synopsis: string
    severity: string
    date: string
    link: string
    detail: string
  }

  export type vmwareUpdateInput = {
    cve?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type vmwareUncheckedUpdateInput = {
    cve?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type vmwareCreateManyInput = {
    cve: string
    synopsis: string
    severity: string
    date: string
    link: string
    detail: string
  }

  export type vmwareUpdateManyMutationInput = {
    cve?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type vmwareUncheckedUpdateManyInput = {
    cve?: StringFieldUpdateOperationsInput | string
    synopsis?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type ciscoCreateInput = {
    id: string
    link: string
    title: string
    impact: string
    version: string
    last_updated: string
    clean_cves?: ciscoCreateclean_cvesInput | string[]
  }

  export type ciscoUncheckedCreateInput = {
    id: string
    link: string
    title: string
    impact: string
    version: string
    last_updated: string
    clean_cves?: ciscoCreateclean_cvesInput | string[]
  }

  export type ciscoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    last_updated?: StringFieldUpdateOperationsInput | string
    clean_cves?: ciscoUpdateclean_cvesInput | string[]
  }

  export type ciscoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    last_updated?: StringFieldUpdateOperationsInput | string
    clean_cves?: ciscoUpdateclean_cvesInput | string[]
  }

  export type ciscoCreateManyInput = {
    id: string
    link: string
    title: string
    impact: string
    version: string
    last_updated: string
    clean_cves?: ciscoCreateclean_cvesInput | string[]
  }

  export type ciscoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    last_updated?: StringFieldUpdateOperationsInput | string
    clean_cves?: ciscoUpdateclean_cvesInput | string[]
  }

  export type ciscoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    last_updated?: StringFieldUpdateOperationsInput | string
    clean_cves?: ciscoUpdateclean_cvesInput | string[]
  }

  export type oracleCreateInput = {
    affected_product: string
    affected_product_link: string
    patch_document: string
    patch_document_link: string
  }

  export type oracleUncheckedCreateInput = {
    id?: number
    affected_product: string
    affected_product_link: string
    patch_document: string
    patch_document_link: string
  }

  export type oracleUpdateInput = {
    affected_product?: StringFieldUpdateOperationsInput | string
    affected_product_link?: StringFieldUpdateOperationsInput | string
    patch_document?: StringFieldUpdateOperationsInput | string
    patch_document_link?: StringFieldUpdateOperationsInput | string
  }

  export type oracleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    affected_product?: StringFieldUpdateOperationsInput | string
    affected_product_link?: StringFieldUpdateOperationsInput | string
    patch_document?: StringFieldUpdateOperationsInput | string
    patch_document_link?: StringFieldUpdateOperationsInput | string
  }

  export type oracleCreateManyInput = {
    id?: number
    affected_product: string
    affected_product_link: string
    patch_document: string
    patch_document_link: string
  }

  export type oracleUpdateManyMutationInput = {
    affected_product?: StringFieldUpdateOperationsInput | string
    affected_product_link?: StringFieldUpdateOperationsInput | string
    patch_document?: StringFieldUpdateOperationsInput | string
    patch_document_link?: StringFieldUpdateOperationsInput | string
  }

  export type oracleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    affected_product?: StringFieldUpdateOperationsInput | string
    affected_product_link?: StringFieldUpdateOperationsInput | string
    patch_document?: StringFieldUpdateOperationsInput | string
    patch_document_link?: StringFieldUpdateOperationsInput | string
  }

  export type microsoftCreateInput = {
    cve: string
    release_date: string
    revision_date: string
    cve_link: string
    cve_title: string
    impact: string
    severity: string
    tag: string
  }

  export type microsoftUncheckedCreateInput = {
    cve: string
    release_date: string
    revision_date: string
    cve_link: string
    cve_title: string
    impact: string
    severity: string
    tag: string
  }

  export type microsoftUpdateInput = {
    cve?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    revision_date?: StringFieldUpdateOperationsInput | string
    cve_link?: StringFieldUpdateOperationsInput | string
    cve_title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type microsoftUncheckedUpdateInput = {
    cve?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    revision_date?: StringFieldUpdateOperationsInput | string
    cve_link?: StringFieldUpdateOperationsInput | string
    cve_title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type microsoftCreateManyInput = {
    cve: string
    release_date: string
    revision_date: string
    cve_link: string
    cve_title: string
    impact: string
    severity: string
    tag: string
  }

  export type microsoftUpdateManyMutationInput = {
    cve?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    revision_date?: StringFieldUpdateOperationsInput | string
    cve_link?: StringFieldUpdateOperationsInput | string
    cve_title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type microsoftUncheckedUpdateManyInput = {
    cve?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    revision_date?: StringFieldUpdateOperationsInput | string
    cve_link?: StringFieldUpdateOperationsInput | string
    cve_title?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    tag?: StringFieldUpdateOperationsInput | string
  }

  export type hackernewsCreateInput = {
    title: string
    link: string
    img: string
    date: string
    description: string
    detail: string
  }

  export type hackernewsUncheckedCreateInput = {
    title: string
    link: string
    img: string
    date: string
    description: string
    detail: string
  }

  export type hackernewsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type hackernewsUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type hackernewsCreateManyInput = {
    title: string
    link: string
    img: string
    date: string
    description: string
    detail: string
  }

  export type hackernewsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type hackernewsUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: StringFieldUpdateOperationsInput | string
    img?: StringFieldUpdateOperationsInput | string
    date?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    detail?: StringFieldUpdateOperationsInput | string
  }

  export type RedhatCreateInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    document?: Redhat_DocumentCreateNestedOneWithoutRedhatInput
    vulnerabilities?: Redhat_VulnerabilityCreateNestedManyWithoutRedhatInput
  }

  export type RedhatUncheckedCreateInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    document?: Redhat_DocumentUncheckedCreateNestedOneWithoutRedhatInput
    vulnerabilities?: Redhat_VulnerabilityUncheckedCreateNestedManyWithoutRedhatInput
  }

  export type RedhatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutRedhatNestedInput
    vulnerabilities?: Redhat_VulnerabilityUpdateManyWithoutRedhatNestedInput
  }

  export type RedhatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUncheckedUpdateOneWithoutRedhatNestedInput
    vulnerabilities?: Redhat_VulnerabilityUncheckedUpdateManyWithoutRedhatNestedInput
  }

  export type RedhatCreateManyInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
  }

  export type RedhatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
  }

  export type RedhatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_DocumentCreateInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentCreateManyInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
  }

  export type Redhat_DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_TrackingCreateInput = {
    id?: string
    current_release_date: string
    ID: string
    document?: Redhat_DocumentCreateNestedOneWithoutTrackingInput
  }

  export type Redhat_TrackingUncheckedCreateInput = {
    id?: string
    current_release_date: string
    ID: string
    documentId?: string | null
  }

  export type Redhat_TrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutTrackingNestedInput
  }

  export type Redhat_TrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_TrackingCreateManyInput = {
    id?: string
    current_release_date: string
    ID: string
    documentId?: string | null
  }

  export type Redhat_TrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_AggregateSeverityCreateInput = {
    id?: string
    namespace: string
    text: string
    document?: Redhat_DocumentCreateNestedOneWithoutAggregate_severityInput
  }

  export type Redhat_AggregateSeverityUncheckedCreateInput = {
    id?: string
    namespace: string
    text: string
    documentId?: string | null
  }

  export type Redhat_AggregateSeverityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutAggregate_severityNestedInput
  }

  export type Redhat_AggregateSeverityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_AggregateSeverityCreateManyInput = {
    id?: string
    namespace: string
    text: string
    documentId?: string | null
  }

  export type Redhat_AggregateSeverityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_AggregateSeverityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_DistributionCreateInput = {
    id?: string
    text: string
    tlpId?: string | null
    tlp?: Redhat_TlpCreateNestedOneWithoutDistributionInput
    document?: Redhat_DocumentCreateNestedOneWithoutDistributionInput
  }

  export type Redhat_DistributionUncheckedCreateInput = {
    id?: string
    text: string
    documentId?: string | null
    tlpId?: string | null
    tlp?: Redhat_TlpUncheckedCreateNestedOneWithoutDistributionInput
  }

  export type Redhat_DistributionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
    tlp?: Redhat_TlpUpdateOneWithoutDistributionNestedInput
    document?: Redhat_DocumentUpdateOneWithoutDistributionNestedInput
  }

  export type Redhat_DistributionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
    tlp?: Redhat_TlpUncheckedUpdateOneWithoutDistributionNestedInput
  }

  export type Redhat_DistributionCreateManyInput = {
    id?: string
    text: string
    documentId?: string | null
    tlpId?: string | null
  }

  export type Redhat_DistributionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_DistributionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_TlpCreateInput = {
    id?: string
    label: string
    url: string
    distribution?: Redhat_DistributionCreateNestedOneWithoutTlpInput
  }

  export type Redhat_TlpUncheckedCreateInput = {
    id?: string
    label: string
    url: string
    distributionId?: string | null
  }

  export type Redhat_TlpUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    distribution?: Redhat_DistributionUpdateOneWithoutTlpNestedInput
  }

  export type Redhat_TlpUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_TlpCreateManyInput = {
    id?: string
    label: string
    url: string
    distributionId?: string | null
  }

  export type Redhat_TlpUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TlpUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Document_NoteCreateInput = {
    id?: string
    category: string
    text: string
    title: string
    document?: Redhat_DocumentCreateNestedOneWithoutNotesInput
  }

  export type Redhat_Document_NoteUncheckedCreateInput = {
    id?: string
    category: string
    text: string
    title: string
    documentId?: string | null
  }

  export type Redhat_Document_NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutNotesNestedInput
  }

  export type Redhat_Document_NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Document_NoteCreateManyInput = {
    id?: string
    category: string
    text: string
    title: string
    documentId?: string | null
  }

  export type Redhat_Document_NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_PublisherCreateInput = {
    id?: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
    document?: Redhat_DocumentCreateNestedOneWithoutPublisherInput
  }

  export type Redhat_PublisherUncheckedCreateInput = {
    id?: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
    documentId?: string | null
  }

  export type Redhat_PublisherUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutPublisherNestedInput
  }

  export type Redhat_PublisherUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_PublisherCreateManyInput = {
    id?: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
    documentId?: string | null
  }

  export type Redhat_PublisherUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_PublisherUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Document_ReferenceCreateInput = {
    id?: string
    category: string
    summary: string
    url: string
    document?: Redhat_DocumentCreateNestedOneWithoutReferencesInput
  }

  export type Redhat_Document_ReferenceUncheckedCreateInput = {
    id?: string
    category: string
    summary: string
    url: string
    documentId?: string | null
  }

  export type Redhat_Document_ReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutReferencesNestedInput
  }

  export type Redhat_Document_ReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Document_ReferenceCreateManyInput = {
    id?: string
    category: string
    summary: string
    url: string
    documentId?: string | null
  }

  export type Redhat_Document_ReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_ReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_VulnerabilityCreateInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateManyInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
  }

  export type Redhat_VulnerabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_VulnerabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_IdCreateInput = {
    id?: string
    system_name: string
    text: string
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutIdsInput
  }

  export type Redhat_Vulnerability_IdUncheckedCreateInput = {
    id?: string
    system_name: string
    text: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_IdUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutIdsNestedInput
  }

  export type Redhat_Vulnerability_IdUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_IdCreateManyInput = {
    id?: string
    system_name: string
    text: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_IdUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_IdUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_NoteCreateInput = {
    id?: string
    category: string
    text: string
    title: string
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutNotesInput
  }

  export type Redhat_Vulnerability_NoteUncheckedCreateInput = {
    id?: string
    category: string
    text: string
    title: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_NoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutNotesNestedInput
  }

  export type Redhat_Vulnerability_NoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_NoteCreateManyInput = {
    id?: string
    category: string
    text: string
    title: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_NoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_NoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ProductStatusCreateInput = {
    id?: string
    fixed?: Redhat_Vulnerability_ProductStatusCreatefixedInput | string[]
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutProduct_statusInput
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedCreateInput = {
    id?: string
    fixed?: Redhat_Vulnerability_ProductStatusCreatefixedInput | string[]
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ProductStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutProduct_statusNestedInput
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ProductStatusCreateManyInput = {
    id?: string
    fixed?: Redhat_Vulnerability_ProductStatusCreatefixedInput | string[]
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ProductStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ReferenceCreateInput = {
    id?: string
    category: string
    summary: string
    url: string
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutReferencesInput
  }

  export type Redhat_Vulnerability_ReferenceUncheckedCreateInput = {
    id?: string
    category: string
    summary: string
    url: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ReferenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutReferencesNestedInput
  }

  export type Redhat_Vulnerability_ReferenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ReferenceCreateManyInput = {
    id?: string
    category: string
    summary: string
    url: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ReferenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ReferenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_RemediationCreateInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutRemediationsInput
    restart_required?: Redhat_Vulnerability_RestartRequiredCreateNestedManyWithoutRemediationInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedCreateInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    vulnerabilityId: string
    restart_required?: Redhat_Vulnerability_RestartRequiredUncheckedCreateNestedManyWithoutRemediationInput
  }

  export type Redhat_Vulnerability_RemediationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutRemediationsNestedInput
    restart_required?: Redhat_Vulnerability_RestartRequiredUpdateManyWithoutRemediationNestedInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
    restart_required?: Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyWithoutRemediationNestedInput
  }

  export type Redhat_Vulnerability_RemediationCreateManyInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    vulnerabilityId: string
  }

  export type Redhat_Vulnerability_RemediationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredCreateInput = {
    id?: string
    category?: string
    remediation?: Redhat_Vulnerability_RemediationCreateNestedOneWithoutRestart_requiredInput
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedCreateInput = {
    id?: string
    category?: string
    remediationId: string
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    remediation?: Redhat_Vulnerability_RemediationUpdateOneWithoutRestart_requiredNestedInput
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    remediationId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredCreateManyInput = {
    id?: string
    category?: string
    remediationId: string
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    remediationId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ScoreCreateInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3CreateNestedOneWithoutScoreInput
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutScoresInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedCreateInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    vulnerabilityId: string
    cvss_v3?: Redhat_Vulnerability_CvssV3UncheckedCreateNestedOneWithoutScoreInput
  }

  export type Redhat_Vulnerability_ScoreUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3UpdateOneWithoutScoreNestedInput
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutScoresNestedInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
    cvss_v3?: Redhat_Vulnerability_CvssV3UncheckedUpdateOneWithoutScoreNestedInput
  }

  export type Redhat_Vulnerability_ScoreCreateManyInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    vulnerabilityId: string
  }

  export type Redhat_Vulnerability_ScoreUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CvssV3CreateInput = {
    id?: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
    score?: Redhat_Vulnerability_ScoreCreateNestedOneWithoutCvss_v3Input
  }

  export type Redhat_Vulnerability_CvssV3UncheckedCreateInput = {
    id?: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
    scoreId: string
  }

  export type Redhat_Vulnerability_CvssV3UpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    score?: Redhat_Vulnerability_ScoreUpdateOneWithoutCvss_v3NestedInput
  }

  export type Redhat_Vulnerability_CvssV3UncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    scoreId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CvssV3CreateManyInput = {
    id?: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
    scoreId: string
  }

  export type Redhat_Vulnerability_CvssV3UpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CvssV3UncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    scoreId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ThreatCreateInput = {
    id?: string
    category: string
    details: string
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutThreatsInput
  }

  export type Redhat_Vulnerability_ThreatUncheckedCreateInput = {
    id?: string
    category: string
    details: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ThreatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutThreatsNestedInput
  }

  export type Redhat_Vulnerability_ThreatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ThreatCreateManyInput = {
    id?: string
    category: string
    details: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_ThreatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ThreatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_CweCreateInput = {
    id?: string
    cweId: string
    name: string
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutCweInput
  }

  export type Redhat_Vulnerability_CweUncheckedCreateInput = {
    id?: string
    cweId: string
    name: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_CweUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutCweNestedInput
  }

  export type Redhat_Vulnerability_CweUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_CweCreateManyInput = {
    id?: string
    cweId: string
    name: string
    vulnerabilityId?: string | null
  }

  export type Redhat_Vulnerability_CweUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CweUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    vulnerabilityId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type vmwareCountOrderByAggregateInput = {
    cve?: SortOrder
    synopsis?: SortOrder
    severity?: SortOrder
    date?: SortOrder
    link?: SortOrder
    detail?: SortOrder
  }

  export type vmwareMaxOrderByAggregateInput = {
    cve?: SortOrder
    synopsis?: SortOrder
    severity?: SortOrder
    date?: SortOrder
    link?: SortOrder
    detail?: SortOrder
  }

  export type vmwareMinOrderByAggregateInput = {
    cve?: SortOrder
    synopsis?: SortOrder
    severity?: SortOrder
    date?: SortOrder
    link?: SortOrder
    detail?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ciscoCountOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    title?: SortOrder
    impact?: SortOrder
    version?: SortOrder
    last_updated?: SortOrder
    clean_cves?: SortOrder
  }

  export type ciscoMaxOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    title?: SortOrder
    impact?: SortOrder
    version?: SortOrder
    last_updated?: SortOrder
  }

  export type ciscoMinOrderByAggregateInput = {
    id?: SortOrder
    link?: SortOrder
    title?: SortOrder
    impact?: SortOrder
    version?: SortOrder
    last_updated?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type oracleCountOrderByAggregateInput = {
    id?: SortOrder
    affected_product?: SortOrder
    affected_product_link?: SortOrder
    patch_document?: SortOrder
    patch_document_link?: SortOrder
  }

  export type oracleAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type oracleMaxOrderByAggregateInput = {
    id?: SortOrder
    affected_product?: SortOrder
    affected_product_link?: SortOrder
    patch_document?: SortOrder
    patch_document_link?: SortOrder
  }

  export type oracleMinOrderByAggregateInput = {
    id?: SortOrder
    affected_product?: SortOrder
    affected_product_link?: SortOrder
    patch_document?: SortOrder
    patch_document_link?: SortOrder
  }

  export type oracleSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type microsoftCountOrderByAggregateInput = {
    cve?: SortOrder
    release_date?: SortOrder
    revision_date?: SortOrder
    cve_link?: SortOrder
    cve_title?: SortOrder
    impact?: SortOrder
    severity?: SortOrder
    tag?: SortOrder
  }

  export type microsoftMaxOrderByAggregateInput = {
    cve?: SortOrder
    release_date?: SortOrder
    revision_date?: SortOrder
    cve_link?: SortOrder
    cve_title?: SortOrder
    impact?: SortOrder
    severity?: SortOrder
    tag?: SortOrder
  }

  export type microsoftMinOrderByAggregateInput = {
    cve?: SortOrder
    release_date?: SortOrder
    revision_date?: SortOrder
    cve_link?: SortOrder
    cve_title?: SortOrder
    impact?: SortOrder
    severity?: SortOrder
    tag?: SortOrder
  }

  export type hackernewsCountOrderByAggregateInput = {
    title?: SortOrder
    link?: SortOrder
    img?: SortOrder
    date?: SortOrder
    description?: SortOrder
    detail?: SortOrder
  }

  export type hackernewsMaxOrderByAggregateInput = {
    title?: SortOrder
    link?: SortOrder
    img?: SortOrder
    date?: SortOrder
    description?: SortOrder
    detail?: SortOrder
  }

  export type hackernewsMinOrderByAggregateInput = {
    title?: SortOrder
    link?: SortOrder
    img?: SortOrder
    date?: SortOrder
    description?: SortOrder
    detail?: SortOrder
  }

  export type Redhat_DocumentNullableRelationFilter = {
    is?: Redhat_DocumentWhereInput | null
    isNot?: Redhat_DocumentWhereInput | null
  }

  export type Redhat_VulnerabilityListRelationFilter = {
    every?: Redhat_VulnerabilityWhereInput
    some?: Redhat_VulnerabilityWhereInput
    none?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RedhatCountOrderByAggregateInput = {
    id?: SortOrder
    RHSA?: SortOrder
    severity?: SortOrder
    released_on?: SortOrder
    CVEs?: SortOrder
    bugzillas?: SortOrder
    released_packages?: SortOrder
    resource_url?: SortOrder
  }

  export type RedhatMaxOrderByAggregateInput = {
    id?: SortOrder
    RHSA?: SortOrder
    severity?: SortOrder
    released_on?: SortOrder
    resource_url?: SortOrder
  }

  export type RedhatMinOrderByAggregateInput = {
    id?: SortOrder
    RHSA?: SortOrder
    severity?: SortOrder
    released_on?: SortOrder
    resource_url?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type Redhat_AggregateSeverityNullableRelationFilter = {
    is?: Redhat_AggregateSeverityWhereInput | null
    isNot?: Redhat_AggregateSeverityWhereInput | null
  }

  export type Redhat_DistributionNullableRelationFilter = {
    is?: Redhat_DistributionWhereInput | null
    isNot?: Redhat_DistributionWhereInput | null
  }

  export type Redhat_PublisherNullableRelationFilter = {
    is?: Redhat_PublisherWhereInput | null
    isNot?: Redhat_PublisherWhereInput | null
  }

  export type Redhat_Document_NoteListRelationFilter = {
    every?: Redhat_Document_NoteWhereInput
    some?: Redhat_Document_NoteWhereInput
    none?: Redhat_Document_NoteWhereInput
  }

  export type Redhat_Document_ReferenceListRelationFilter = {
    every?: Redhat_Document_ReferenceWhereInput
    some?: Redhat_Document_ReferenceWhereInput
    none?: Redhat_Document_ReferenceWhereInput
  }

  export type RedhatNullableRelationFilter = {
    is?: RedhatWhereInput | null
    isNot?: RedhatWhereInput | null
  }

  export type Redhat_TrackingListRelationFilter = {
    every?: Redhat_TrackingWhereInput
    some?: Redhat_TrackingWhereInput
    none?: Redhat_TrackingWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Redhat_Document_NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Document_ReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_TrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    csaf_version?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
    aggregateSeverityId?: SortOrder
    distributionId?: SortOrder
    publisherId?: SortOrder
  }

  export type Redhat_DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    csaf_version?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
    aggregateSeverityId?: SortOrder
    distributionId?: SortOrder
    publisherId?: SortOrder
  }

  export type Redhat_DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    csaf_version?: SortOrder
    lang?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
    aggregateSeverityId?: SortOrder
    distributionId?: SortOrder
    publisherId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type Redhat_TrackingCountOrderByAggregateInput = {
    id?: SortOrder
    current_release_date?: SortOrder
    ID?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_TrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    current_release_date?: SortOrder
    ID?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_TrackingMinOrderByAggregateInput = {
    id?: SortOrder
    current_release_date?: SortOrder
    ID?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_AggregateSeverityCountOrderByAggregateInput = {
    id?: SortOrder
    namespace?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_AggregateSeverityMaxOrderByAggregateInput = {
    id?: SortOrder
    namespace?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_AggregateSeverityMinOrderByAggregateInput = {
    id?: SortOrder
    namespace?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_TlpNullableRelationFilter = {
    is?: Redhat_TlpWhereInput | null
    isNot?: Redhat_TlpWhereInput | null
  }

  export type Redhat_DistributionCountOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
    tlpId?: SortOrder
  }

  export type Redhat_DistributionMaxOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
    tlpId?: SortOrder
  }

  export type Redhat_DistributionMinOrderByAggregateInput = {
    id?: SortOrder
    text?: SortOrder
    documentId?: SortOrder
    tlpId?: SortOrder
  }

  export type Redhat_TlpCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    url?: SortOrder
    distributionId?: SortOrder
  }

  export type Redhat_TlpMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    url?: SortOrder
    distributionId?: SortOrder
  }

  export type Redhat_TlpMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    url?: SortOrder
    distributionId?: SortOrder
  }

  export type Redhat_Document_NoteCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Document_NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Document_NoteMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_PublisherCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    contact_details?: SortOrder
    issuing_authority?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_PublisherMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    contact_details?: SortOrder
    issuing_authority?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_PublisherMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    contact_details?: SortOrder
    issuing_authority?: SortOrder
    name?: SortOrder
    namespace?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Document_ReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Document_ReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Document_ReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    documentId?: SortOrder
  }

  export type Redhat_Vulnerability_IdListRelationFilter = {
    every?: Redhat_Vulnerability_IdWhereInput
    some?: Redhat_Vulnerability_IdWhereInput
    none?: Redhat_Vulnerability_IdWhereInput
  }

  export type Redhat_Vulnerability_NoteListRelationFilter = {
    every?: Redhat_Vulnerability_NoteWhereInput
    some?: Redhat_Vulnerability_NoteWhereInput
    none?: Redhat_Vulnerability_NoteWhereInput
  }

  export type Redhat_Vulnerability_ProductStatusNullableRelationFilter = {
    is?: Redhat_Vulnerability_ProductStatusWhereInput | null
    isNot?: Redhat_Vulnerability_ProductStatusWhereInput | null
  }

  export type Redhat_Vulnerability_ReferenceListRelationFilter = {
    every?: Redhat_Vulnerability_ReferenceWhereInput
    some?: Redhat_Vulnerability_ReferenceWhereInput
    none?: Redhat_Vulnerability_ReferenceWhereInput
  }

  export type Redhat_Vulnerability_RemediationListRelationFilter = {
    every?: Redhat_Vulnerability_RemediationWhereInput
    some?: Redhat_Vulnerability_RemediationWhereInput
    none?: Redhat_Vulnerability_RemediationWhereInput
  }

  export type Redhat_Vulnerability_ScoreListRelationFilter = {
    every?: Redhat_Vulnerability_ScoreWhereInput
    some?: Redhat_Vulnerability_ScoreWhereInput
    none?: Redhat_Vulnerability_ScoreWhereInput
  }

  export type Redhat_Vulnerability_ThreatListRelationFilter = {
    every?: Redhat_Vulnerability_ThreatWhereInput
    some?: Redhat_Vulnerability_ThreatWhereInput
    none?: Redhat_Vulnerability_ThreatWhereInput
  }

  export type Redhat_Vulnerability_CweNullableRelationFilter = {
    is?: Redhat_Vulnerability_CweWhereInput | null
    isNot?: Redhat_Vulnerability_CweWhereInput | null
  }

  export type Redhat_Vulnerability_IdOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_NoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_ReferenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_RemediationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_ScoreOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_ThreatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_VulnerabilityCountOrderByAggregateInput = {
    id?: SortOrder
    cve?: SortOrder
    discovery_date?: SortOrder
    release_date?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
  }

  export type Redhat_VulnerabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    cve?: SortOrder
    discovery_date?: SortOrder
    release_date?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
  }

  export type Redhat_VulnerabilityMinOrderByAggregateInput = {
    id?: SortOrder
    cve?: SortOrder
    discovery_date?: SortOrder
    release_date?: SortOrder
    title?: SortOrder
    redhatId?: SortOrder
  }

  export type Redhat_VulnerabilityNullableRelationFilter = {
    is?: Redhat_VulnerabilityWhereInput | null
    isNot?: Redhat_VulnerabilityWhereInput | null
  }

  export type Redhat_Vulnerability_IdCountOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    text?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_IdMaxOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    text?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_IdMinOrderByAggregateInput = {
    id?: SortOrder
    system_name?: SortOrder
    text?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_NoteCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_NoteMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_NoteMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    text?: SortOrder
    title?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ProductStatusCountOrderByAggregateInput = {
    id?: SortOrder
    fixed?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ProductStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ProductStatusMinOrderByAggregateInput = {
    id?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ReferenceCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ReferenceMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ReferenceMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    summary?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_RestartRequiredListRelationFilter = {
    every?: Redhat_Vulnerability_RestartRequiredWhereInput
    some?: Redhat_Vulnerability_RestartRequiredWhereInput
    none?: Redhat_Vulnerability_RestartRequiredWhereInput
  }

  export type Redhat_Vulnerability_RestartRequiredOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Redhat_Vulnerability_RemediationCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    product_ids?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_RemediationMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_RemediationMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    url?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_RemediationNullableRelationFilter = {
    is?: Redhat_Vulnerability_RemediationWhereInput | null
    isNot?: Redhat_Vulnerability_RemediationWhereInput | null
  }

  export type Redhat_Vulnerability_RestartRequiredCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    remediationId?: SortOrder
  }

  export type Redhat_Vulnerability_RestartRequiredMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    remediationId?: SortOrder
  }

  export type Redhat_Vulnerability_RestartRequiredMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    remediationId?: SortOrder
  }

  export type Redhat_Vulnerability_CvssV3NullableRelationFilter = {
    is?: Redhat_Vulnerability_CvssV3WhereInput | null
    isNot?: Redhat_Vulnerability_CvssV3WhereInput | null
  }

  export type Redhat_Vulnerability_ScoreCountOrderByAggregateInput = {
    id?: SortOrder
    products?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ScoreMaxOrderByAggregateInput = {
    id?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ScoreMinOrderByAggregateInput = {
    id?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ScoreNullableRelationFilter = {
    is?: Redhat_Vulnerability_ScoreWhereInput | null
    isNot?: Redhat_Vulnerability_ScoreWhereInput | null
  }

  export type Redhat_Vulnerability_CvssV3CountOrderByAggregateInput = {
    id?: SortOrder
    attackComplexity?: SortOrder
    attackVector?: SortOrder
    availabilityImpact?: SortOrder
    baseScore?: SortOrder
    baseSeverity?: SortOrder
    confidentialityImpact?: SortOrder
    integrityImpact?: SortOrder
    privilegesRequired?: SortOrder
    scope?: SortOrder
    userInteraction?: SortOrder
    vectorString?: SortOrder
    version?: SortOrder
    scoreId?: SortOrder
  }

  export type Redhat_Vulnerability_CvssV3AvgOrderByAggregateInput = {
    baseScore?: SortOrder
  }

  export type Redhat_Vulnerability_CvssV3MaxOrderByAggregateInput = {
    id?: SortOrder
    attackComplexity?: SortOrder
    attackVector?: SortOrder
    availabilityImpact?: SortOrder
    baseScore?: SortOrder
    baseSeverity?: SortOrder
    confidentialityImpact?: SortOrder
    integrityImpact?: SortOrder
    privilegesRequired?: SortOrder
    scope?: SortOrder
    userInteraction?: SortOrder
    vectorString?: SortOrder
    version?: SortOrder
    scoreId?: SortOrder
  }

  export type Redhat_Vulnerability_CvssV3MinOrderByAggregateInput = {
    id?: SortOrder
    attackComplexity?: SortOrder
    attackVector?: SortOrder
    availabilityImpact?: SortOrder
    baseScore?: SortOrder
    baseSeverity?: SortOrder
    confidentialityImpact?: SortOrder
    integrityImpact?: SortOrder
    privilegesRequired?: SortOrder
    scope?: SortOrder
    userInteraction?: SortOrder
    vectorString?: SortOrder
    version?: SortOrder
    scoreId?: SortOrder
  }

  export type Redhat_Vulnerability_CvssV3SumOrderByAggregateInput = {
    baseScore?: SortOrder
  }

  export type Redhat_Vulnerability_ThreatCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ThreatMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_ThreatMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    details?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_CweCountOrderByAggregateInput = {
    id?: SortOrder
    cweId?: SortOrder
    name?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_CweMaxOrderByAggregateInput = {
    id?: SortOrder
    cweId?: SortOrder
    name?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type Redhat_Vulnerability_CweMinOrderByAggregateInput = {
    id?: SortOrder
    cweId?: SortOrder
    name?: SortOrder
    vulnerabilityId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type ciscoCreateclean_cvesInput = {
    set: string[]
  }

  export type ciscoUpdateclean_cvesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RedhatCreateCVEsInput = {
    set: string[]
  }

  export type RedhatCreatebugzillasInput = {
    set: string[]
  }

  export type RedhatCreatereleased_packagesInput = {
    set: string[]
  }

  export type Redhat_DocumentCreateNestedOneWithoutRedhatInput = {
    create?: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutRedhatInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_VulnerabilityCreateNestedManyWithoutRedhatInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput> | Redhat_VulnerabilityCreateWithoutRedhatInput[] | Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput[]
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput | Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput[]
    createMany?: Redhat_VulnerabilityCreateManyRedhatInputEnvelope
    connect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
  }

  export type Redhat_DocumentUncheckedCreateNestedOneWithoutRedhatInput = {
    create?: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutRedhatInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_VulnerabilityUncheckedCreateNestedManyWithoutRedhatInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput> | Redhat_VulnerabilityCreateWithoutRedhatInput[] | Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput[]
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput | Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput[]
    createMany?: Redhat_VulnerabilityCreateManyRedhatInputEnvelope
    connect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
  }

  export type RedhatUpdateCVEsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RedhatUpdatebugzillasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type RedhatUpdatereleased_packagesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Redhat_DocumentUpdateOneWithoutRedhatNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutRedhatInput
    upsert?: Redhat_DocumentUpsertWithoutRedhatInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutRedhatInput, Redhat_DocumentUpdateWithoutRedhatInput>, Redhat_DocumentUncheckedUpdateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityUpdateManyWithoutRedhatNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput> | Redhat_VulnerabilityCreateWithoutRedhatInput[] | Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput[]
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput | Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput[]
    upsert?: Redhat_VulnerabilityUpsertWithWhereUniqueWithoutRedhatInput | Redhat_VulnerabilityUpsertWithWhereUniqueWithoutRedhatInput[]
    createMany?: Redhat_VulnerabilityCreateManyRedhatInputEnvelope
    set?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    disconnect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    delete?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    connect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    update?: Redhat_VulnerabilityUpdateWithWhereUniqueWithoutRedhatInput | Redhat_VulnerabilityUpdateWithWhereUniqueWithoutRedhatInput[]
    updateMany?: Redhat_VulnerabilityUpdateManyWithWhereWithoutRedhatInput | Redhat_VulnerabilityUpdateManyWithWhereWithoutRedhatInput[]
    deleteMany?: Redhat_VulnerabilityScalarWhereInput | Redhat_VulnerabilityScalarWhereInput[]
  }

  export type Redhat_DocumentUncheckedUpdateOneWithoutRedhatNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutRedhatInput
    upsert?: Redhat_DocumentUpsertWithoutRedhatInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutRedhatInput, Redhat_DocumentUpdateWithoutRedhatInput>, Redhat_DocumentUncheckedUpdateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityUncheckedUpdateManyWithoutRedhatNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput> | Redhat_VulnerabilityCreateWithoutRedhatInput[] | Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput[]
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput | Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput[]
    upsert?: Redhat_VulnerabilityUpsertWithWhereUniqueWithoutRedhatInput | Redhat_VulnerabilityUpsertWithWhereUniqueWithoutRedhatInput[]
    createMany?: Redhat_VulnerabilityCreateManyRedhatInputEnvelope
    set?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    disconnect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    delete?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    connect?: Redhat_VulnerabilityWhereUniqueInput | Redhat_VulnerabilityWhereUniqueInput[]
    update?: Redhat_VulnerabilityUpdateWithWhereUniqueWithoutRedhatInput | Redhat_VulnerabilityUpdateWithWhereUniqueWithoutRedhatInput[]
    updateMany?: Redhat_VulnerabilityUpdateManyWithWhereWithoutRedhatInput | Redhat_VulnerabilityUpdateManyWithWhereWithoutRedhatInput[]
    deleteMany?: Redhat_VulnerabilityScalarWhereInput | Redhat_VulnerabilityScalarWhereInput[]
  }

  export type Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_AggregateSeverityCreateOrConnectWithoutDocumentInput
    connect?: Redhat_AggregateSeverityWhereUniqueInput
  }

  export type Redhat_DistributionCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutDocumentInput
    connect?: Redhat_DistributionWhereUniqueInput
  }

  export type Redhat_PublisherCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_PublisherCreateOrConnectWithoutDocumentInput
    connect?: Redhat_PublisherWhereUniqueInput
  }

  export type Redhat_Document_NoteCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput> | Redhat_Document_NoteCreateWithoutDocumentInput[] | Redhat_Document_NoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_NoteCreateOrConnectWithoutDocumentInput | Redhat_Document_NoteCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_Document_NoteCreateManyDocumentInputEnvelope
    connect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
  }

  export type Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput> | Redhat_Document_ReferenceCreateWithoutDocumentInput[] | Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput | Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_Document_ReferenceCreateManyDocumentInputEnvelope
    connect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
  }

  export type RedhatCreateNestedOneWithoutDocumentInput = {
    create?: XOR<RedhatCreateWithoutDocumentInput, RedhatUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: RedhatCreateOrConnectWithoutDocumentInput
    connect?: RedhatWhereUniqueInput
  }

  export type Redhat_TrackingCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput> | Redhat_TrackingCreateWithoutDocumentInput[] | Redhat_TrackingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_TrackingCreateOrConnectWithoutDocumentInput | Redhat_TrackingCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_TrackingCreateManyDocumentInputEnvelope
    connect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
  }

  export type Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_AggregateSeverityCreateOrConnectWithoutDocumentInput
    connect?: Redhat_AggregateSeverityWhereUniqueInput
  }

  export type Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutDocumentInput
    connect?: Redhat_DistributionWhereUniqueInput
  }

  export type Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput = {
    create?: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_PublisherCreateOrConnectWithoutDocumentInput
    connect?: Redhat_PublisherWhereUniqueInput
  }

  export type Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput> | Redhat_Document_NoteCreateWithoutDocumentInput[] | Redhat_Document_NoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_NoteCreateOrConnectWithoutDocumentInput | Redhat_Document_NoteCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_Document_NoteCreateManyDocumentInputEnvelope
    connect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
  }

  export type Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput> | Redhat_Document_ReferenceCreateWithoutDocumentInput[] | Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput | Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_Document_ReferenceCreateManyDocumentInputEnvelope
    connect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
  }

  export type Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput> | Redhat_TrackingCreateWithoutDocumentInput[] | Redhat_TrackingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_TrackingCreateOrConnectWithoutDocumentInput | Redhat_TrackingCreateOrConnectWithoutDocumentInput[]
    createMany?: Redhat_TrackingCreateManyDocumentInputEnvelope
    connect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_AggregateSeverityCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_AggregateSeverityUpsertWithoutDocumentInput
    disconnect?: Redhat_AggregateSeverityWhereInput | boolean
    delete?: Redhat_AggregateSeverityWhereInput | boolean
    connect?: Redhat_AggregateSeverityWhereUniqueInput
    update?: XOR<XOR<Redhat_AggregateSeverityUpdateToOneWithWhereWithoutDocumentInput, Redhat_AggregateSeverityUpdateWithoutDocumentInput>, Redhat_AggregateSeverityUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_DistributionUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_DistributionUpsertWithoutDocumentInput
    disconnect?: Redhat_DistributionWhereInput | boolean
    delete?: Redhat_DistributionWhereInput | boolean
    connect?: Redhat_DistributionWhereUniqueInput
    update?: XOR<XOR<Redhat_DistributionUpdateToOneWithWhereWithoutDocumentInput, Redhat_DistributionUpdateWithoutDocumentInput>, Redhat_DistributionUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_PublisherUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_PublisherCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_PublisherUpsertWithoutDocumentInput
    disconnect?: Redhat_PublisherWhereInput | boolean
    delete?: Redhat_PublisherWhereInput | boolean
    connect?: Redhat_PublisherWhereUniqueInput
    update?: XOR<XOR<Redhat_PublisherUpdateToOneWithWhereWithoutDocumentInput, Redhat_PublisherUpdateWithoutDocumentInput>, Redhat_PublisherUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput> | Redhat_Document_NoteCreateWithoutDocumentInput[] | Redhat_Document_NoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_NoteCreateOrConnectWithoutDocumentInput | Redhat_Document_NoteCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_Document_NoteUpsertWithWhereUniqueWithoutDocumentInput | Redhat_Document_NoteUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_Document_NoteCreateManyDocumentInputEnvelope
    set?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    disconnect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    delete?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    connect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    update?: Redhat_Document_NoteUpdateWithWhereUniqueWithoutDocumentInput | Redhat_Document_NoteUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_Document_NoteUpdateManyWithWhereWithoutDocumentInput | Redhat_Document_NoteUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_Document_NoteScalarWhereInput | Redhat_Document_NoteScalarWhereInput[]
  }

  export type Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput> | Redhat_Document_ReferenceCreateWithoutDocumentInput[] | Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput | Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_Document_ReferenceUpsertWithWhereUniqueWithoutDocumentInput | Redhat_Document_ReferenceUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_Document_ReferenceCreateManyDocumentInputEnvelope
    set?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    disconnect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    delete?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    connect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    update?: Redhat_Document_ReferenceUpdateWithWhereUniqueWithoutDocumentInput | Redhat_Document_ReferenceUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_Document_ReferenceUpdateManyWithWhereWithoutDocumentInput | Redhat_Document_ReferenceUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_Document_ReferenceScalarWhereInput | Redhat_Document_ReferenceScalarWhereInput[]
  }

  export type RedhatUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<RedhatCreateWithoutDocumentInput, RedhatUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: RedhatCreateOrConnectWithoutDocumentInput
    upsert?: RedhatUpsertWithoutDocumentInput
    disconnect?: RedhatWhereInput | boolean
    delete?: RedhatWhereInput | boolean
    connect?: RedhatWhereUniqueInput
    update?: XOR<XOR<RedhatUpdateToOneWithWhereWithoutDocumentInput, RedhatUpdateWithoutDocumentInput>, RedhatUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_TrackingUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput> | Redhat_TrackingCreateWithoutDocumentInput[] | Redhat_TrackingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_TrackingCreateOrConnectWithoutDocumentInput | Redhat_TrackingCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_TrackingUpsertWithWhereUniqueWithoutDocumentInput | Redhat_TrackingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_TrackingCreateManyDocumentInputEnvelope
    set?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    disconnect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    delete?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    connect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    update?: Redhat_TrackingUpdateWithWhereUniqueWithoutDocumentInput | Redhat_TrackingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_TrackingUpdateManyWithWhereWithoutDocumentInput | Redhat_TrackingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_TrackingScalarWhereInput | Redhat_TrackingScalarWhereInput[]
  }

  export type Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_AggregateSeverityCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_AggregateSeverityUpsertWithoutDocumentInput
    disconnect?: Redhat_AggregateSeverityWhereInput | boolean
    delete?: Redhat_AggregateSeverityWhereInput | boolean
    connect?: Redhat_AggregateSeverityWhereUniqueInput
    update?: XOR<XOR<Redhat_AggregateSeverityUpdateToOneWithWhereWithoutDocumentInput, Redhat_AggregateSeverityUpdateWithoutDocumentInput>, Redhat_AggregateSeverityUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_DistributionUpsertWithoutDocumentInput
    disconnect?: Redhat_DistributionWhereInput | boolean
    delete?: Redhat_DistributionWhereInput | boolean
    connect?: Redhat_DistributionWhereUniqueInput
    update?: XOR<XOR<Redhat_DistributionUpdateToOneWithWhereWithoutDocumentInput, Redhat_DistributionUpdateWithoutDocumentInput>, Redhat_DistributionUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput = {
    create?: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
    connectOrCreate?: Redhat_PublisherCreateOrConnectWithoutDocumentInput
    upsert?: Redhat_PublisherUpsertWithoutDocumentInput
    disconnect?: Redhat_PublisherWhereInput | boolean
    delete?: Redhat_PublisherWhereInput | boolean
    connect?: Redhat_PublisherWhereUniqueInput
    update?: XOR<XOR<Redhat_PublisherUpdateToOneWithWhereWithoutDocumentInput, Redhat_PublisherUpdateWithoutDocumentInput>, Redhat_PublisherUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput> | Redhat_Document_NoteCreateWithoutDocumentInput[] | Redhat_Document_NoteUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_NoteCreateOrConnectWithoutDocumentInput | Redhat_Document_NoteCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_Document_NoteUpsertWithWhereUniqueWithoutDocumentInput | Redhat_Document_NoteUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_Document_NoteCreateManyDocumentInputEnvelope
    set?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    disconnect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    delete?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    connect?: Redhat_Document_NoteWhereUniqueInput | Redhat_Document_NoteWhereUniqueInput[]
    update?: Redhat_Document_NoteUpdateWithWhereUniqueWithoutDocumentInput | Redhat_Document_NoteUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_Document_NoteUpdateManyWithWhereWithoutDocumentInput | Redhat_Document_NoteUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_Document_NoteScalarWhereInput | Redhat_Document_NoteScalarWhereInput[]
  }

  export type Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput> | Redhat_Document_ReferenceCreateWithoutDocumentInput[] | Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput | Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_Document_ReferenceUpsertWithWhereUniqueWithoutDocumentInput | Redhat_Document_ReferenceUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_Document_ReferenceCreateManyDocumentInputEnvelope
    set?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    disconnect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    delete?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    connect?: Redhat_Document_ReferenceWhereUniqueInput | Redhat_Document_ReferenceWhereUniqueInput[]
    update?: Redhat_Document_ReferenceUpdateWithWhereUniqueWithoutDocumentInput | Redhat_Document_ReferenceUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_Document_ReferenceUpdateManyWithWhereWithoutDocumentInput | Redhat_Document_ReferenceUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_Document_ReferenceScalarWhereInput | Redhat_Document_ReferenceScalarWhereInput[]
  }

  export type Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput> | Redhat_TrackingCreateWithoutDocumentInput[] | Redhat_TrackingUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: Redhat_TrackingCreateOrConnectWithoutDocumentInput | Redhat_TrackingCreateOrConnectWithoutDocumentInput[]
    upsert?: Redhat_TrackingUpsertWithWhereUniqueWithoutDocumentInput | Redhat_TrackingUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: Redhat_TrackingCreateManyDocumentInputEnvelope
    set?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    disconnect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    delete?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    connect?: Redhat_TrackingWhereUniqueInput | Redhat_TrackingWhereUniqueInput[]
    update?: Redhat_TrackingUpdateWithWhereUniqueWithoutDocumentInput | Redhat_TrackingUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: Redhat_TrackingUpdateManyWithWhereWithoutDocumentInput | Redhat_TrackingUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: Redhat_TrackingScalarWhereInput | Redhat_TrackingScalarWhereInput[]
  }

  export type Redhat_DocumentCreateNestedOneWithoutTrackingInput = {
    create?: XOR<Redhat_DocumentCreateWithoutTrackingInput, Redhat_DocumentUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutTrackingInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_DocumentUpdateOneWithoutTrackingNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutTrackingInput, Redhat_DocumentUncheckedCreateWithoutTrackingInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutTrackingInput
    upsert?: Redhat_DocumentUpsertWithoutTrackingInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutTrackingInput, Redhat_DocumentUpdateWithoutTrackingInput>, Redhat_DocumentUncheckedUpdateWithoutTrackingInput>
  }

  export type Redhat_DocumentCreateNestedOneWithoutAggregate_severityInput = {
    create?: XOR<Redhat_DocumentCreateWithoutAggregate_severityInput, Redhat_DocumentUncheckedCreateWithoutAggregate_severityInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutAggregate_severityInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_DocumentUpdateOneWithoutAggregate_severityNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutAggregate_severityInput, Redhat_DocumentUncheckedCreateWithoutAggregate_severityInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutAggregate_severityInput
    upsert?: Redhat_DocumentUpsertWithoutAggregate_severityInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutAggregate_severityInput, Redhat_DocumentUpdateWithoutAggregate_severityInput>, Redhat_DocumentUncheckedUpdateWithoutAggregate_severityInput>
  }

  export type Redhat_TlpCreateNestedOneWithoutDistributionInput = {
    create?: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_TlpCreateOrConnectWithoutDistributionInput
    connect?: Redhat_TlpWhereUniqueInput
  }

  export type Redhat_DocumentCreateNestedOneWithoutDistributionInput = {
    create?: XOR<Redhat_DocumentCreateWithoutDistributionInput, Redhat_DocumentUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutDistributionInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_TlpUncheckedCreateNestedOneWithoutDistributionInput = {
    create?: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_TlpCreateOrConnectWithoutDistributionInput
    connect?: Redhat_TlpWhereUniqueInput
  }

  export type Redhat_TlpUpdateOneWithoutDistributionNestedInput = {
    create?: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_TlpCreateOrConnectWithoutDistributionInput
    upsert?: Redhat_TlpUpsertWithoutDistributionInput
    disconnect?: Redhat_TlpWhereInput | boolean
    delete?: Redhat_TlpWhereInput | boolean
    connect?: Redhat_TlpWhereUniqueInput
    update?: XOR<XOR<Redhat_TlpUpdateToOneWithWhereWithoutDistributionInput, Redhat_TlpUpdateWithoutDistributionInput>, Redhat_TlpUncheckedUpdateWithoutDistributionInput>
  }

  export type Redhat_DocumentUpdateOneWithoutDistributionNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutDistributionInput, Redhat_DocumentUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutDistributionInput
    upsert?: Redhat_DocumentUpsertWithoutDistributionInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutDistributionInput, Redhat_DocumentUpdateWithoutDistributionInput>, Redhat_DocumentUncheckedUpdateWithoutDistributionInput>
  }

  export type Redhat_TlpUncheckedUpdateOneWithoutDistributionNestedInput = {
    create?: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
    connectOrCreate?: Redhat_TlpCreateOrConnectWithoutDistributionInput
    upsert?: Redhat_TlpUpsertWithoutDistributionInput
    disconnect?: Redhat_TlpWhereInput | boolean
    delete?: Redhat_TlpWhereInput | boolean
    connect?: Redhat_TlpWhereUniqueInput
    update?: XOR<XOR<Redhat_TlpUpdateToOneWithWhereWithoutDistributionInput, Redhat_TlpUpdateWithoutDistributionInput>, Redhat_TlpUncheckedUpdateWithoutDistributionInput>
  }

  export type Redhat_DistributionCreateNestedOneWithoutTlpInput = {
    create?: XOR<Redhat_DistributionCreateWithoutTlpInput, Redhat_DistributionUncheckedCreateWithoutTlpInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutTlpInput
    connect?: Redhat_DistributionWhereUniqueInput
  }

  export type Redhat_DistributionUpdateOneWithoutTlpNestedInput = {
    create?: XOR<Redhat_DistributionCreateWithoutTlpInput, Redhat_DistributionUncheckedCreateWithoutTlpInput>
    connectOrCreate?: Redhat_DistributionCreateOrConnectWithoutTlpInput
    upsert?: Redhat_DistributionUpsertWithoutTlpInput
    disconnect?: Redhat_DistributionWhereInput | boolean
    delete?: Redhat_DistributionWhereInput | boolean
    connect?: Redhat_DistributionWhereUniqueInput
    update?: XOR<XOR<Redhat_DistributionUpdateToOneWithWhereWithoutTlpInput, Redhat_DistributionUpdateWithoutTlpInput>, Redhat_DistributionUncheckedUpdateWithoutTlpInput>
  }

  export type Redhat_DocumentCreateNestedOneWithoutNotesInput = {
    create?: XOR<Redhat_DocumentCreateWithoutNotesInput, Redhat_DocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutNotesInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_DocumentUpdateOneWithoutNotesNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutNotesInput, Redhat_DocumentUncheckedCreateWithoutNotesInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutNotesInput
    upsert?: Redhat_DocumentUpsertWithoutNotesInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutNotesInput, Redhat_DocumentUpdateWithoutNotesInput>, Redhat_DocumentUncheckedUpdateWithoutNotesInput>
  }

  export type Redhat_DocumentCreateNestedOneWithoutPublisherInput = {
    create?: XOR<Redhat_DocumentCreateWithoutPublisherInput, Redhat_DocumentUncheckedCreateWithoutPublisherInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutPublisherInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_DocumentUpdateOneWithoutPublisherNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutPublisherInput, Redhat_DocumentUncheckedCreateWithoutPublisherInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutPublisherInput
    upsert?: Redhat_DocumentUpsertWithoutPublisherInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutPublisherInput, Redhat_DocumentUpdateWithoutPublisherInput>, Redhat_DocumentUncheckedUpdateWithoutPublisherInput>
  }

  export type Redhat_DocumentCreateNestedOneWithoutReferencesInput = {
    create?: XOR<Redhat_DocumentCreateWithoutReferencesInput, Redhat_DocumentUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutReferencesInput
    connect?: Redhat_DocumentWhereUniqueInput
  }

  export type Redhat_DocumentUpdateOneWithoutReferencesNestedInput = {
    create?: XOR<Redhat_DocumentCreateWithoutReferencesInput, Redhat_DocumentUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: Redhat_DocumentCreateOrConnectWithoutReferencesInput
    upsert?: Redhat_DocumentUpsertWithoutReferencesInput
    disconnect?: Redhat_DocumentWhereInput | boolean
    delete?: Redhat_DocumentWhereInput | boolean
    connect?: Redhat_DocumentWhereUniqueInput
    update?: XOR<XOR<Redhat_DocumentUpdateToOneWithWhereWithoutReferencesInput, Redhat_DocumentUpdateWithoutReferencesInput>, Redhat_DocumentUncheckedUpdateWithoutReferencesInput>
  }

  export type Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_IdCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_NoteCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_ProductStatusCreateOrConnectWithoutVulnerabilityInput
    connect?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }

  export type Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_RemediationCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ScoreCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ThreatCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_CweCreateOrConnectWithoutVulnerabilityInput
    connect?: Redhat_Vulnerability_CweWhereUniqueInput
  }

  export type RedhatCreateNestedOneWithoutVulnerabilitiesInput = {
    create?: XOR<RedhatCreateWithoutVulnerabilitiesInput, RedhatUncheckedCreateWithoutVulnerabilitiesInput>
    connectOrCreate?: RedhatCreateOrConnectWithoutVulnerabilitiesInput
    connect?: RedhatWhereUniqueInput
  }

  export type Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_IdCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_NoteCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_ProductStatusCreateOrConnectWithoutVulnerabilityInput
    connect?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
  }

  export type Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_RemediationCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ScoreCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ThreatCreateManyVulnerabilityInputEnvelope
    connect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput = {
    create?: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_CweCreateOrConnectWithoutVulnerabilityInput
    connect?: Redhat_Vulnerability_CweWhereUniqueInput
  }

  export type Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_IdUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_IdCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    delete?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    connect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    update?: Redhat_Vulnerability_IdUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_IdUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_IdScalarWhereInput | Redhat_Vulnerability_IdScalarWhereInput[]
  }

  export type Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_NoteUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_NoteCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    delete?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    connect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    update?: Redhat_Vulnerability_NoteUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_NoteUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_NoteScalarWhereInput | Redhat_Vulnerability_NoteScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_ProductStatusCreateOrConnectWithoutVulnerabilityInput
    upsert?: Redhat_Vulnerability_ProductStatusUpsertWithoutVulnerabilityInput
    disconnect?: Redhat_Vulnerability_ProductStatusWhereInput | boolean
    delete?: Redhat_Vulnerability_ProductStatusWhereInput | boolean
    connect?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_ProductStatusUpdateToOneWithWhereWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUpdateWithoutVulnerabilityInput>, Redhat_Vulnerability_ProductStatusUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ReferenceUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    update?: Redhat_Vulnerability_ReferenceUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ReferenceUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ReferenceScalarWhereInput | Redhat_Vulnerability_ReferenceScalarWhereInput[]
  }

  export type Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_RemediationUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_RemediationCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    delete?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    update?: Redhat_Vulnerability_RemediationUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_RemediationUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_RemediationScalarWhereInput | Redhat_Vulnerability_RemediationScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ScoreUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ScoreCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    update?: Redhat_Vulnerability_ScoreUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ScoreUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ScoreScalarWhereInput | Redhat_Vulnerability_ScoreScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ThreatUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ThreatCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    update?: Redhat_Vulnerability_ThreatUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ThreatUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ThreatScalarWhereInput | Redhat_Vulnerability_ThreatScalarWhereInput[]
  }

  export type Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_CweCreateOrConnectWithoutVulnerabilityInput
    upsert?: Redhat_Vulnerability_CweUpsertWithoutVulnerabilityInput
    disconnect?: Redhat_Vulnerability_CweWhereInput | boolean
    delete?: Redhat_Vulnerability_CweWhereInput | boolean
    connect?: Redhat_Vulnerability_CweWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_CweUpdateToOneWithWhereWithoutVulnerabilityInput, Redhat_Vulnerability_CweUpdateWithoutVulnerabilityInput>, Redhat_Vulnerability_CweUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type RedhatUpdateOneWithoutVulnerabilitiesNestedInput = {
    create?: XOR<RedhatCreateWithoutVulnerabilitiesInput, RedhatUncheckedCreateWithoutVulnerabilitiesInput>
    connectOrCreate?: RedhatCreateOrConnectWithoutVulnerabilitiesInput
    upsert?: RedhatUpsertWithoutVulnerabilitiesInput
    disconnect?: RedhatWhereInput | boolean
    delete?: RedhatWhereInput | boolean
    connect?: RedhatWhereUniqueInput
    update?: XOR<XOR<RedhatUpdateToOneWithWhereWithoutVulnerabilitiesInput, RedhatUpdateWithoutVulnerabilitiesInput>, RedhatUncheckedUpdateWithoutVulnerabilitiesInput>
  }

  export type Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_IdUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_IdCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    delete?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    connect?: Redhat_Vulnerability_IdWhereUniqueInput | Redhat_Vulnerability_IdWhereUniqueInput[]
    update?: Redhat_Vulnerability_IdUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_IdUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_IdUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_IdScalarWhereInput | Redhat_Vulnerability_IdScalarWhereInput[]
  }

  export type Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_NoteUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_NoteCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    delete?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    connect?: Redhat_Vulnerability_NoteWhereUniqueInput | Redhat_Vulnerability_NoteWhereUniqueInput[]
    update?: Redhat_Vulnerability_NoteUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_NoteUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_NoteUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_NoteScalarWhereInput | Redhat_Vulnerability_NoteScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_ProductStatusCreateOrConnectWithoutVulnerabilityInput
    upsert?: Redhat_Vulnerability_ProductStatusUpsertWithoutVulnerabilityInput
    disconnect?: Redhat_Vulnerability_ProductStatusWhereInput | boolean
    delete?: Redhat_Vulnerability_ProductStatusWhereInput | boolean
    connect?: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_ProductStatusUpdateToOneWithWhereWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUpdateWithoutVulnerabilityInput>, Redhat_Vulnerability_ProductStatusUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ReferenceUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ReferenceWhereUniqueInput | Redhat_Vulnerability_ReferenceWhereUniqueInput[]
    update?: Redhat_Vulnerability_ReferenceUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ReferenceUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ReferenceUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ReferenceScalarWhereInput | Redhat_Vulnerability_ReferenceScalarWhereInput[]
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_RemediationUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_RemediationCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    delete?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput | Redhat_Vulnerability_RemediationWhereUniqueInput[]
    update?: Redhat_Vulnerability_RemediationUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_RemediationUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_RemediationUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_RemediationScalarWhereInput | Redhat_Vulnerability_RemediationScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ScoreUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ScoreCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput | Redhat_Vulnerability_ScoreWhereUniqueInput[]
    update?: Redhat_Vulnerability_ScoreUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ScoreUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ScoreUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ScoreScalarWhereInput | Redhat_Vulnerability_ScoreScalarWhereInput[]
  }

  export type Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput> | Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput[] | Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput[]
    connectOrCreate?: Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput[]
    upsert?: Redhat_Vulnerability_ThreatUpsertWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpsertWithWhereUniqueWithoutVulnerabilityInput[]
    createMany?: Redhat_Vulnerability_ThreatCreateManyVulnerabilityInputEnvelope
    set?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    delete?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    connect?: Redhat_Vulnerability_ThreatWhereUniqueInput | Redhat_Vulnerability_ThreatWhereUniqueInput[]
    update?: Redhat_Vulnerability_ThreatUpdateWithWhereUniqueWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpdateWithWhereUniqueWithoutVulnerabilityInput[]
    updateMany?: Redhat_Vulnerability_ThreatUpdateManyWithWhereWithoutVulnerabilityInput | Redhat_Vulnerability_ThreatUpdateManyWithWhereWithoutVulnerabilityInput[]
    deleteMany?: Redhat_Vulnerability_ThreatScalarWhereInput | Redhat_Vulnerability_ThreatScalarWhereInput[]
  }

  export type Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput = {
    create?: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
    connectOrCreate?: Redhat_Vulnerability_CweCreateOrConnectWithoutVulnerabilityInput
    upsert?: Redhat_Vulnerability_CweUpsertWithoutVulnerabilityInput
    disconnect?: Redhat_Vulnerability_CweWhereInput | boolean
    delete?: Redhat_Vulnerability_CweWhereInput | boolean
    connect?: Redhat_Vulnerability_CweWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_CweUpdateToOneWithWhereWithoutVulnerabilityInput, Redhat_Vulnerability_CweUpdateWithoutVulnerabilityInput>, Redhat_Vulnerability_CweUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutIdsInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutIdsInput, Redhat_VulnerabilityUncheckedCreateWithoutIdsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutIdsInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_VulnerabilityUpdateOneWithoutIdsNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutIdsInput, Redhat_VulnerabilityUncheckedCreateWithoutIdsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutIdsInput
    upsert?: Redhat_VulnerabilityUpsertWithoutIdsInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutIdsInput, Redhat_VulnerabilityUpdateWithoutIdsInput>, Redhat_VulnerabilityUncheckedUpdateWithoutIdsInput>
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutNotesInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutNotesInput, Redhat_VulnerabilityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutNotesInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_VulnerabilityUpdateOneWithoutNotesNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutNotesInput, Redhat_VulnerabilityUncheckedCreateWithoutNotesInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutNotesInput
    upsert?: Redhat_VulnerabilityUpsertWithoutNotesInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutNotesInput, Redhat_VulnerabilityUpdateWithoutNotesInput>, Redhat_VulnerabilityUncheckedUpdateWithoutNotesInput>
  }

  export type Redhat_Vulnerability_ProductStatusCreatefixedInput = {
    set: string[]
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutProduct_statusInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedCreateWithoutProduct_statusInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutProduct_statusInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_Vulnerability_ProductStatusUpdatefixedInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Redhat_VulnerabilityUpdateOneWithoutProduct_statusNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedCreateWithoutProduct_statusInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutProduct_statusInput
    upsert?: Redhat_VulnerabilityUpsertWithoutProduct_statusInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutProduct_statusInput, Redhat_VulnerabilityUpdateWithoutProduct_statusInput>, Redhat_VulnerabilityUncheckedUpdateWithoutProduct_statusInput>
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutReferencesInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutReferencesInput, Redhat_VulnerabilityUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutReferencesInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_VulnerabilityUpdateOneWithoutReferencesNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutReferencesInput, Redhat_VulnerabilityUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutReferencesInput
    upsert?: Redhat_VulnerabilityUpsertWithoutReferencesInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutReferencesInput, Redhat_VulnerabilityUpdateWithoutReferencesInput>, Redhat_VulnerabilityUncheckedUpdateWithoutReferencesInput>
  }

  export type Redhat_Vulnerability_RemediationCreateproduct_idsInput = {
    set: string[]
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutRemediationsInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRemediationsInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_Vulnerability_RestartRequiredCreateNestedManyWithoutRemediationInput = {
    create?: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput> | Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput[] | Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput[]
    connectOrCreate?: Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput[]
    createMany?: Redhat_Vulnerability_RestartRequiredCreateManyRemediationInputEnvelope
    connect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedCreateNestedManyWithoutRemediationInput = {
    create?: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput> | Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput[] | Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput[]
    connectOrCreate?: Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput[]
    createMany?: Redhat_Vulnerability_RestartRequiredCreateManyRemediationInputEnvelope
    connect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
  }

  export type Redhat_Vulnerability_RemediationUpdateproduct_idsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Redhat_VulnerabilityUpdateOneWithoutRemediationsNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedCreateWithoutRemediationsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutRemediationsInput
    upsert?: Redhat_VulnerabilityUpsertWithoutRemediationsInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutRemediationsInput, Redhat_VulnerabilityUpdateWithoutRemediationsInput>, Redhat_VulnerabilityUncheckedUpdateWithoutRemediationsInput>
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateManyWithoutRemediationNestedInput = {
    create?: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput> | Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput[] | Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput[]
    connectOrCreate?: Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput[]
    upsert?: Redhat_Vulnerability_RestartRequiredUpsertWithWhereUniqueWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpsertWithWhereUniqueWithoutRemediationInput[]
    createMany?: Redhat_Vulnerability_RestartRequiredCreateManyRemediationInputEnvelope
    set?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    delete?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    connect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    update?: Redhat_Vulnerability_RestartRequiredUpdateWithWhereUniqueWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpdateWithWhereUniqueWithoutRemediationInput[]
    updateMany?: Redhat_Vulnerability_RestartRequiredUpdateManyWithWhereWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpdateManyWithWhereWithoutRemediationInput[]
    deleteMany?: Redhat_Vulnerability_RestartRequiredScalarWhereInput | Redhat_Vulnerability_RestartRequiredScalarWhereInput[]
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyWithoutRemediationNestedInput = {
    create?: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput> | Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput[] | Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput[]
    connectOrCreate?: Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput[]
    upsert?: Redhat_Vulnerability_RestartRequiredUpsertWithWhereUniqueWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpsertWithWhereUniqueWithoutRemediationInput[]
    createMany?: Redhat_Vulnerability_RestartRequiredCreateManyRemediationInputEnvelope
    set?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    disconnect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    delete?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    connect?: Redhat_Vulnerability_RestartRequiredWhereUniqueInput | Redhat_Vulnerability_RestartRequiredWhereUniqueInput[]
    update?: Redhat_Vulnerability_RestartRequiredUpdateWithWhereUniqueWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpdateWithWhereUniqueWithoutRemediationInput[]
    updateMany?: Redhat_Vulnerability_RestartRequiredUpdateManyWithWhereWithoutRemediationInput | Redhat_Vulnerability_RestartRequiredUpdateManyWithWhereWithoutRemediationInput[]
    deleteMany?: Redhat_Vulnerability_RestartRequiredScalarWhereInput | Redhat_Vulnerability_RestartRequiredScalarWhereInput[]
  }

  export type Redhat_Vulnerability_RemediationCreateNestedOneWithoutRestart_requiredInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutRestart_requiredInput>
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutRestart_requiredInput
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput
  }

  export type Redhat_Vulnerability_RemediationUpdateOneWithoutRestart_requiredNestedInput = {
    create?: XOR<Redhat_Vulnerability_RemediationCreateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutRestart_requiredInput>
    connectOrCreate?: Redhat_Vulnerability_RemediationCreateOrConnectWithoutRestart_requiredInput
    upsert?: Redhat_Vulnerability_RemediationUpsertWithoutRestart_requiredInput
    disconnect?: Redhat_Vulnerability_RemediationWhereInput | boolean
    delete?: Redhat_Vulnerability_RemediationWhereInput | boolean
    connect?: Redhat_Vulnerability_RemediationWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_RemediationUpdateToOneWithWhereWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUpdateWithoutRestart_requiredInput>, Redhat_Vulnerability_RemediationUncheckedUpdateWithoutRestart_requiredInput>
  }

  export type Redhat_Vulnerability_ScoreCreateproductsInput = {
    set: string[]
  }

  export type Redhat_Vulnerability_CvssV3CreateNestedOneWithoutScoreInput = {
    create?: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
    connectOrCreate?: Redhat_Vulnerability_CvssV3CreateOrConnectWithoutScoreInput
    connect?: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutScoresInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutScoresInput, Redhat_VulnerabilityUncheckedCreateWithoutScoresInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutScoresInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_Vulnerability_CvssV3UncheckedCreateNestedOneWithoutScoreInput = {
    create?: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
    connectOrCreate?: Redhat_Vulnerability_CvssV3CreateOrConnectWithoutScoreInput
    connect?: Redhat_Vulnerability_CvssV3WhereUniqueInput
  }

  export type Redhat_Vulnerability_ScoreUpdateproductsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Redhat_Vulnerability_CvssV3UpdateOneWithoutScoreNestedInput = {
    create?: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
    connectOrCreate?: Redhat_Vulnerability_CvssV3CreateOrConnectWithoutScoreInput
    upsert?: Redhat_Vulnerability_CvssV3UpsertWithoutScoreInput
    disconnect?: Redhat_Vulnerability_CvssV3WhereInput | boolean
    delete?: Redhat_Vulnerability_CvssV3WhereInput | boolean
    connect?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_CvssV3UpdateToOneWithWhereWithoutScoreInput, Redhat_Vulnerability_CvssV3UpdateWithoutScoreInput>, Redhat_Vulnerability_CvssV3UncheckedUpdateWithoutScoreInput>
  }

  export type Redhat_VulnerabilityUpdateOneWithoutScoresNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutScoresInput, Redhat_VulnerabilityUncheckedCreateWithoutScoresInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutScoresInput
    upsert?: Redhat_VulnerabilityUpsertWithoutScoresInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutScoresInput, Redhat_VulnerabilityUpdateWithoutScoresInput>, Redhat_VulnerabilityUncheckedUpdateWithoutScoresInput>
  }

  export type Redhat_Vulnerability_CvssV3UncheckedUpdateOneWithoutScoreNestedInput = {
    create?: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
    connectOrCreate?: Redhat_Vulnerability_CvssV3CreateOrConnectWithoutScoreInput
    upsert?: Redhat_Vulnerability_CvssV3UpsertWithoutScoreInput
    disconnect?: Redhat_Vulnerability_CvssV3WhereInput | boolean
    delete?: Redhat_Vulnerability_CvssV3WhereInput | boolean
    connect?: Redhat_Vulnerability_CvssV3WhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_CvssV3UpdateToOneWithWhereWithoutScoreInput, Redhat_Vulnerability_CvssV3UpdateWithoutScoreInput>, Redhat_Vulnerability_CvssV3UncheckedUpdateWithoutScoreInput>
  }

  export type Redhat_Vulnerability_ScoreCreateNestedOneWithoutCvss_v3Input = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedCreateWithoutCvss_v3Input>
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutCvss_v3Input
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput
  }

  export type Redhat_Vulnerability_ScoreUpdateOneWithoutCvss_v3NestedInput = {
    create?: XOR<Redhat_Vulnerability_ScoreCreateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedCreateWithoutCvss_v3Input>
    connectOrCreate?: Redhat_Vulnerability_ScoreCreateOrConnectWithoutCvss_v3Input
    upsert?: Redhat_Vulnerability_ScoreUpsertWithoutCvss_v3Input
    disconnect?: Redhat_Vulnerability_ScoreWhereInput | boolean
    delete?: Redhat_Vulnerability_ScoreWhereInput | boolean
    connect?: Redhat_Vulnerability_ScoreWhereUniqueInput
    update?: XOR<XOR<Redhat_Vulnerability_ScoreUpdateToOneWithWhereWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUpdateWithoutCvss_v3Input>, Redhat_Vulnerability_ScoreUncheckedUpdateWithoutCvss_v3Input>
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutThreatsInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutThreatsInput, Redhat_VulnerabilityUncheckedCreateWithoutThreatsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutThreatsInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_VulnerabilityUpdateOneWithoutThreatsNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutThreatsInput, Redhat_VulnerabilityUncheckedCreateWithoutThreatsInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutThreatsInput
    upsert?: Redhat_VulnerabilityUpsertWithoutThreatsInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutThreatsInput, Redhat_VulnerabilityUpdateWithoutThreatsInput>, Redhat_VulnerabilityUncheckedUpdateWithoutThreatsInput>
  }

  export type Redhat_VulnerabilityCreateNestedOneWithoutCweInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutCweInput, Redhat_VulnerabilityUncheckedCreateWithoutCweInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutCweInput
    connect?: Redhat_VulnerabilityWhereUniqueInput
  }

  export type Redhat_VulnerabilityUpdateOneWithoutCweNestedInput = {
    create?: XOR<Redhat_VulnerabilityCreateWithoutCweInput, Redhat_VulnerabilityUncheckedCreateWithoutCweInput>
    connectOrCreate?: Redhat_VulnerabilityCreateOrConnectWithoutCweInput
    upsert?: Redhat_VulnerabilityUpsertWithoutCweInput
    disconnect?: Redhat_VulnerabilityWhereInput | boolean
    delete?: Redhat_VulnerabilityWhereInput | boolean
    connect?: Redhat_VulnerabilityWhereUniqueInput
    update?: XOR<XOR<Redhat_VulnerabilityUpdateToOneWithWhereWithoutCweInput, Redhat_VulnerabilityUpdateWithoutCweInput>, Redhat_VulnerabilityUncheckedUpdateWithoutCweInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type Redhat_DocumentCreateWithoutRedhatInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutRedhatInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutRedhatInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityCreateWithoutRedhatInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutRedhatInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityCreateManyRedhatInputEnvelope = {
    data: Redhat_VulnerabilityCreateManyRedhatInput | Redhat_VulnerabilityCreateManyRedhatInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_DocumentUpsertWithoutRedhatInput = {
    update: XOR<Redhat_DocumentUpdateWithoutRedhatInput, Redhat_DocumentUncheckedUpdateWithoutRedhatInput>
    create: XOR<Redhat_DocumentCreateWithoutRedhatInput, Redhat_DocumentUncheckedCreateWithoutRedhatInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutRedhatInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutRedhatInput, Redhat_DocumentUncheckedUpdateWithoutRedhatInput>
  }

  export type Redhat_DocumentUpdateWithoutRedhatInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutRedhatInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_VulnerabilityUpsertWithWhereUniqueWithoutRedhatInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    update: XOR<Redhat_VulnerabilityUpdateWithoutRedhatInput, Redhat_VulnerabilityUncheckedUpdateWithoutRedhatInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutRedhatInput, Redhat_VulnerabilityUncheckedCreateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityUpdateWithWhereUniqueWithoutRedhatInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutRedhatInput, Redhat_VulnerabilityUncheckedUpdateWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityUpdateManyWithWhereWithoutRedhatInput = {
    where: Redhat_VulnerabilityScalarWhereInput
    data: XOR<Redhat_VulnerabilityUpdateManyMutationInput, Redhat_VulnerabilityUncheckedUpdateManyWithoutRedhatInput>
  }

  export type Redhat_VulnerabilityScalarWhereInput = {
    AND?: Redhat_VulnerabilityScalarWhereInput | Redhat_VulnerabilityScalarWhereInput[]
    OR?: Redhat_VulnerabilityScalarWhereInput[]
    NOT?: Redhat_VulnerabilityScalarWhereInput | Redhat_VulnerabilityScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability"> | string
    cve?: StringFilter<"Redhat_Vulnerability"> | string
    discovery_date?: StringFilter<"Redhat_Vulnerability"> | string
    release_date?: StringFilter<"Redhat_Vulnerability"> | string
    title?: StringFilter<"Redhat_Vulnerability"> | string
    redhatId?: StringFilter<"Redhat_Vulnerability"> | string
  }

  export type Redhat_AggregateSeverityCreateWithoutDocumentInput = {
    id?: string
    namespace: string
    text: string
  }

  export type Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput = {
    id?: string
    namespace: string
    text: string
  }

  export type Redhat_AggregateSeverityCreateOrConnectWithoutDocumentInput = {
    where: Redhat_AggregateSeverityWhereUniqueInput
    create: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_DistributionCreateWithoutDocumentInput = {
    id?: string
    text: string
    tlpId?: string | null
    tlp?: Redhat_TlpCreateNestedOneWithoutDistributionInput
  }

  export type Redhat_DistributionUncheckedCreateWithoutDocumentInput = {
    id?: string
    text: string
    tlpId?: string | null
    tlp?: Redhat_TlpUncheckedCreateNestedOneWithoutDistributionInput
  }

  export type Redhat_DistributionCreateOrConnectWithoutDocumentInput = {
    where: Redhat_DistributionWhereUniqueInput
    create: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_PublisherCreateWithoutDocumentInput = {
    id?: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
  }

  export type Redhat_PublisherUncheckedCreateWithoutDocumentInput = {
    id?: string
    category: string
    contact_details: string
    issuing_authority: string
    name: string
    namespace: string
  }

  export type Redhat_PublisherCreateOrConnectWithoutDocumentInput = {
    where: Redhat_PublisherWhereUniqueInput
    create: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteCreateWithoutDocumentInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Document_NoteUncheckedCreateWithoutDocumentInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Document_NoteCreateOrConnectWithoutDocumentInput = {
    where: Redhat_Document_NoteWhereUniqueInput
    create: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteCreateManyDocumentInputEnvelope = {
    data: Redhat_Document_NoteCreateManyDocumentInput | Redhat_Document_NoteCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Document_ReferenceCreateWithoutDocumentInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_Document_ReferenceCreateOrConnectWithoutDocumentInput = {
    where: Redhat_Document_ReferenceWhereUniqueInput
    create: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_Document_ReferenceCreateManyDocumentInputEnvelope = {
    data: Redhat_Document_ReferenceCreateManyDocumentInput | Redhat_Document_ReferenceCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type RedhatCreateWithoutDocumentInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    vulnerabilities?: Redhat_VulnerabilityCreateNestedManyWithoutRedhatInput
  }

  export type RedhatUncheckedCreateWithoutDocumentInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    vulnerabilities?: Redhat_VulnerabilityUncheckedCreateNestedManyWithoutRedhatInput
  }

  export type RedhatCreateOrConnectWithoutDocumentInput = {
    where: RedhatWhereUniqueInput
    create: XOR<RedhatCreateWithoutDocumentInput, RedhatUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_TrackingCreateWithoutDocumentInput = {
    id?: string
    current_release_date: string
    ID: string
  }

  export type Redhat_TrackingUncheckedCreateWithoutDocumentInput = {
    id?: string
    current_release_date: string
    ID: string
  }

  export type Redhat_TrackingCreateOrConnectWithoutDocumentInput = {
    where: Redhat_TrackingWhereUniqueInput
    create: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_TrackingCreateManyDocumentInputEnvelope = {
    data: Redhat_TrackingCreateManyDocumentInput | Redhat_TrackingCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_AggregateSeverityUpsertWithoutDocumentInput = {
    update: XOR<Redhat_AggregateSeverityUpdateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_AggregateSeverityCreateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedCreateWithoutDocumentInput>
    where?: Redhat_AggregateSeverityWhereInput
  }

  export type Redhat_AggregateSeverityUpdateToOneWithWhereWithoutDocumentInput = {
    where?: Redhat_AggregateSeverityWhereInput
    data: XOR<Redhat_AggregateSeverityUpdateWithoutDocumentInput, Redhat_AggregateSeverityUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_AggregateSeverityUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_AggregateSeverityUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_DistributionUpsertWithoutDocumentInput = {
    update: XOR<Redhat_DistributionUpdateWithoutDocumentInput, Redhat_DistributionUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_DistributionCreateWithoutDocumentInput, Redhat_DistributionUncheckedCreateWithoutDocumentInput>
    where?: Redhat_DistributionWhereInput
  }

  export type Redhat_DistributionUpdateToOneWithWhereWithoutDocumentInput = {
    where?: Redhat_DistributionWhereInput
    data: XOR<Redhat_DistributionUpdateWithoutDocumentInput, Redhat_DistributionUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_DistributionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
    tlp?: Redhat_TlpUpdateOneWithoutDistributionNestedInput
  }

  export type Redhat_DistributionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
    tlp?: Redhat_TlpUncheckedUpdateOneWithoutDistributionNestedInput
  }

  export type Redhat_PublisherUpsertWithoutDocumentInput = {
    update: XOR<Redhat_PublisherUpdateWithoutDocumentInput, Redhat_PublisherUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_PublisherCreateWithoutDocumentInput, Redhat_PublisherUncheckedCreateWithoutDocumentInput>
    where?: Redhat_PublisherWhereInput
  }

  export type Redhat_PublisherUpdateToOneWithWhereWithoutDocumentInput = {
    where?: Redhat_PublisherWhereInput
    data: XOR<Redhat_PublisherUpdateWithoutDocumentInput, Redhat_PublisherUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_PublisherUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_PublisherUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    contact_details?: StringFieldUpdateOperationsInput | string
    issuing_authority?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    namespace?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_NoteUpsertWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_Document_NoteWhereUniqueInput
    update: XOR<Redhat_Document_NoteUpdateWithoutDocumentInput, Redhat_Document_NoteUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_Document_NoteCreateWithoutDocumentInput, Redhat_Document_NoteUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteUpdateWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_Document_NoteWhereUniqueInput
    data: XOR<Redhat_Document_NoteUpdateWithoutDocumentInput, Redhat_Document_NoteUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_Document_NoteUpdateManyWithWhereWithoutDocumentInput = {
    where: Redhat_Document_NoteScalarWhereInput
    data: XOR<Redhat_Document_NoteUpdateManyMutationInput, Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentInput>
  }

  export type Redhat_Document_NoteScalarWhereInput = {
    AND?: Redhat_Document_NoteScalarWhereInput | Redhat_Document_NoteScalarWhereInput[]
    OR?: Redhat_Document_NoteScalarWhereInput[]
    NOT?: Redhat_Document_NoteScalarWhereInput | Redhat_Document_NoteScalarWhereInput[]
    id?: StringFilter<"Redhat_Document_Note"> | string
    category?: StringFilter<"Redhat_Document_Note"> | string
    text?: StringFilter<"Redhat_Document_Note"> | string
    title?: StringFilter<"Redhat_Document_Note"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Note"> | string | null
  }

  export type Redhat_Document_ReferenceUpsertWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_Document_ReferenceWhereUniqueInput
    update: XOR<Redhat_Document_ReferenceUpdateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_Document_ReferenceCreateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_Document_ReferenceUpdateWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_Document_ReferenceWhereUniqueInput
    data: XOR<Redhat_Document_ReferenceUpdateWithoutDocumentInput, Redhat_Document_ReferenceUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_Document_ReferenceUpdateManyWithWhereWithoutDocumentInput = {
    where: Redhat_Document_ReferenceScalarWhereInput
    data: XOR<Redhat_Document_ReferenceUpdateManyMutationInput, Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentInput>
  }

  export type Redhat_Document_ReferenceScalarWhereInput = {
    AND?: Redhat_Document_ReferenceScalarWhereInput | Redhat_Document_ReferenceScalarWhereInput[]
    OR?: Redhat_Document_ReferenceScalarWhereInput[]
    NOT?: Redhat_Document_ReferenceScalarWhereInput | Redhat_Document_ReferenceScalarWhereInput[]
    id?: StringFilter<"Redhat_Document_Reference"> | string
    category?: StringFilter<"Redhat_Document_Reference"> | string
    summary?: StringFilter<"Redhat_Document_Reference"> | string
    url?: StringFilter<"Redhat_Document_Reference"> | string
    documentId?: StringNullableFilter<"Redhat_Document_Reference"> | string | null
  }

  export type RedhatUpsertWithoutDocumentInput = {
    update: XOR<RedhatUpdateWithoutDocumentInput, RedhatUncheckedUpdateWithoutDocumentInput>
    create: XOR<RedhatCreateWithoutDocumentInput, RedhatUncheckedCreateWithoutDocumentInput>
    where?: RedhatWhereInput
  }

  export type RedhatUpdateToOneWithWhereWithoutDocumentInput = {
    where?: RedhatWhereInput
    data: XOR<RedhatUpdateWithoutDocumentInput, RedhatUncheckedUpdateWithoutDocumentInput>
  }

  export type RedhatUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    vulnerabilities?: Redhat_VulnerabilityUpdateManyWithoutRedhatNestedInput
  }

  export type RedhatUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    vulnerabilities?: Redhat_VulnerabilityUncheckedUpdateManyWithoutRedhatNestedInput
  }

  export type Redhat_TrackingUpsertWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_TrackingWhereUniqueInput
    update: XOR<Redhat_TrackingUpdateWithoutDocumentInput, Redhat_TrackingUncheckedUpdateWithoutDocumentInput>
    create: XOR<Redhat_TrackingCreateWithoutDocumentInput, Redhat_TrackingUncheckedCreateWithoutDocumentInput>
  }

  export type Redhat_TrackingUpdateWithWhereUniqueWithoutDocumentInput = {
    where: Redhat_TrackingWhereUniqueInput
    data: XOR<Redhat_TrackingUpdateWithoutDocumentInput, Redhat_TrackingUncheckedUpdateWithoutDocumentInput>
  }

  export type Redhat_TrackingUpdateManyWithWhereWithoutDocumentInput = {
    where: Redhat_TrackingScalarWhereInput
    data: XOR<Redhat_TrackingUpdateManyMutationInput, Redhat_TrackingUncheckedUpdateManyWithoutDocumentInput>
  }

  export type Redhat_TrackingScalarWhereInput = {
    AND?: Redhat_TrackingScalarWhereInput | Redhat_TrackingScalarWhereInput[]
    OR?: Redhat_TrackingScalarWhereInput[]
    NOT?: Redhat_TrackingScalarWhereInput | Redhat_TrackingScalarWhereInput[]
    id?: StringFilter<"Redhat_Tracking"> | string
    current_release_date?: StringFilter<"Redhat_Tracking"> | string
    ID?: StringFilter<"Redhat_Tracking"> | string
    documentId?: StringNullableFilter<"Redhat_Tracking"> | string | null
  }

  export type Redhat_DocumentCreateWithoutTrackingInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutTrackingInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutTrackingInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutTrackingInput, Redhat_DocumentUncheckedCreateWithoutTrackingInput>
  }

  export type Redhat_DocumentUpsertWithoutTrackingInput = {
    update: XOR<Redhat_DocumentUpdateWithoutTrackingInput, Redhat_DocumentUncheckedUpdateWithoutTrackingInput>
    create: XOR<Redhat_DocumentCreateWithoutTrackingInput, Redhat_DocumentUncheckedCreateWithoutTrackingInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutTrackingInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutTrackingInput, Redhat_DocumentUncheckedUpdateWithoutTrackingInput>
  }

  export type Redhat_DocumentUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutTrackingInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentCreateWithoutAggregate_severityInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutAggregate_severityInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutAggregate_severityInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutAggregate_severityInput, Redhat_DocumentUncheckedCreateWithoutAggregate_severityInput>
  }

  export type Redhat_DocumentUpsertWithoutAggregate_severityInput = {
    update: XOR<Redhat_DocumentUpdateWithoutAggregate_severityInput, Redhat_DocumentUncheckedUpdateWithoutAggregate_severityInput>
    create: XOR<Redhat_DocumentCreateWithoutAggregate_severityInput, Redhat_DocumentUncheckedCreateWithoutAggregate_severityInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutAggregate_severityInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutAggregate_severityInput, Redhat_DocumentUncheckedUpdateWithoutAggregate_severityInput>
  }

  export type Redhat_DocumentUpdateWithoutAggregate_severityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutAggregate_severityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_TlpCreateWithoutDistributionInput = {
    id?: string
    label: string
    url: string
  }

  export type Redhat_TlpUncheckedCreateWithoutDistributionInput = {
    id?: string
    label: string
    url: string
  }

  export type Redhat_TlpCreateOrConnectWithoutDistributionInput = {
    where: Redhat_TlpWhereUniqueInput
    create: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
  }

  export type Redhat_DocumentCreateWithoutDistributionInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutDistributionInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutDistributionInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutDistributionInput, Redhat_DocumentUncheckedCreateWithoutDistributionInput>
  }

  export type Redhat_TlpUpsertWithoutDistributionInput = {
    update: XOR<Redhat_TlpUpdateWithoutDistributionInput, Redhat_TlpUncheckedUpdateWithoutDistributionInput>
    create: XOR<Redhat_TlpCreateWithoutDistributionInput, Redhat_TlpUncheckedCreateWithoutDistributionInput>
    where?: Redhat_TlpWhereInput
  }

  export type Redhat_TlpUpdateToOneWithWhereWithoutDistributionInput = {
    where?: Redhat_TlpWhereInput
    data: XOR<Redhat_TlpUpdateWithoutDistributionInput, Redhat_TlpUncheckedUpdateWithoutDistributionInput>
  }

  export type Redhat_TlpUpdateWithoutDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TlpUncheckedUpdateWithoutDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_DocumentUpsertWithoutDistributionInput = {
    update: XOR<Redhat_DocumentUpdateWithoutDistributionInput, Redhat_DocumentUncheckedUpdateWithoutDistributionInput>
    create: XOR<Redhat_DocumentCreateWithoutDistributionInput, Redhat_DocumentUncheckedCreateWithoutDistributionInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutDistributionInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutDistributionInput, Redhat_DocumentUncheckedUpdateWithoutDistributionInput>
  }

  export type Redhat_DocumentUpdateWithoutDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutDistributionInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DistributionCreateWithoutTlpInput = {
    id?: string
    text: string
    tlpId?: string | null
    document?: Redhat_DocumentCreateNestedOneWithoutDistributionInput
  }

  export type Redhat_DistributionUncheckedCreateWithoutTlpInput = {
    id?: string
    text: string
    documentId?: string | null
    tlpId?: string | null
  }

  export type Redhat_DistributionCreateOrConnectWithoutTlpInput = {
    where: Redhat_DistributionWhereUniqueInput
    create: XOR<Redhat_DistributionCreateWithoutTlpInput, Redhat_DistributionUncheckedCreateWithoutTlpInput>
  }

  export type Redhat_DistributionUpsertWithoutTlpInput = {
    update: XOR<Redhat_DistributionUpdateWithoutTlpInput, Redhat_DistributionUncheckedUpdateWithoutTlpInput>
    create: XOR<Redhat_DistributionCreateWithoutTlpInput, Redhat_DistributionUncheckedCreateWithoutTlpInput>
    where?: Redhat_DistributionWhereInput
  }

  export type Redhat_DistributionUpdateToOneWithWhereWithoutTlpInput = {
    where?: Redhat_DistributionWhereInput
    data: XOR<Redhat_DistributionUpdateWithoutTlpInput, Redhat_DistributionUncheckedUpdateWithoutTlpInput>
  }

  export type Redhat_DistributionUpdateWithoutTlpInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
    document?: Redhat_DocumentUpdateOneWithoutDistributionNestedInput
  }

  export type Redhat_DistributionUncheckedUpdateWithoutTlpInput = {
    id?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    tlpId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_DocumentCreateWithoutNotesInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutNotesInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutNotesInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutNotesInput, Redhat_DocumentUncheckedCreateWithoutNotesInput>
  }

  export type Redhat_DocumentUpsertWithoutNotesInput = {
    update: XOR<Redhat_DocumentUpdateWithoutNotesInput, Redhat_DocumentUncheckedUpdateWithoutNotesInput>
    create: XOR<Redhat_DocumentCreateWithoutNotesInput, Redhat_DocumentUncheckedCreateWithoutNotesInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutNotesInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutNotesInput, Redhat_DocumentUncheckedUpdateWithoutNotesInput>
  }

  export type Redhat_DocumentUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentCreateWithoutPublisherInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutPublisherInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    references?: Redhat_Document_ReferenceUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutPublisherInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutPublisherInput, Redhat_DocumentUncheckedCreateWithoutPublisherInput>
  }

  export type Redhat_DocumentUpsertWithoutPublisherInput = {
    update: XOR<Redhat_DocumentUpdateWithoutPublisherInput, Redhat_DocumentUncheckedUpdateWithoutPublisherInput>
    create: XOR<Redhat_DocumentCreateWithoutPublisherInput, Redhat_DocumentUncheckedCreateWithoutPublisherInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutPublisherInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutPublisherInput, Redhat_DocumentUncheckedUpdateWithoutPublisherInput>
  }

  export type Redhat_DocumentUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutPublisherInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    references?: Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentCreateWithoutReferencesInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteCreateNestedManyWithoutDocumentInput
    redhat?: RedhatCreateNestedOneWithoutDocumentInput
    tracking?: Redhat_TrackingCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentUncheckedCreateWithoutReferencesInput = {
    id?: string
    category: string
    csaf_version: string
    lang: string
    title: string
    redhatId?: string | null
    aggregateSeverityId?: string | null
    distributionId?: string | null
    publisherId?: string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedCreateNestedOneWithoutDocumentInput
    distribution?: Redhat_DistributionUncheckedCreateNestedOneWithoutDocumentInput
    publisher?: Redhat_PublisherUncheckedCreateNestedOneWithoutDocumentInput
    notes?: Redhat_Document_NoteUncheckedCreateNestedManyWithoutDocumentInput
    tracking?: Redhat_TrackingUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type Redhat_DocumentCreateOrConnectWithoutReferencesInput = {
    where: Redhat_DocumentWhereUniqueInput
    create: XOR<Redhat_DocumentCreateWithoutReferencesInput, Redhat_DocumentUncheckedCreateWithoutReferencesInput>
  }

  export type Redhat_DocumentUpsertWithoutReferencesInput = {
    update: XOR<Redhat_DocumentUpdateWithoutReferencesInput, Redhat_DocumentUncheckedUpdateWithoutReferencesInput>
    create: XOR<Redhat_DocumentCreateWithoutReferencesInput, Redhat_DocumentUncheckedCreateWithoutReferencesInput>
    where?: Redhat_DocumentWhereInput
  }

  export type Redhat_DocumentUpdateToOneWithWhereWithoutReferencesInput = {
    where?: Redhat_DocumentWhereInput
    data: XOR<Redhat_DocumentUpdateWithoutReferencesInput, Redhat_DocumentUncheckedUpdateWithoutReferencesInput>
  }

  export type Redhat_DocumentUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUpdateManyWithoutDocumentNestedInput
    redhat?: RedhatUpdateOneWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_DocumentUncheckedUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    csaf_version?: StringFieldUpdateOperationsInput | string
    lang?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregateSeverityId?: NullableStringFieldUpdateOperationsInput | string | null
    distributionId?: NullableStringFieldUpdateOperationsInput | string | null
    publisherId?: NullableStringFieldUpdateOperationsInput | string | null
    aggregate_severity?: Redhat_AggregateSeverityUncheckedUpdateOneWithoutDocumentNestedInput
    distribution?: Redhat_DistributionUncheckedUpdateOneWithoutDocumentNestedInput
    publisher?: Redhat_PublisherUncheckedUpdateOneWithoutDocumentNestedInput
    notes?: Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentNestedInput
    tracking?: Redhat_TrackingUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput = {
    id?: string
    system_name: string
    text: string
  }

  export type Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    system_name: string
    text: string
  }

  export type Redhat_Vulnerability_IdCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_IdWhereUniqueInput
    create: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_IdCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_IdCreateManyVulnerabilityInput | Redhat_Vulnerability_IdCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Vulnerability_NoteCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_NoteWhereUniqueInput
    create: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_NoteCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_NoteCreateManyVulnerabilityInput | Redhat_Vulnerability_NoteCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput = {
    id?: string
    fixed?: Redhat_Vulnerability_ProductStatusCreatefixedInput | string[]
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    fixed?: Redhat_Vulnerability_ProductStatusCreatefixedInput | string[]
  }

  export type Redhat_Vulnerability_ProductStatusCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ProductStatusWhereUniqueInput
    create: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_Vulnerability_ReferenceCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
    create: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInput | Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    restart_required?: Redhat_Vulnerability_RestartRequiredCreateNestedManyWithoutRemediationInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    restart_required?: Redhat_Vulnerability_RestartRequiredUncheckedCreateNestedManyWithoutRemediationInput
  }

  export type Redhat_Vulnerability_RemediationCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
    create: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_RemediationCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_RemediationCreateManyVulnerabilityInput | Redhat_Vulnerability_RemediationCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3CreateNestedOneWithoutScoreInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3UncheckedCreateNestedOneWithoutScoreInput
  }

  export type Redhat_Vulnerability_ScoreCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
    create: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ScoreCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_ScoreCreateManyVulnerabilityInput | Redhat_Vulnerability_ScoreCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    details: string
  }

  export type Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    category: string
    details: string
  }

  export type Redhat_Vulnerability_ThreatCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
    create: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ThreatCreateManyVulnerabilityInputEnvelope = {
    data: Redhat_Vulnerability_ThreatCreateManyVulnerabilityInput | Redhat_Vulnerability_ThreatCreateManyVulnerabilityInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput = {
    id?: string
    cweId: string
    name: string
  }

  export type Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput = {
    id?: string
    cweId: string
    name: string
  }

  export type Redhat_Vulnerability_CweCreateOrConnectWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_CweWhereUniqueInput
    create: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
  }

  export type RedhatCreateWithoutVulnerabilitiesInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    document?: Redhat_DocumentCreateNestedOneWithoutRedhatInput
  }

  export type RedhatUncheckedCreateWithoutVulnerabilitiesInput = {
    id?: string
    RHSA: string
    severity: string
    released_on: string
    CVEs?: RedhatCreateCVEsInput | string[]
    bugzillas?: RedhatCreatebugzillasInput | string[]
    released_packages?: RedhatCreatereleased_packagesInput | string[]
    resource_url: string
    document?: Redhat_DocumentUncheckedCreateNestedOneWithoutRedhatInput
  }

  export type RedhatCreateOrConnectWithoutVulnerabilitiesInput = {
    where: RedhatWhereUniqueInput
    create: XOR<RedhatCreateWithoutVulnerabilitiesInput, RedhatUncheckedCreateWithoutVulnerabilitiesInput>
  }

  export type Redhat_Vulnerability_IdUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_IdWhereUniqueInput
    update: XOR<Redhat_Vulnerability_IdUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_IdCreateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_IdUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_IdWhereUniqueInput
    data: XOR<Redhat_Vulnerability_IdUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_IdUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_IdUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_IdScalarWhereInput
    data: XOR<Redhat_Vulnerability_IdUpdateManyMutationInput, Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_IdScalarWhereInput = {
    AND?: Redhat_Vulnerability_IdScalarWhereInput | Redhat_Vulnerability_IdScalarWhereInput[]
    OR?: Redhat_Vulnerability_IdScalarWhereInput[]
    NOT?: Redhat_Vulnerability_IdScalarWhereInput | Redhat_Vulnerability_IdScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Id"> | string
    system_name?: StringFilter<"Redhat_Vulnerability_Id"> | string
    text?: StringFilter<"Redhat_Vulnerability_Id"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Id"> | string | null
  }

  export type Redhat_Vulnerability_NoteUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_NoteWhereUniqueInput
    update: XOR<Redhat_Vulnerability_NoteUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_NoteCreateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_NoteUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_NoteWhereUniqueInput
    data: XOR<Redhat_Vulnerability_NoteUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_NoteUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_NoteUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_NoteScalarWhereInput
    data: XOR<Redhat_Vulnerability_NoteUpdateManyMutationInput, Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_NoteScalarWhereInput = {
    AND?: Redhat_Vulnerability_NoteScalarWhereInput | Redhat_Vulnerability_NoteScalarWhereInput[]
    OR?: Redhat_Vulnerability_NoteScalarWhereInput[]
    NOT?: Redhat_Vulnerability_NoteScalarWhereInput | Redhat_Vulnerability_NoteScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Note"> | string
    category?: StringFilter<"Redhat_Vulnerability_Note"> | string
    text?: StringFilter<"Redhat_Vulnerability_Note"> | string
    title?: StringFilter<"Redhat_Vulnerability_Note"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Note"> | string | null
  }

  export type Redhat_Vulnerability_ProductStatusUpsertWithoutVulnerabilityInput = {
    update: XOR<Redhat_Vulnerability_ProductStatusUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_ProductStatusCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedCreateWithoutVulnerabilityInput>
    where?: Redhat_Vulnerability_ProductStatusWhereInput
  }

  export type Redhat_Vulnerability_ProductStatusUpdateToOneWithWhereWithoutVulnerabilityInput = {
    where?: Redhat_Vulnerability_ProductStatusWhereInput
    data: XOR<Redhat_Vulnerability_ProductStatusUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ProductStatusUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ProductStatusUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
  }

  export type Redhat_Vulnerability_ProductStatusUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    fixed?: Redhat_Vulnerability_ProductStatusUpdatefixedInput | string[]
  }

  export type Redhat_Vulnerability_ReferenceUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
    update: XOR<Redhat_Vulnerability_ReferenceUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_ReferenceCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ReferenceWhereUniqueInput
    data: XOR<Redhat_Vulnerability_ReferenceUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ReferenceUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ReferenceScalarWhereInput
    data: XOR<Redhat_Vulnerability_ReferenceUpdateManyMutationInput, Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ReferenceScalarWhereInput = {
    AND?: Redhat_Vulnerability_ReferenceScalarWhereInput | Redhat_Vulnerability_ReferenceScalarWhereInput[]
    OR?: Redhat_Vulnerability_ReferenceScalarWhereInput[]
    NOT?: Redhat_Vulnerability_ReferenceScalarWhereInput | Redhat_Vulnerability_ReferenceScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    category?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    summary?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    url?: StringFilter<"Redhat_Vulnerability_Reference"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Reference"> | string | null
  }

  export type Redhat_Vulnerability_RemediationUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
    update: XOR<Redhat_Vulnerability_RemediationUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_RemediationCreateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_RemediationUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
    data: XOR<Redhat_Vulnerability_RemediationUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_RemediationUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_RemediationUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_RemediationScalarWhereInput
    data: XOR<Redhat_Vulnerability_RemediationUpdateManyMutationInput, Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_RemediationScalarWhereInput = {
    AND?: Redhat_Vulnerability_RemediationScalarWhereInput | Redhat_Vulnerability_RemediationScalarWhereInput[]
    OR?: Redhat_Vulnerability_RemediationScalarWhereInput[]
    NOT?: Redhat_Vulnerability_RemediationScalarWhereInput | Redhat_Vulnerability_RemediationScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    category?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    details?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
    product_ids?: StringNullableListFilter<"Redhat_Vulnerability_Remediation">
    url?: StringNullableFilter<"Redhat_Vulnerability_Remediation"> | string | null
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Remediation"> | string
  }

  export type Redhat_Vulnerability_ScoreUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
    update: XOR<Redhat_Vulnerability_ScoreUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_ScoreCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ScoreUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
    data: XOR<Redhat_Vulnerability_ScoreUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ScoreUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ScoreUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ScoreScalarWhereInput
    data: XOR<Redhat_Vulnerability_ScoreUpdateManyMutationInput, Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ScoreScalarWhereInput = {
    AND?: Redhat_Vulnerability_ScoreScalarWhereInput | Redhat_Vulnerability_ScoreScalarWhereInput[]
    OR?: Redhat_Vulnerability_ScoreScalarWhereInput[]
    NOT?: Redhat_Vulnerability_ScoreScalarWhereInput | Redhat_Vulnerability_ScoreScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Score"> | string
    products?: StringNullableListFilter<"Redhat_Vulnerability_Score">
    vulnerabilityId?: StringFilter<"Redhat_Vulnerability_Score"> | string
  }

  export type Redhat_Vulnerability_ThreatUpsertWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
    update: XOR<Redhat_Vulnerability_ThreatUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_ThreatCreateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedCreateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ThreatUpdateWithWhereUniqueWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ThreatWhereUniqueInput
    data: XOR<Redhat_Vulnerability_ThreatUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_ThreatUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ThreatUpdateManyWithWhereWithoutVulnerabilityInput = {
    where: Redhat_Vulnerability_ThreatScalarWhereInput
    data: XOR<Redhat_Vulnerability_ThreatUpdateManyMutationInput, Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_ThreatScalarWhereInput = {
    AND?: Redhat_Vulnerability_ThreatScalarWhereInput | Redhat_Vulnerability_ThreatScalarWhereInput[]
    OR?: Redhat_Vulnerability_ThreatScalarWhereInput[]
    NOT?: Redhat_Vulnerability_ThreatScalarWhereInput | Redhat_Vulnerability_ThreatScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    category?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    details?: StringFilter<"Redhat_Vulnerability_Threat"> | string
    vulnerabilityId?: StringNullableFilter<"Redhat_Vulnerability_Threat"> | string | null
  }

  export type Redhat_Vulnerability_CweUpsertWithoutVulnerabilityInput = {
    update: XOR<Redhat_Vulnerability_CweUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedUpdateWithoutVulnerabilityInput>
    create: XOR<Redhat_Vulnerability_CweCreateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedCreateWithoutVulnerabilityInput>
    where?: Redhat_Vulnerability_CweWhereInput
  }

  export type Redhat_Vulnerability_CweUpdateToOneWithWhereWithoutVulnerabilityInput = {
    where?: Redhat_Vulnerability_CweWhereInput
    data: XOR<Redhat_Vulnerability_CweUpdateWithoutVulnerabilityInput, Redhat_Vulnerability_CweUncheckedUpdateWithoutVulnerabilityInput>
  }

  export type Redhat_Vulnerability_CweUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CweUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    cweId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type RedhatUpsertWithoutVulnerabilitiesInput = {
    update: XOR<RedhatUpdateWithoutVulnerabilitiesInput, RedhatUncheckedUpdateWithoutVulnerabilitiesInput>
    create: XOR<RedhatCreateWithoutVulnerabilitiesInput, RedhatUncheckedCreateWithoutVulnerabilitiesInput>
    where?: RedhatWhereInput
  }

  export type RedhatUpdateToOneWithWhereWithoutVulnerabilitiesInput = {
    where?: RedhatWhereInput
    data: XOR<RedhatUpdateWithoutVulnerabilitiesInput, RedhatUncheckedUpdateWithoutVulnerabilitiesInput>
  }

  export type RedhatUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUpdateOneWithoutRedhatNestedInput
  }

  export type RedhatUncheckedUpdateWithoutVulnerabilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    RHSA?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    released_on?: StringFieldUpdateOperationsInput | string
    CVEs?: RedhatUpdateCVEsInput | string[]
    bugzillas?: RedhatUpdatebugzillasInput | string[]
    released_packages?: RedhatUpdatereleased_packagesInput | string[]
    resource_url?: StringFieldUpdateOperationsInput | string
    document?: Redhat_DocumentUncheckedUpdateOneWithoutRedhatNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutIdsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutIdsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutIdsInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutIdsInput, Redhat_VulnerabilityUncheckedCreateWithoutIdsInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutIdsInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutIdsInput, Redhat_VulnerabilityUncheckedUpdateWithoutIdsInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutIdsInput, Redhat_VulnerabilityUncheckedCreateWithoutIdsInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutIdsInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutIdsInput, Redhat_VulnerabilityUncheckedUpdateWithoutIdsInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutIdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutIdsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutNotesInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutNotesInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutNotesInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutNotesInput, Redhat_VulnerabilityUncheckedCreateWithoutNotesInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutNotesInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutNotesInput, Redhat_VulnerabilityUncheckedUpdateWithoutNotesInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutNotesInput, Redhat_VulnerabilityUncheckedCreateWithoutNotesInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutNotesInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutNotesInput, Redhat_VulnerabilityUncheckedUpdateWithoutNotesInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutProduct_statusInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutProduct_statusInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutProduct_statusInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedCreateWithoutProduct_statusInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutProduct_statusInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedUpdateWithoutProduct_statusInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedCreateWithoutProduct_statusInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutProduct_statusInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutProduct_statusInput, Redhat_VulnerabilityUncheckedUpdateWithoutProduct_statusInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutProduct_statusInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutProduct_statusInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutReferencesInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutReferencesInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutReferencesInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutReferencesInput, Redhat_VulnerabilityUncheckedCreateWithoutReferencesInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutReferencesInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutReferencesInput, Redhat_VulnerabilityUncheckedUpdateWithoutReferencesInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutReferencesInput, Redhat_VulnerabilityUncheckedCreateWithoutReferencesInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutReferencesInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutReferencesInput, Redhat_VulnerabilityUncheckedUpdateWithoutReferencesInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutReferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutRemediationsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutRemediationsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutRemediationsInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedCreateWithoutRemediationsInput>
  }

  export type Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput = {
    id?: string
    category?: string
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput = {
    id?: string
    category?: string
  }

  export type Redhat_Vulnerability_RestartRequiredCreateOrConnectWithoutRemediationInput = {
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    create: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput>
  }

  export type Redhat_Vulnerability_RestartRequiredCreateManyRemediationInputEnvelope = {
    data: Redhat_Vulnerability_RestartRequiredCreateManyRemediationInput | Redhat_Vulnerability_RestartRequiredCreateManyRemediationInput[]
    skipDuplicates?: boolean
  }

  export type Redhat_VulnerabilityUpsertWithoutRemediationsInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedUpdateWithoutRemediationsInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedCreateWithoutRemediationsInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutRemediationsInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutRemediationsInput, Redhat_VulnerabilityUncheckedUpdateWithoutRemediationsInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutRemediationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_Vulnerability_RestartRequiredUpsertWithWhereUniqueWithoutRemediationInput = {
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    update: XOR<Redhat_Vulnerability_RestartRequiredUpdateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateWithoutRemediationInput>
    create: XOR<Redhat_Vulnerability_RestartRequiredCreateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedCreateWithoutRemediationInput>
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateWithWhereUniqueWithoutRemediationInput = {
    where: Redhat_Vulnerability_RestartRequiredWhereUniqueInput
    data: XOR<Redhat_Vulnerability_RestartRequiredUpdateWithoutRemediationInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateWithoutRemediationInput>
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateManyWithWhereWithoutRemediationInput = {
    where: Redhat_Vulnerability_RestartRequiredScalarWhereInput
    data: XOR<Redhat_Vulnerability_RestartRequiredUpdateManyMutationInput, Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyWithoutRemediationInput>
  }

  export type Redhat_Vulnerability_RestartRequiredScalarWhereInput = {
    AND?: Redhat_Vulnerability_RestartRequiredScalarWhereInput | Redhat_Vulnerability_RestartRequiredScalarWhereInput[]
    OR?: Redhat_Vulnerability_RestartRequiredScalarWhereInput[]
    NOT?: Redhat_Vulnerability_RestartRequiredScalarWhereInput | Redhat_Vulnerability_RestartRequiredScalarWhereInput[]
    id?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    category?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
    remediationId?: StringFilter<"Redhat_Vulnerability_RestartRequired"> | string
  }

  export type Redhat_Vulnerability_RemediationCreateWithoutRestart_requiredInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutRemediationsInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedCreateWithoutRestart_requiredInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
    vulnerabilityId: string
  }

  export type Redhat_Vulnerability_RemediationCreateOrConnectWithoutRestart_requiredInput = {
    where: Redhat_Vulnerability_RemediationWhereUniqueInput
    create: XOR<Redhat_Vulnerability_RemediationCreateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutRestart_requiredInput>
  }

  export type Redhat_Vulnerability_RemediationUpsertWithoutRestart_requiredInput = {
    update: XOR<Redhat_Vulnerability_RemediationUpdateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedUpdateWithoutRestart_requiredInput>
    create: XOR<Redhat_Vulnerability_RemediationCreateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedCreateWithoutRestart_requiredInput>
    where?: Redhat_Vulnerability_RemediationWhereInput
  }

  export type Redhat_Vulnerability_RemediationUpdateToOneWithWhereWithoutRestart_requiredInput = {
    where?: Redhat_Vulnerability_RemediationWhereInput
    data: XOR<Redhat_Vulnerability_RemediationUpdateWithoutRestart_requiredInput, Redhat_Vulnerability_RemediationUncheckedUpdateWithoutRestart_requiredInput>
  }

  export type Redhat_Vulnerability_RemediationUpdateWithoutRestart_requiredInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutRemediationsNestedInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateWithoutRestart_requiredInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CvssV3CreateWithoutScoreInput = {
    id?: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
  }

  export type Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput = {
    id?: string
    attackComplexity: string
    attackVector: string
    availabilityImpact: string
    baseScore: number
    baseSeverity: string
    confidentialityImpact: string
    integrityImpact: string
    privilegesRequired: string
    scope: string
    userInteraction: string
    vectorString: string
    version: string
  }

  export type Redhat_Vulnerability_CvssV3CreateOrConnectWithoutScoreInput = {
    where: Redhat_Vulnerability_CvssV3WhereUniqueInput
    create: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
  }

  export type Redhat_VulnerabilityCreateWithoutScoresInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutScoresInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutScoresInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutScoresInput, Redhat_VulnerabilityUncheckedCreateWithoutScoresInput>
  }

  export type Redhat_Vulnerability_CvssV3UpsertWithoutScoreInput = {
    update: XOR<Redhat_Vulnerability_CvssV3UpdateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedUpdateWithoutScoreInput>
    create: XOR<Redhat_Vulnerability_CvssV3CreateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedCreateWithoutScoreInput>
    where?: Redhat_Vulnerability_CvssV3WhereInput
  }

  export type Redhat_Vulnerability_CvssV3UpdateToOneWithWhereWithoutScoreInput = {
    where?: Redhat_Vulnerability_CvssV3WhereInput
    data: XOR<Redhat_Vulnerability_CvssV3UpdateWithoutScoreInput, Redhat_Vulnerability_CvssV3UncheckedUpdateWithoutScoreInput>
  }

  export type Redhat_Vulnerability_CvssV3UpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_CvssV3UncheckedUpdateWithoutScoreInput = {
    id?: StringFieldUpdateOperationsInput | string
    attackComplexity?: StringFieldUpdateOperationsInput | string
    attackVector?: StringFieldUpdateOperationsInput | string
    availabilityImpact?: StringFieldUpdateOperationsInput | string
    baseScore?: IntFieldUpdateOperationsInput | number
    baseSeverity?: StringFieldUpdateOperationsInput | string
    confidentialityImpact?: StringFieldUpdateOperationsInput | string
    integrityImpact?: StringFieldUpdateOperationsInput | string
    privilegesRequired?: StringFieldUpdateOperationsInput | string
    scope?: StringFieldUpdateOperationsInput | string
    userInteraction?: StringFieldUpdateOperationsInput | string
    vectorString?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_VulnerabilityUpsertWithoutScoresInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutScoresInput, Redhat_VulnerabilityUncheckedUpdateWithoutScoresInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutScoresInput, Redhat_VulnerabilityUncheckedCreateWithoutScoresInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutScoresInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutScoresInput, Redhat_VulnerabilityUncheckedUpdateWithoutScoresInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutScoresInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_Vulnerability_ScoreCreateWithoutCvss_v3Input = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    vulnerability?: Redhat_VulnerabilityCreateNestedOneWithoutScoresInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedCreateWithoutCvss_v3Input = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
    vulnerabilityId: string
  }

  export type Redhat_Vulnerability_ScoreCreateOrConnectWithoutCvss_v3Input = {
    where: Redhat_Vulnerability_ScoreWhereUniqueInput
    create: XOR<Redhat_Vulnerability_ScoreCreateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedCreateWithoutCvss_v3Input>
  }

  export type Redhat_Vulnerability_ScoreUpsertWithoutCvss_v3Input = {
    update: XOR<Redhat_Vulnerability_ScoreUpdateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedUpdateWithoutCvss_v3Input>
    create: XOR<Redhat_Vulnerability_ScoreCreateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedCreateWithoutCvss_v3Input>
    where?: Redhat_Vulnerability_ScoreWhereInput
  }

  export type Redhat_Vulnerability_ScoreUpdateToOneWithWhereWithoutCvss_v3Input = {
    where?: Redhat_Vulnerability_ScoreWhereInput
    data: XOR<Redhat_Vulnerability_ScoreUpdateWithoutCvss_v3Input, Redhat_Vulnerability_ScoreUncheckedUpdateWithoutCvss_v3Input>
  }

  export type Redhat_Vulnerability_ScoreUpdateWithoutCvss_v3Input = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    vulnerability?: Redhat_VulnerabilityUpdateOneWithoutScoresNestedInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateWithoutCvss_v3Input = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    vulnerabilityId?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_VulnerabilityCreateWithoutThreatsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweCreateNestedOneWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutThreatsInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    cwe?: Redhat_Vulnerability_CweUncheckedCreateNestedOneWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutThreatsInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutThreatsInput, Redhat_VulnerabilityUncheckedCreateWithoutThreatsInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutThreatsInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutThreatsInput, Redhat_VulnerabilityUncheckedUpdateWithoutThreatsInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutThreatsInput, Redhat_VulnerabilityUncheckedCreateWithoutThreatsInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutThreatsInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutThreatsInput, Redhat_VulnerabilityUncheckedUpdateWithoutThreatsInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutThreatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutThreatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateWithoutCweInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    ids?: Redhat_Vulnerability_IdCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatCreateNestedManyWithoutVulnerabilityInput
    redhat?: RedhatCreateNestedOneWithoutVulnerabilitiesInput
  }

  export type Redhat_VulnerabilityUncheckedCreateWithoutCweInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
    redhatId: string
    ids?: Redhat_Vulnerability_IdUncheckedCreateNestedManyWithoutVulnerabilityInput
    notes?: Redhat_Vulnerability_NoteUncheckedCreateNestedManyWithoutVulnerabilityInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedCreateNestedOneWithoutVulnerabilityInput
    references?: Redhat_Vulnerability_ReferenceUncheckedCreateNestedManyWithoutVulnerabilityInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedCreateNestedManyWithoutVulnerabilityInput
    scores?: Redhat_Vulnerability_ScoreUncheckedCreateNestedManyWithoutVulnerabilityInput
    threats?: Redhat_Vulnerability_ThreatUncheckedCreateNestedManyWithoutVulnerabilityInput
  }

  export type Redhat_VulnerabilityCreateOrConnectWithoutCweInput = {
    where: Redhat_VulnerabilityWhereUniqueInput
    create: XOR<Redhat_VulnerabilityCreateWithoutCweInput, Redhat_VulnerabilityUncheckedCreateWithoutCweInput>
  }

  export type Redhat_VulnerabilityUpsertWithoutCweInput = {
    update: XOR<Redhat_VulnerabilityUpdateWithoutCweInput, Redhat_VulnerabilityUncheckedUpdateWithoutCweInput>
    create: XOR<Redhat_VulnerabilityCreateWithoutCweInput, Redhat_VulnerabilityUncheckedCreateWithoutCweInput>
    where?: Redhat_VulnerabilityWhereInput
  }

  export type Redhat_VulnerabilityUpdateToOneWithWhereWithoutCweInput = {
    where?: Redhat_VulnerabilityWhereInput
    data: XOR<Redhat_VulnerabilityUpdateWithoutCweInput, Redhat_VulnerabilityUncheckedUpdateWithoutCweInput>
  }

  export type Redhat_VulnerabilityUpdateWithoutCweInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    redhat?: RedhatUpdateOneWithoutVulnerabilitiesNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutCweInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    redhatId?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityCreateManyRedhatInput = {
    id?: string
    cve: string
    discovery_date: string
    release_date: string
    title: string
  }

  export type Redhat_VulnerabilityUpdateWithoutRedhatInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateWithoutRedhatInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    ids?: Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityNestedInput
    notes?: Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityNestedInput
    product_status?: Redhat_Vulnerability_ProductStatusUncheckedUpdateOneWithoutVulnerabilityNestedInput
    references?: Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityNestedInput
    remediations?: Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityNestedInput
    scores?: Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityNestedInput
    threats?: Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityNestedInput
    cwe?: Redhat_Vulnerability_CweUncheckedUpdateOneWithoutVulnerabilityNestedInput
  }

  export type Redhat_VulnerabilityUncheckedUpdateManyWithoutRedhatInput = {
    id?: StringFieldUpdateOperationsInput | string
    cve?: StringFieldUpdateOperationsInput | string
    discovery_date?: StringFieldUpdateOperationsInput | string
    release_date?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_NoteCreateManyDocumentInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Document_ReferenceCreateManyDocumentInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_TrackingCreateManyDocumentInput = {
    id?: string
    current_release_date: string
    ID: string
  }

  export type Redhat_Document_NoteUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_NoteUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_NoteUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_ReferenceUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_ReferenceUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Document_ReferenceUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TrackingUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TrackingUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_TrackingUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    current_release_date?: StringFieldUpdateOperationsInput | string
    ID?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_IdCreateManyVulnerabilityInput = {
    id?: string
    system_name: string
    text: string
  }

  export type Redhat_Vulnerability_NoteCreateManyVulnerabilityInput = {
    id?: string
    category: string
    text: string
    title: string
  }

  export type Redhat_Vulnerability_ReferenceCreateManyVulnerabilityInput = {
    id?: string
    category: string
    summary: string
    url: string
  }

  export type Redhat_Vulnerability_RemediationCreateManyVulnerabilityInput = {
    id?: string
    category: string
    details: string
    product_ids?: Redhat_Vulnerability_RemediationCreateproduct_idsInput | string[]
    url?: string | null
  }

  export type Redhat_Vulnerability_ScoreCreateManyVulnerabilityInput = {
    id?: string
    products?: Redhat_Vulnerability_ScoreCreateproductsInput | string[]
  }

  export type Redhat_Vulnerability_ThreatCreateManyVulnerabilityInput = {
    id?: string
    category: string
    details: string
  }

  export type Redhat_Vulnerability_IdUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_IdUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_IdUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    system_name?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_NoteUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_NoteUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_NoteUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    text?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ReferenceUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ReferenceUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ReferenceUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RemediationUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    restart_required?: Redhat_Vulnerability_RestartRequiredUpdateManyWithoutRemediationNestedInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
    restart_required?: Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyWithoutRemediationNestedInput
  }

  export type Redhat_Vulnerability_RemediationUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
    product_ids?: Redhat_Vulnerability_RemediationUpdateproduct_idsInput | string[]
    url?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Redhat_Vulnerability_ScoreUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3UpdateOneWithoutScoreNestedInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
    cvss_v3?: Redhat_Vulnerability_CvssV3UncheckedUpdateOneWithoutScoreNestedInput
  }

  export type Redhat_Vulnerability_ScoreUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    products?: Redhat_Vulnerability_ScoreUpdateproductsInput | string[]
  }

  export type Redhat_Vulnerability_ThreatUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ThreatUncheckedUpdateWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_ThreatUncheckedUpdateManyWithoutVulnerabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    details?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredCreateManyRemediationInput = {
    id?: string
    category?: string
  }

  export type Redhat_Vulnerability_RestartRequiredUpdateWithoutRemediationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedUpdateWithoutRemediationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }

  export type Redhat_Vulnerability_RestartRequiredUncheckedUpdateManyWithoutRemediationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use RedhatCountOutputTypeDefaultArgs instead
     */
    export type RedhatCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RedhatCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_DocumentCountOutputTypeDefaultArgs instead
     */
    export type Redhat_DocumentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_DocumentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_VulnerabilityCountOutputTypeDefaultArgs instead
     */
    export type Redhat_VulnerabilityCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_VulnerabilityCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_RemediationCountOutputTypeDefaultArgs instead
     */
    export type Redhat_Vulnerability_RemediationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_RemediationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use vmwareDefaultArgs instead
     */
    export type vmwareArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = vmwareDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ciscoDefaultArgs instead
     */
    export type ciscoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ciscoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use oracleDefaultArgs instead
     */
    export type oracleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = oracleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use microsoftDefaultArgs instead
     */
    export type microsoftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = microsoftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use hackernewsDefaultArgs instead
     */
    export type hackernewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = hackernewsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RedhatDefaultArgs instead
     */
    export type RedhatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RedhatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_DocumentDefaultArgs instead
     */
    export type Redhat_DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_DocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_TrackingDefaultArgs instead
     */
    export type Redhat_TrackingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_TrackingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_AggregateSeverityDefaultArgs instead
     */
    export type Redhat_AggregateSeverityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_AggregateSeverityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_DistributionDefaultArgs instead
     */
    export type Redhat_DistributionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_DistributionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_TlpDefaultArgs instead
     */
    export type Redhat_TlpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_TlpDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Document_NoteDefaultArgs instead
     */
    export type Redhat_Document_NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Document_NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_PublisherDefaultArgs instead
     */
    export type Redhat_PublisherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_PublisherDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Document_ReferenceDefaultArgs instead
     */
    export type Redhat_Document_ReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Document_ReferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_VulnerabilityDefaultArgs instead
     */
    export type Redhat_VulnerabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_VulnerabilityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_IdDefaultArgs instead
     */
    export type Redhat_Vulnerability_IdArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_IdDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_NoteDefaultArgs instead
     */
    export type Redhat_Vulnerability_NoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_NoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_ProductStatusDefaultArgs instead
     */
    export type Redhat_Vulnerability_ProductStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_ProductStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_ReferenceDefaultArgs instead
     */
    export type Redhat_Vulnerability_ReferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_ReferenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_RemediationDefaultArgs instead
     */
    export type Redhat_Vulnerability_RemediationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_RemediationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_RestartRequiredDefaultArgs instead
     */
    export type Redhat_Vulnerability_RestartRequiredArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_RestartRequiredDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_ScoreDefaultArgs instead
     */
    export type Redhat_Vulnerability_ScoreArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_ScoreDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_CvssV3DefaultArgs instead
     */
    export type Redhat_Vulnerability_CvssV3Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_CvssV3DefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_ThreatDefaultArgs instead
     */
    export type Redhat_Vulnerability_ThreatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_ThreatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use Redhat_Vulnerability_CweDefaultArgs instead
     */
    export type Redhat_Vulnerability_CweArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Redhat_Vulnerability_CweDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}